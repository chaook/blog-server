/*
Navicat MySQL Data Transfer

Source Server         : mysql
Source Server Version : 80017
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 80017
File Encoding         : 65001

Date: 2021-08-22 14:12:25
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for t_about
-- ----------------------------
DROP TABLE IF EXISTS `t_about`;
CREATE TABLE `t_about` (
  `image` varchar(255) DEFAULT NULL,
  `qq` varchar(12) DEFAULT NULL,
  `wechat` varchar(255) DEFAULT NULL,
  `about_me` varchar(255) DEFAULT NULL,
  `record` varchar(255) DEFAULT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_about
-- ----------------------------

-- ----------------------------
-- Table structure for t_blog
-- ----------------------------
DROP TABLE IF EXISTS `t_blog`;
CREATE TABLE `t_blog` (
  `blog_id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `outline` varchar(255) DEFAULT NULL,
  `author` varchar(255) DEFAULT NULL,
  `image` varchar(255) DEFAULT NULL,
  `is_published` tinyint(1) NOT NULL DEFAULT '1',
  `views` int(11) NOT NULL DEFAULT '0',
  `type_id` int(11) DEFAULT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_blog
-- ----------------------------
INSERT INTO `t_blog` VALUES ('2', 'Maven 基础用法', '\r\n\r\n## maven解决的问题\r\n\r\n### 一个项目就是一个工程\r\n\r\n如果项目非常庞大，就不适合使用package来划分模块，最好是每一个模块对应一个工程，利于分工协作。借助于maven就可以将一个项目拆分成多个工程\r\n\r\n### 项目中使用jar包，需要“复制”、“粘贴”项目的lib中\r\n\r\n同样的jar包重复的出现在不同的项目工程中，你需要做不停的复制粘贴的重复工作。借助于maven，可以将jar包保存在“仓库”中，不管在哪个项目只要使用引用即可就行。\r\n\r\n###  jar包需要的时候每次都要自己准备好或到官网下载\r\n\r\n借助于maven我们可以使用统一的规范方式下载jar包，规范\r\n\r\n### jar包版本不一致的风险\r\n\r\n不同的项目在使用jar包的时候，有可能会导致各个项目的jar包版本不一致，导致未执行错误。借助于maven，所有的jar包都放在“仓库”中，所有的项目都使用仓库的一份jar包。\r\n\r\n### 一个jar包依赖其他的jar包需要自己手动的加入到项目中\r\n\r\n借助于maven，它会自动的将依赖的jar包导入进来。\r\n\r\n##  构建的各个环节\r\n\r\n- 清理clean：将以前编译得到的旧文件class字节码文件删除\r\n\r\n- 编译compile：将java源程序编译成class字节码文件\r\n\r\n- 测试test：自动测试，自动调用junit程序\r\n\r\n- 报告report：测试程序执行的结果\r\n\r\n- 打包package：动态Web工程打War包，java工程打jar包\r\n\r\n- 安装install：Maven特定的概念-----将打包得到的文件复制到“仓库”中的指定位置\r\n\r\n- 部署deploy：将动态Web工程生成的war包复制到Servlet容器下，使其可以运行\r\n\r\n## 依赖范围\r\n\r\n| scope    | 说明                                          | 示例            |\r\n| :------- | :-------------------------------------------- | :-------------- |\r\n| compile  | 编译时需要用到该jar包（默认）                 | commons-logging |\r\n| test     | 编译Test时需要用到该jar包                     | junit           |\r\n| runtime  | 编译时不需要，但运行时需要用到                | mysql           |\r\n| provided | 编译时需要用到，但运行时由JDK或某个服务器提供 | servlet-api     |\r\n\r\n## 唯一ID\r\n\r\n- groupId：属于组织的名称，类似Java的包名；\r\n- artifactId：该jar包自身的名称，类似Java的类名；\r\n- version：该jar包的版本。\r\n\r\n## Maven镜像\r\n\r\n在.m2目录下的setting.xml文件\r\n\r\n```\r\n<settings>\r\n    <mirrors>\r\n        <mirror>\r\n            <id>aliyun</id>\r\n            <name>aliyun</name>\r\n            <mirrorOf>central</mirrorOf>\r\n            <!-- 国内推荐阿里云的Maven镜像 -->\r\n            <url>https://maven.aliyun.com/repository/central</url>\r\n        </mirror>\r\n    </mirrors>\r\n</settings>\r\n```', 'Maven 最基本的用法', '鸡米花', 'IMG_3331.JPG', '1', '2', '6', '2021-06-10 20:06:30', '2021-06-10 20:06:30');
INSERT INTO `t_blog` VALUES ('3', 'Spring 核心内容', '# 1. 容器\r\n\r\n## 1. 生命周期回调\r\n\r\n### 1. 初始化回调\r\n\r\n1. Bean实现` org.springframework.beans.factory.InitializingBean `接口（不推荐，因为代码会和spring耦合）\r\n2. 使用` @PostConstruct ` 注解\r\n3. 在XML配置文件` <bean>` 标签设置` init-method `属性，属性值为无返回值、无参方法的方法名，例:\r\n\r\n```xml\r\n<bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/>\r\n```\r\n\r\n```java\r\npublic class ExampleBean {\r\n	public void init() {\r\n		// do some initialization work\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n### 2. 销毁回调\r\n\r\n1. Bean实现` org.springframework.beans.factory.DisposableBean` 接口（不推荐，因为代码会和spring耦合）\r\n2. 使用` @PreDestroy ` 注解\r\n3. 在XML配置文件` <bean>` 标签设置` destroy-method `属性，属性值为无返回值、无参方法的方法名\r\n\r\n### 3. 默认回调函数\r\n\r\n在XML文件设置 ` <beans> `标签的` default-init-method `属性（\r\n\r\n销毁回调和初始化回调相似）例：\r\n\r\n```xml\r\n<beans default-init-method=\"init\">\r\n	<bean id=\"blogService\" 				class=\"com.something.DefaultBlogService\">\r\n		<property name=\"blogDao\" ref=\"blogDao\" />\r\n	</bean>\r\n</beans>\r\n```\r\n\r\n\r\n\r\n### 4.启动和关闭回调\r\n\r\n实现 ` Lifecycle  `接口的bean会在启动和关闭时调用相应的方法，注意：容器内的热刷新不会触发该接口的回调。\r\n\r\n\r\n\r\n## 2. 基于注解的配置\r\n\r\n### @Required\r\n\r\n设置在需要注入的属性的setter方法上面（从Spring5.1起已被弃用），例：\r\n\r\n``` java\r\npublic class SimpleMovieLister {\r\n	private MovieFinder movieFinder;\r\n	@Required\r\n	public void setMovieFinder(MovieFinder 	movieFinder) {\r\n		this.movieFinder = movieFinder;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n### @Autowired\r\n\r\nAutowired注解会在当前容器查找合适的bean自动注入，如果找不到会抛出异常，可以给注解添加上`equired = false`避免无匹配的bean时抛出异常，例：\r\n\r\n``` java\r\npublic class SimpleMovieLister {\r\n    \r\n	private MovieFinder movieFinder;\r\n    \r\n	@Autowired(required = false)\r\n	public void setMovieFinder(MovieFinder movieFinder) {\r\n		this.movieFinder = movieFinder;\r\n	}\r\n}\r\n```\r\n\r\n也可以用 Java8 的` java.util.Optional`来设置需要注入的依赖可空，例：\r\n\r\n``` java\r\npublic class SimpleMovieLister {\r\n	@Autowired\r\n	public void setMovieFinder(Optional<MovieFinder> movieFinder) {\r\n	}\r\n}\r\n```\r\n\r\n在Spring5.0后，可以用` @Nullable` 注解来表示依赖项可空，例：\r\n\r\n``` java\r\npublic class SimpleMovieLister {\r\n	@Autowired\r\n	public void setMovieFinder(@Nullable MovieFinder movieFinder) {\r\n	}\r\n}\r\n```\r\n\r\n@Autowired 可以用在：\r\n\r\n1. 构造器上面\r\n2. 任意参数类型、参数数量的方法上\r\n3. 类属性上，属性可以是数组、Set、字符串为键的Map（bean的名称和键名匹配）。可以让需要注入的bean实现` org.springframework.core.Ordered  `接口、添加` @Order`或者` @Priority` 注解来决定集合中bean的顺序，否者顺序为bean在容器注册时的顺序。\r\n\r\n### @Primary\r\n\r\n按类型自动装配时遇到多个可装配的bean会抛出异常，可以使用` @Primary`注解修饰bean定义，同类型bean定义最多只能有一个带该注解。自动装配时遇到多个同类型bean时会选择带有` @Primary`注解的bean。例：\r\n\r\n``` java\r\n@Configuration\r\npublic class MovieConfiguration {\r\n	@Bean\r\n	@Primary\r\n	public MovieCatalog firstMovieCatalog() { ... }\r\n	@Bean\r\n	public MovieCatalog secondMovieCatalog() { ... }\r\n}\r\n```\r\n\r\n``` xml\r\n<bean class=\"example.SimpleMovieCatalog\" primary=\"true\">\r\n</bean>\r\n<bean class=\"example.SimpleMovieCatalog\">\r\n</bean>\r\n```\r\n\r\n\r\n\r\n### @Qualifiers\r\n\r\n您可以将` @Qualifiers` 注解的值与特定的参数关联起来，缩小类型匹配的范围，以便为每个参数选择特定的bean。例：\r\n\r\n自动配置属性：\r\n\r\n``` java\r\npublic class MovieRecommender {\r\n	@Autowired\r\n	@Qualifier(\"main\")\r\n	private MovieCatalog movieCatalog;\r\n}\r\n```\r\n\r\n自动配置方法参数：\r\n\r\n``` java\r\npublic class MovieRecommender {\r\n	private MovieCatalog movieCatalog;\r\n	private CustomerPreferenceDao customerPreferenceDao;\r\n    @Autowired\r\n	public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog,\r\n		CustomerPreferenceDao customerPreferenceDao) {\r\n		this.movieCatalog = movieCatalog;\r\n		this.customerPreferenceDao = customerPreferenceDao;\r\n	}\r\n}\r\n```\r\n\r\n\r\n\r\n对应XML的bean定义：\r\n\r\n``` xml\r\n<bean class=\"example.SimpleMovieCatalog\">\r\n	<qualifier value=\"main\"/> \r\n</bean>\r\n<bean class=\"example.SimpleMovieCatalog\">\r\n	<qualifier value=\"action\"/> \r\n</bean>\r\n```\r\n\r\n### @Resource\r\n\r\n` @Resource`注解默认以bean名字查找相应的bean。\r\n\r\n` @Resource `注解可以用在字段和setter方法上，可以提供参数` name = xxx`（可以省略name），例：\r\n\r\n``` java\r\npublic class SimpleMovieLister {\r\n	private MovieFinder movieFinder;\r\n	@Resource(name=\"myMovieFinder\") \r\n	public void setMovieFinder(MovieFinder movieFinder) {\r\n	this.movieFinder = movieFinder;\r\n	}\r\n}\r\n```\r\n\r\n若没有提供参数，则默认以字段名或setter方法名为bean名。\r\n\r\n ## 3. 类路径扫描和组件管理\r\n\r\n#### @Component\r\n\r\n使用` @Component`注解的类会被扫描到Spring容器内，该注解相当于XML里面的` <beans>`标签。\r\n\r\n#### 扫描过滤器\r\n\r\n可以通过扫描过滤器来包含或者排除部分类，扫描过滤器有以下五种类型：\r\n\r\n| 过滤器类型             | 表达式示例                 | 描述                                                         |\r\n| ---------------------- | -------------------------- | ------------------------------------------------------------ |\r\n| annotation（默认类型） | org.example.SomeAnnotation | 用在component级别上的注解。                                  |\r\n| assignable             | org.example.SomeClass      | component上的类                                              |\r\n| aspectj                | org.example..*Service+     | component上的AspectJ表达式                                   |\r\n| regex                  | org\\.example\\.Default.*    | 匹配类名的正则表达式                                         |\r\n| custom                 | org.example.MyTypeFilter   | 实现` org.springframework.core.type .TypeFilter`接口的自定义过滤器 |\r\n\r\nJava 类配置示例，该示例排除了用` @Repository`注解的类，包含“stub”的持久层：\r\n\r\n``` java\r\n@Configuration\r\n@ComponentScan(basePackages = \"org.example\",\r\n	includeFilters = @Filter(type = FilterType.REGEX, pattern = \".*Stub.*Repository\"),\r\n	excludeFilters = @Filter(Repository.class))\r\npublic class AppConfig {\r\n}\r\n```\r\n\r\n等价XML配置文件：\r\n\r\n``` xml\r\n<beans>\r\n	<context:component-scan base-package=\"org.example\">\r\n	<context:include-filter type=\"regex\"\r\n		expression=\".*Stub.*Repository\"/>\r\n	<context:exclude-filter type=\"annotation\"\r\n		expression=\"org.springframework.stereotype.Repository\"/>\r\n	</context:component-scan>\r\n</beans>\r\n```\r\n\r\n## 4. 基于Java的配置\r\n\r\n### 使用AnnotationConfigApplicationContext 初始化容器\r\n\r\n` AnnotationConfigApplicationContext`可以接受` @Configuration`、` @Component`和任意JSR-330支持的注解。例：\r\n\r\n``` java\r\npublic static void main(String[] args) {\r\n	ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl\r\n		.class, Dependency1.class, Dependency2.class);\r\n	MyService myService = ctx.getBean(MyService.class);\r\n	myService.doStuff();\r\n}\r\n```\r\n\r\n另一种注册方式：\r\n\r\n``` java\r\npublic static void main(String[] args) {\r\n	AnnotationConfigApplicationContext ctx = new\r\n	AnnotationConfigApplicationContext();\r\n	ctx.register(AppConfig.class, OtherConfig.class);\r\n	ctx.register(AdditionalConfig.class);\r\n	ctx.refresh();\r\n	MyService myService = ctx.getBean(MyService.class);\r\n	myService.doStuff();\r\n}\r\n```\r\n\r\n### @Bean注解\r\n\r\n` @Bean`是一个方法级别的注解，等价于XML文件的` <bean/>`元素，可以用在带有` @Configuratin` 或` @Component`注解的类。\r\n\r\n由该注解声明的bean默认名字为方法名，可以使用`name`属性给bean命名，例：\r\n\r\n```java\r\n@Configuration\r\npublic class AppConfig {\r\n	@Bean(naem = \"myTransferService\")\r\n	public TransferServiceImpl transferService() {\r\n		return new TransferServiceImpl();\r\n	}\r\n}\r\n```\r\n\r\n和下面XML文件等价：\r\n\r\n```xml\r\n<beans>\r\n	<bean id=\"myTransferService\" class=\"com.acme.TransferServiceImpl\"/>\r\n</beans>\r\n```\r\n\r\n` @bean`可以用在有任意数量参数的方法，用来表示创建该bean所需的依赖，例：\r\n\r\n```java\r\n@Configuration\r\npublic class AppConfig {\r\n	@Bean\r\npublic TransferService transferService(AccountRepository accountRepository) {\r\n	return new TransferServiceImpl(accountRepository);\r\n	}\r\n}\r\n```\r\n\r\n# 2. 资源\r\n\r\n### ResourceLoader\r\n\r\n所有 application contexts 都实现了`ResourceLoader`接口。因此，所有 application contexts 都可以用来获取` Resource`实例。具体获取到的实例取决于application contexts的具体类型，也可以使用前缀来强制使用相应类型的Resource。有以下前缀：\r\n\r\n| 前缀       | 示例                           |\r\n| ---------- | ------------------------------ |\r\n| classpath: | classpath:com/myapp/config.xml |\r\n| file:      | file:///data/config.xml        |\r\n| http:      | https://myserver/logo.png      |\r\n| (none)     | /data/config.xml               |\r\n\r\n\r\n\r\n### FileSystemResource\r\n\r\nFileSystemApplicationContext 强制所有的 FileSystemResource 都为相对路径，也就是说下面例子是相同的：\r\n\r\n``` java\r\nApplicationContext ctx = new FileSystemXmlApplicationContext(\"conf/context.xml\");\r\n```\r\n\r\n``` java\r\nApplicationContext ctx = new FileSystemXmlApplicationContext(\"/conf/context.xml\");\r\n```\r\n\r\n如果想要用绝对路径，可以避免使用FileSystemResource 和 FileSystemXmlApplicationContext  ，或者可以用 `file:`前缀，例：\r\n\r\n``` java\r\nApplicationContext ctx = new FileSystemXmlApplicationContext(\"file:///conf/context.xml\");\r\n```\r\n\r\n# 3. 面向切面编程\r\n\r\n## 1. 基本名词\r\n\r\n###  切面\r\n\r\n跨越多个类的关注的模块化，在Spring AOP中，切面是通过常规类或`@Asect`注解的类来实现的。\r\n\r\n### 连接点\r\n\r\n执行过程中的一个点，比如方法执行或异常处理，Spring AOP 中总是代表一个方法执行。\r\n\r\n### 通知\r\n\r\n切面在特定的连接点上采取的动作。包含有前置通知、返回通知、环绕通知，许多AOP框架，包括Spring，将通知建模为拦截器，围绕连接点维护拦截器链。\r\n\r\n### 切入点\r\n\r\n匹配连接点的述语。通知与切入点表达式相关联，并在切入点匹配的任何连接点上运行。\r\n\r\n### 引入\r\n\r\n代表类型声明其他方法或字段。Spring AOP允许您为任何建议的对象引入新接口(和相应的实现)。\r\n\r\n### 目标对象\r\n\r\n由一个或多个方面通知的对象。也称为“建议对象”。由于Spring AOP是通过使用运行时代理实现的，因此该对象始终是一个代理对象。\r\n\r\n### AOP代理\r\n\r\nAOP框架为了实现方面契约而创建的对象(通知方法执行等)。在Spring框架中，AOP代理是JDK动态代理或CGLIB代理。\r\n\r\n### 编织\r\n\r\n将切面与其他应用程序类型或对象链接以创建建议的对象。这可以在编译时(例如，使用AspectJ编译器)、加载时或运行时完成。与其他纯Java AOP框架一样，Spring AOP在运行时执行编织。\r\n\r\n## 2. 通知类型\r\n\r\n### 前置通知\r\n\r\n在连接点之前运行的通知，但不能阻止执行流继续到连接点(除非抛出异常)。\r\n\r\n### 返回通知\r\n\r\n连接点正常完成后运行的通知(例如，如果方法返回而没有引发异常)。\r\n\r\n### 异常通知\r\n\r\n在方法通过抛出异常退出时执行的通知。\r\n\r\n### 后置通知\r\n\r\n无论连接点以何种方式退出的通知(正常或异常回报)。类似finally。\r\n\r\n### 环绕通知\r\n\r\n环绕通知可以在方法调用前后执行自定义行为。它还负责选择是继续执行连接点，还是通过返回自己的返回值或抛出异常来终止目标方法的执行。\r\n\r\n## 3. 指示器\r\n\r\n使用注解类型限制时要用全限定名。\r\n\r\n| 指示器      | 描述                                                         |\r\n| ----------- | ------------------------------------------------------------ |\r\n| execution   | 用于匹配方法执行连接点。这是在使用Spring AOP时要使用的主要切入点指示器。 |\r\n| within      | 限制匹配到特定类型中的连接点(使用Spring AOP时，在匹配类型中声明的方法的执行)。within(it) it作用对象必须是对象，在方法失效 |\r\n| this        | 限制匹配到连接点，其中bean引用(Spring AOP代理)是给定类型的一个实例。 |\r\n| target      | 限制匹配到连接点，其中目标对象(被代理的应用程序对象)是给定类型的一个实例。 |\r\n| args        | 限制匹配到连接点，其中参数是给定类型的实例。                 |\r\n| @target     | 限制匹配到连接点，其中执行对象的类具有给定类型的**注解**。   |\r\n| @args       | 限制匹配到连接点，其中传递的实际参数的运行时类型具有给定类型的**注解**。 |\r\n| @within     | 限制匹配到具有给定**注解**的类型内的连接点(使用Spring AOP时使用给定注解在类型中声明的方法的执行)。 |\r\n| @annotation | 限制匹配到连接点，连接点的主题具有给定的**注解**。           |\r\n\r\n#### execution示例\r\n\r\n```java\r\nexecution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)\r\n          throws-pattern?)\r\n```\r\n\r\n除了返回类型、名称和参数，其它都是可以省略的。`name-pattern`精确到方法名而不是类名。\r\n\r\n`*`  可以表示所有返回类型、可以作为名称中的所有或部分、任意类型的参数（注意，不是任意个数）。\r\n\r\n`()` 匹配没有参数的方法。\r\n\r\n` (..)` 匹配有任意个数参数的方法。\r\n\r\n* 匹配到任意public的方法：\r\n\r\n  ```java\r\n  execution(public * *(..))\r\n  ```\r\n\r\n* 匹配到任意以`set`开头的方法：\r\n\r\n  ```java\r\n  execution(* set*(..))\r\n  ```\r\n\r\n* 匹配到任意`AccountService`接口定义的所有方法：\r\n\r\n  ```java\r\n  execution(* com.xyz.service.AccountService.*(..))\r\n  ```\r\n\r\n* 匹配到service包及其子包的所有方法：\r\n\r\n  ```java\r\n  execution(* com.xyz.service..*.*(..))\r\n  ```\r\n\r\n  \r\n\r\n', '阅读 Spring 官方 spring-core 的笔记', '鸡米花', 'IMG_3331.JPG', '1', '4', '5', '2021-07-22 15:44:27', '2021-08-23 16:58:27');
INSERT INTO `t_blog` VALUES ('4', 'MyBatis 学习笔记', '# 入门\r\n\r\nmaven 引入依赖\r\n\r\n``` xml\r\n<dependency>\r\n  <groupId>org.mybatis</groupId>\r\n  <artifactId>mybatis</artifactId>\r\n  <version>x.x.x</version>\r\n</dependency>\r\n```\r\n\r\n## 从 XML 中构建 SqlSessionFactory\r\n\r\n建议使用类路径下的资源文件进行配置。\r\n\r\n但也可以使用任意的输入流（InputStream）实例，MyBatis包含了Resource工具类。\r\n\r\n```  java\r\nString resource = \"org/mybatis/example/mybatis-config.xml\";\r\nInputStream inputStream = Resources.getResourceAsStream(resource);\r\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);\r\n```\r\n\r\nXML最关键部分包含：\r\n\r\n``` xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE configuration\r\n  PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-config.dtd\">\r\n<configuration>\r\n  <environments default=\"development\">\r\n    <environment id=\"development\">\r\n      <transactionManager type=\"JDBC\"/>\r\n      <dataSource type=\"POOLED\">\r\n        <property name=\"driver\" value=\"${driver}\"/>\r\n        <property name=\"url\" value=\"${url}\"/>\r\n        <property name=\"username\" value=\"${username}\"/>\r\n        <property name=\"password\" value=\"${password}\"/>\r\n      </dataSource>\r\n    </environment>\r\n  </environments>\r\n  <mappers>\r\n    <mapper resource=\"org/mybatis/example/BlogMapper.xml\"/>\r\n  </mappers>\r\n</configuration>\r\n```\r\n\r\n## 从 Java 代码构建 SqlSessionFactory\r\n\r\n先将关键的 DataSource 和 TransactionFactory 添加到一个Environment 中，再将 Environment 添加到 Configuration 中，最后通过 SqlSeesionFactoryBuilder 创建。\r\n\r\n```java\r\nDataSource dataSource = BlogDataSourceFactory.getBlogDataSource();\r\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\r\nEnvironment environment = new Environment(\"development\", transactionFactory, dataSource);\r\nConfiguration configuration = new Configuration(environment);\r\nconfiguration.addMapper(BlogMapper.class);\r\nSqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);\r\n```\r\n\r\n## 从SqlSessionFactory 中获取 SqlSeesion\r\n\r\n旧版本写法：\r\n\r\n```java\r\ntry (SqlSession session = sqlSessionFactory.openSession()) {\r\n  Blog blog = (Blog) session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);\r\n}\r\n```\r\n\r\n新版本写法：\r\n\r\n```java\r\ntry (SqlSession session = sqlSessionFactory.openSession()) {\r\n  BlogMapper mapper = session.getMapper(BlogMapper.class);\r\n  Blog blog = mapper.selectBlog(101);\r\n}\r\n```\r\n\r\n**try 括号中的变量会自动 close ，但是要实现 AutoClosable 接口。**\r\n\r\n## 映射 SQL 语句\r\n\r\n基于 XML ：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\r\n<!DOCTYPE mapper\r\n  PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\r\n  \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\r\n<mapper namespace=\"org.mybatis.example.BlogMapper\">\r\n  <select id=\"selectBlog\" resultType=\"Blog\">\r\n    select * from Blog where id = #{id}\r\n  </select>\r\n</mapper>\r\n```\r\n\r\n基于注解：\r\n\r\n```java\r\npackage org.mybatis.example;\r\npublic interface BlogMapper {\r\n  @Select(\"SELECT * FROM blog WHERE id = #{id}\")\r\n  Blog selectBlog(int id);\r\n}\r\n```\r\n\r\n如果语句复杂，基于注解的映射会变得很混乱。\r\n\r\n## 作用域和生命周期\r\n\r\n- SqlSessionFactoryBuilder \r\n\r\n  建议方法作用域，以便用完后释放 XML 解析资源\r\n\r\n- SqlSessionFactory \r\n\r\n  不建议多次重建该实例，推荐应用作用域，可以使用单例或静态单例\r\n\r\n- SqlSession \r\n\r\n  线程不安全，不能被共享。该实例绝对不能放在类的静态域，甚至类变量都不行。\r\n\r\n- 映射器实例 \r\n\r\n  最大作用域和创建他们的 SqlSession 相同，到那时应该使用方法作用域。\r\n\r\n\r\n\r\n# XML 配置\r\n\r\n顶层结构：\r\n\r\n- configuration（配置）\r\n  - properties（属性）\r\n  - settings（设置）\r\n  - typeAliases（类型别名）\r\n  - typeHandlers（类型处理器）\r\n  - objectFactory（对象工厂）\r\n  - plugins（插件）\r\n  - environments（环境配置）\r\n    - environment（环境变量）\r\n      - transactionManager（事务管理器）\r\n      - dataSource（数据源）\r\n  - databaseIdProvider（数据库厂商标识）\r\n  - mappers（映射器）\r\n\r\n## 属性\r\n\r\n可以在外部配置，进行动态替换。也可以在 properties 的子元素中设置：\r\n\r\n```xml\r\n<properties resource=\"org/mybatis/example/config.properties\">\r\n  <property name=\"username\" value=\"dev_user\"/>\r\n  <property name=\"password\" value=\"F2Fa3!33TYyg\"/>\r\n</properties>\r\n```\r\n\r\n在配置文件引用属性：\r\n\r\n```xml\r\n<dataSource type=\"POOLED\">\r\n  <property name=\"username\" value=\"${username}\"/>\r\n</dataSource>\r\n```\r\n\r\n在方法中传入属性：\r\n\r\n```java\r\nSqlSessionFactory factory = new SqlSessionFactoryBuilder().build(reader, props);\r\n```\r\n\r\n属性加载顺序：\r\n\r\n1. 读取在 properties 元素体中的属性\r\n2. properties 中的 resource 属性类路径下的文件。或 url 属性指定的类路径下的文件。\r\n3. 作为方法参数传递的属性。\r\n\r\n**后面读取的属性会覆盖前面读取的属性**\r\n\r\n所以方法参数传递的属性有最高优先级。\r\n\r\n## 设置\r\n\r\n部分常用settings，详细内容在 [MyBatis3-配置]([mybatis – MyBatis 3 | 配置](https://mybatis.org/mybatis-3/zh/configuration.html))\r\n\r\n| 设置名                            | 描述                                                         | 有效值                                                       | 默认值                         |\r\n| :-------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------- |\r\n| cacheEnabled                      | 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。     | true \\| false                                                | true                           |\r\n| lazyLoadingEnabled                | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 `fetchType` 属性来覆盖该项的开关状态。 | true \\| false                                                | false                          |\r\n| autoMappingBehavior               | 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 | NONE, PARTIAL, FULL                                          | PARTIAL                        |\r\n| autoMappingUnknown-ColumnBehavior | 指定发现自动映射目标未知列（或未知属性类型）的行为。`NONE`: 不做任何反应`WARNING`: 输出警告日志（`\'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior\'` 的日志等级必须设置为 `WARN`）`FAILING`: 映射失败 (抛出 `SqlSessionException`) | NONE, WARNING, FAILING                                       | NONE                           |\r\n| defaultStatementTimeout           | 设置超时时间，它决定数据库驱动等待数据库响应的秒数。         | 任意正整数                                                   | 未设置 (null)                  |\r\n| mapUnderscoreTo-CamelCase         | 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 | true \\| false                                                | false                          |\r\n| lazyLoadTriggerMethods            | 指定对象的哪些方法触发一次延迟加载。                         | 用逗号分隔的方法列表。                                       | equals,clone,hashCode,toString |\r\n| returnInstanceForEmptyRow         | 当返回行的所有列都是空时，MyBatis默认返回 `null`。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） | true \\| false                                                | false                          |\r\n| logPrefix                         | 指定 MyBatis 增加到日志名称的前缀。                          | 任何字符串                                                   | 未设置                         |\r\n| logImpl                           | 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。        | SLF4J \\| LOG4J \\| LOG4J2 \\| JDK_LOGGING \\| COMMONS_LOGGING \\| STDOUT_LOGGING \\| NO_LOGGING | 未设置                         |\r\n\r\n配置示例：\r\n\r\n```xml\r\n<settings>\r\n  <setting name=\"lazyLoadingEnabled\" value=\"true\"/>\r\n</settings>\r\n```\r\n\r\n## 类型别名\r\n\r\n仅用于 XML 配置，例如：\r\n\r\n```xml\r\n<typeAliases>\r\n  <typeAlias alias=\"Author\" type=\"domain.blog.Author\"/>\r\n</typeAliases>\r\n```\r\n\r\n也可以指定为包名，比如：\r\n\r\n```xml\r\n<typeAliases>\r\n  <package name=\"domain.blog\"/>\r\n</typeAliases>\r\n```\r\n\r\n在包没有注解的情况下，会使用 Bean 的首字母小写的类名来作为它的别名。如果有注解会使用注解值。例如：\r\n\r\n```java\r\n@Alias(\"author\")\r\npublic class Author {\r\n    ...\r\n}\r\n```\r\n\r\n## 类型处理器\r\n\r\n在设置预处理语句参数或从结果集中取出一个值时，都会用类型处理器将获取到的值以合适的方式转换成 Java类型。详细内容见 [MyBatis3-配置]([mybatis – MyBatis 3 | 配置](https://mybatis.org/mybatis-3/zh/configuration.html)) 。\r\n\r\n可以实现 `org.apache.ibatis.type.TypeHandler` 接口或继承 `org.apache.ibatis.type.BaseTypeHandler` 类来重写或创建类型处理器。比如：\r\n\r\n```Java\r\n// ExampleTypeHandler.java\r\n@MappedJdbcTypes(JdbcType.VARCHAR)\r\npublic class ExampleTypeHandler extends BaseTypeHandler<String> {\r\n\r\n  @Override\r\n  public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {\r\n    ps.setString(i, parameter);\r\n  }\r\n\r\n  @Override\r\n  public String getNullableResult(ResultSet rs, String columnName) throws SQLException {\r\n    return rs.getString(columnName);\r\n  }\r\n\r\n  @Override\r\n  public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException {\r\n    return rs.getString(columnIndex);\r\n  }\r\n\r\n  @Override\r\n  public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {\r\n    return cs.getString(columnIndex);\r\n  }\r\n}\r\n```\r\n\r\n```xml\r\n<!-- mybatis-config.xml -->\r\n<typeHandlers>\r\n  <typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/>\r\n</typeHandlers>\r\n```\r\n\r\n通过类型处理器的泛型，MyBatis 可以得知该类型处理器处理的 Java 类型，不过这种行为可以通过两种方法改变：\r\n\r\n- 在类型处理器的配置元素（typeHandler 元素）上增加一个 `javaType` 属性（比如：`javaType=\"String\"`）；（高优先级）\r\n- 在类型处理器的类上增加一个 `@MappedTypes` 注解指定与其关联的 Java 类型列表。 \r\n\r\n可以通过两种方式来指定关联的 JDBC 类型：\r\n\r\n- 在类型处理器的配置元素上增加一个 `jdbcType` 属性（比如：`jdbcType=\"VARCHAR\"`）；（高优先级）\r\n- 在类型处理器的类上增加一个 `@MappedJdbcTypes` 注解指定与其关联的 JDBC 类型列表。\r\n\r\n## 处理枚举类型\r\n\r\n可以在 `EnumTypeHandler` 或者 `EnumOrdinalTypeHandler` 中选一个来用。默认情况会选前者。\r\n\r\n`EnumTypeHandler` 会处理任意继承 `Enum` 的类。\r\n\r\n如果不想存储名字的话，可以在配置文件中把 `EnumOrdinalTypeHandler` 加到 `typeHandlers` 中。\r\n\r\n```xml\r\n<typeHandlers>\r\n  <typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\" javaType=\"java.math.RoundingMode\"/>\r\n</typeHandlers>\r\n```\r\n\r\n如果配置了 `EnumOrdinalTypeHandler` 自动映射器会自动选用它，如果想用普通的 `EnumTypeHandler` ，就必须在 result 的 typeHandler 属性中显示指定。\r\n\r\n## 对象工厂\r\n\r\n每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。\r\n\r\n```xml\r\n<objectFactory type=\"org.mybatis.example.ExampleObjectFactory\">\r\n  <property name=\"someProperty\" value=\"100\"/>\r\n</objectFactory>\r\n```\r\n\r\n## 插件\r\n\r\nMyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：\r\n\r\n- Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)\r\n- ParameterHandler (getParameterObject, setParameters)\r\n- ResultSetHandler (handleResultSets, handleOutputParameters)\r\n- StatementHandler (prepare, parameterize, batch, update, query)\r\n\r\n修改和重写这些方法可以能会破坏 MyBatis 的核心模块，这些都时更底层的类和方法，所以使用插件的时候要特别当心。\r\n\r\n使用这些插件是很简单的，只需要实现 Interceptor 接口，并指定想要拦截的方法。\r\n\r\n```java\r\n@Intercepts({@Signature(\r\n    type= Executor.class,\r\n    method = \"update\",\r\n    args = {MappedStatement.class,Object.class})})\r\npublic class ExamplePlugin implements Interceptor {\r\n\r\n    private Properties properties = new Properties();\r\n\r\n    public Object intercept(Invocation invocation) throws Throwable {\r\n        // implement pre processing if need\r\n        Object returnObject = invocation.proceed();\r\n        // implement post processing if need\r\n        return returnObject;\r\n    }\r\n\r\n    public void setProperties(Properties properties) {\r\n        this.properties = properties;\r\n    }\r\n}\r\n```\r\n\r\n```xml\r\n<plugins>\r\n    <plugin interceptor=\"org.mybatis.example.ExamplePlugin\">\r\n        <property name=\"someProperty\" value=\"100\"/>\r\n    </plugin>\r\n</plugins>\r\n```\r\n\r\n## 环境配置\r\n\r\n每个 SqlSessionFactory 实例只能选择一种环境，所以如果想要连接两个数据库，就需要创建两个 SqlSessionFactory。\r\n\r\n为了指定创建哪种环境，只要将它作为可选的参数传递给 SqlSessionFactoryBuilder 即可。\r\n\r\n```xml\r\n<environments default=\"development\">\r\n  <environment id=\"development\">\r\n    <transactionManager type=\"JDBC\">\r\n      <property name=\"...\" value=\"...\"/>\r\n    </transactionManager>\r\n    <dataSource type=\"POOLED\">\r\n      <property name=\"url\" value=\"${url}\"/>\r\n    </dataSource>\r\n  </environment>\r\n</environments>\r\n```\r\n\r\n### 事务管理器\r\n\r\n在 MyBatis 中有两种类型的事务管理器（也就是 type=\"[JDBC|MANAGED]\"）：\r\n\r\n- JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。\r\n- MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。\r\n\r\n**提示** *如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。*\r\n\r\n### 数据源\r\n\r\n有三种内建的数据源类型（也就是 type=\"[UNPOOLED|POOLED|JNDI]\"）：\r\n\r\n#### UNPOOLED\r\n\r\n这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序，或者一些连接池不重要的数据库来说，是一个很好的选择。 UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：\r\n\r\n- `driver` – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。 \r\n- `url` – 这是数据库的 JDBC URL 地址。\r\n- `username` – 登录数据库的用户名。\r\n- `password` – 登录数据库的密码。\r\n- `defaultTransactionIsolationLevel` – 默认的连接事务隔离级别。\r\n- `defaultNetworkTimeout` – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。\r\n\r\n作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：\r\n\r\n- `driver.encoding=UTF8`\r\n\r\n这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 `UTF8` 的 `encoding` 属性给数据库驱动。这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值。\r\n\r\n#### POOLED\r\n\r\n这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。\r\n\r\n除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：\r\n\r\n- `poolMaximumActiveConnections` – 在任意时间可存在的活动（正在使用）连接数量，默认值：10\r\n- `poolMaximumIdleConnections` – 任意时间可能存在的空闲连接数。\r\n- `poolMaximumCheckoutTime` – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）\r\n- `poolTimeToWait` – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。\r\n- `poolMaximumLocalBadConnectionTolerance` – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 `poolMaximumIdleConnections` 与 `poolMaximumLocalBadConnectionTolerance` 之和。 默认值：3（新增于 3.4.5）\r\n- `poolPingQuery` – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。\r\n- `poolPingEnabled` – 是否启用侦测查询。若开启，需要设置 `poolPingQuery` 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。\r\n- `poolPingConnectionsNotUsedFor` – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。\r\n\r\n#### JNDI \r\n\r\n这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：\r\n\r\n- `initial_context` – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。\r\n- `data_source` – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。\r\n\r\n和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如：\r\n\r\n- `env.encoding=UTF8`\r\n\r\n你可以通过实现接口 `org.apache.ibatis.datasource.DataSourceFactory` 来使用第三方数据源实现：\r\n\r\n```java\r\npublic interface DataSourceFactory {\r\n    void setProperties(Properties props);\r\n    DataSource getDataSource();\r\n}\r\n```\r\n\r\n## 数据库厂商标识\r\n\r\n MyBatis 会加载带有匹配当前数据库 `databaseId` 属性和所有不带 `databaseId` 属性的语句。 如果同时找到带有 `databaseId` 和不带 `databaseId` 的相同语句，则后者会被舍弃。\r\n\r\n```xml\r\n<databaseIdProvider type=\"DB_VENDOR\" />\r\n```\r\n\r\ndatabaseIdProvider 对应的 DB_VENDOR 实现会将 databaseId 设置为 `DatabaseMetaData#getDatabaseProductName()` 返回的字符串。 由于通常情况下这些字符串都非常长，而且相同产品的不同版本会返回不同的值，你可能想通过设置属性别名来使其变短：\r\n\r\n```xml\r\n<databaseIdProvider type=\"DB_VENDOR\">\r\n  <property name=\"SQL Server\" value=\"sqlserver\"/>\r\n  <property name=\"DB2\" value=\"db2\"/>\r\n  <property name=\"Oracle\" value=\"oracle\" />\r\n</databaseIdProvider>\r\n```\r\n\r\n## 映射器\r\n\r\n为了直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 `file:///` 形式的 URL），或类名和包名等。例如：\r\n\r\n```xml\r\n<!-- 使用相对于类路径的资源引用 -->\r\n<mappers>\r\n  <mapper resource=\"org/mybatis/builder/BlogMapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n```xml\r\n<!-- 使用完全限定资源定位符（URL） -->\r\n<mappers>\r\n  <mapper url=\"file:///var/mappers/BlogMapper.xml\"/>\r\n</mappers>\r\n```\r\n\r\n```xml\r\n<!-- 使用映射器接口实现类的完全限定类名 -->\r\n<mappers>\r\n  <mapper class=\"org.mybatis.builder.BlogMapper\"/>\r\n</mappers>\r\n```\r\n\r\n```xml\r\n<!-- 将包内的映射器接口实现全部注册为映射器 -->\r\n<mappers>\r\n  <package name=\"org.mybatis.builder\"/>\r\n</mappers>\r\n```\r\n\r\n# XML 映射文件\r\n\r\nSQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：\r\n\r\n- `cache` – 该命名空间的缓存配置。\r\n- `cache-ref` – 引用其它命名空间的缓存配置。\r\n- `resultMap` – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。\r\n- ~~`parameterMap` – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。~~\r\n- `sql` – 可被其它语句引用的可重用语句块。\r\n- `insert` – 映射插入语句。\r\n- `update` – 映射更新语句。\r\n- `delete` – 映射删除语句。\r\n- `select` – 映射查询语句。\r\n\r\n## select\r\n\r\n一个简单查询的 select 元素是非常简单的。比如：\r\n\r\n```xml\r\n<select id=\"selectPerson\" parameterType=\"int\" resultType=\"hashmap\">\r\n  SELECT * FROM PERSON WHERE ID = #{id}\r\n</select>\r\n```\r\n\r\n这就告诉 MyBatis 创建一个预处理语句（PreparedStatement）参数，在 JDBC 中，这样的一个参数在 SQL 中会由一个“?”来标识，并被传递到一个新的预处理语句中，就像这样：\r\n\r\n```java\r\n// 近似的 JDBC 代码，非 MyBatis 代码...\r\nString selectPerson = \"SELECT * FROM PERSON WHERE ID=?\";\r\nPreparedStatement ps = conn.prepareStatement(selectPerson);\r\nps.setInt(1,id);\r\n```\r\n\r\nselect 元素允许你配置很多属性来配置每条语句的行为细节。\r\n\r\n```xml\r\n<select\r\n  id=\"selectPerson\"\r\n  parameterType=\"int\"\r\n  parameterMap=\"deprecated\"\r\n  resultType=\"hashmap\"\r\n  resultMap=\"personResultMap\"\r\n  flushCache=\"false\"\r\n  useCache=\"true\"\r\n  timeout=\"10\"\r\n  fetchSize=\"256\"\r\n  statementType=\"PREPARED\"\r\n  resultSetType=\"FORWARD_ONLY\">\r\n```\r\n\r\n| 属性             | 描述                                                         |\r\n| :--------------- | :----------------------------------------------------------- |\r\n| `id`             | 在命名空间中唯一的标识符，可以被用来引用这条语句。           |\r\n| `parameterType`  | 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 |\r\n| ~~parameterMap~~ | ~~用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。~~ |\r\n| `resultType`     | 期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。 |\r\n| `resultMap`      | 对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。 |\r\n| `flushCache`     | 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。 |\r\n| `useCache`       | 将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。 |\r\n| `timeout`        | 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 |\r\n| `fetchSize`      | 这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。 |\r\n| `statementType`  | 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 |\r\n| `resultSetType`  | FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。 |\r\n| `databaseId`     | 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 |\r\n| `resultOrdered`  | 这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：`false`。 |\r\n| `resultSets`     | 这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。 |\r\n\r\n## insert， update 和 delete\r\n\r\n数据变更语句 insert，update 和 delete 的实现非常接近：\r\n\r\n```xml\r\n<insert\r\n  id=\"insertAuthor\"\r\n  parameterType=\"domain.blog.Author\"\r\n  flushCache=\"true\"\r\n  statementType=\"PREPARED\"\r\n  keyProperty=\"\"\r\n  keyColumn=\"\"\r\n  useGeneratedKeys=\"\"\r\n  timeout=\"20\">\r\n\r\n<update\r\n  id=\"updateAuthor\"\r\n  parameterType=\"domain.blog.Author\"\r\n  flushCache=\"true\"\r\n  statementType=\"PREPARED\"\r\n  timeout=\"20\">\r\n\r\n<delete\r\n  id=\"deleteAuthor\"\r\n  parameterType=\"domain.blog.Author\"\r\n  flushCache=\"true\"\r\n  statementType=\"PREPARED\"\r\n  timeout=\"20\">\r\n```\r\n\r\n| 属性               | 描述                                                         |\r\n| :----------------- | :----------------------------------------------------------- |\r\n| `id`               | 在命名空间中唯一的标识符，可以被用来引用这条语句。           |\r\n| `parameterType`    | 将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。 |\r\n| ~~`parameterMap`~~ | ~~用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。~~ |\r\n| `flushCache`       | 将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。 |\r\n| `timeout`          | 这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。 |\r\n| `statementType`    | 可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。 |\r\n| `useGeneratedKeys` | （仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。 |\r\n| `keyProperty`      | （仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（`unset`）。如果生成列不止一个，可以用逗号分隔多个属性名称。 |\r\n| `keyColumn`        | （仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。 |\r\n| `databaseId`       | 如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。 |\r\n\r\n首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。\r\n\r\n```xml\r\n<insert id=\"insertAuthor\" useGeneratedKeys=\"true\"\r\n    keyProperty=\"id\">\r\n  insert into Author (username,password,email,bio)\r\n  values (#{username},#{password},#{email},#{bio})\r\n</insert>\r\n```\r\n\r\n## sql\r\n\r\n这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。比如：\r\n\r\n```xml\r\n<sql id=\"userColumns\"> ${alias}.id,${alias}.username,${alias}.password </sql>\r\n```\r\n\r\n这个 SQL 片段可以在其它语句中使用，例如：\r\n\r\n```xml\r\n<select id=\"selectUsers\" resultType=\"map\">\r\n  select\r\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t1\"/></include>,\r\n    <include refid=\"userColumns\"><property name=\"alias\" value=\"t2\"/></include>\r\n  from some_table t1\r\n    cross join some_table t2\r\n</select>\r\n```\r\n\r\n## 参数\r\n\r\n首先，和 MyBatis 的其它部分一样，参数也可以指定一个特殊的数据类型。\r\n\r\n```java\r\n#{property,javaType=int,jdbcType=NUMERIC}\r\n```\r\n\r\nMyBatis 几乎总是可以根据参数对象的类型确定 javaType，除非该对象是一个 `HashMap`。这个时候，你需要显式指定 `javaType` 来确保正确的类型处理器（`TypeHandler`）被使用。\r\n\r\n**提示** *JDBC 要求，如果一个列允许使用 null 值，并且会使用值为 null 的参数，就必须要指定 JDBC 类型（jdbcType）。*\r\n\r\n对于数值类型，还可以设置 `numericScale` 指定小数点后保留的位数。\r\n\r\n```java\r\n#{height,javaType=double,jdbcType=NUMERIC,numericScale=2}\r\n```\r\n\r\n### 字符串替换\r\n\r\n默认情况下，使用 `#{}` 参数语法时，MyBatis 会创建 `PreparedStatement` 参数占位符，并通过占位符安全地设置参数（就像使用 ? 一样）。不过有时你就是想直接在 SQL 语句中直接插入一个不转义的字符串。 比如 ORDER BY 子句，这时候你可以：\r\n\r\n```sql\r\nORDER BY ${columnName}\r\n```\r\n\r\n这样，MyBatis 就不会修改或转义该字符串了。\r\n\r\n当 SQL 语句中的元数据（如表名或列名）是动态生成的时候，字符串替换将会非常有用。 举个例子，如果你想 `select` 一个表任意一列的数据时可以只写这样一个方法：\r\n\r\n```java\r\n@Select(\"select * from user where ${column} = #{value}\")\r\nUser findByColumn(@Param(\"column\") String column, @Param(\"value\") String value);\r\n```\r\n\r\n其中 `${column}` 会被直接替换，而 `#{value}` 会使用 `?` 预处理。\r\n\r\n**提示** *用这种方式接受用户的输入，并用作语句参数是不安全的，会导致潜在的 SQL 注入攻击。因此，要么不允许用户输入这些字段，要么自行转义并检验这些参数。*\r\n\r\n## 结果映射（resultMap）\r\n\r\n只设置 `resultType` 的情况下，MyBatis 会在幕后自动创建一个 `ResultMap`，再根据属性名来映射列到 JavaBean 的属性上。\r\n\r\n基本的显式配置如下：\r\n\r\n```xml\r\n<resultMap id=\"userResultMap\" type=\"User\">\r\n  <id property=\"id\" column=\"user_id\" />\r\n  <result property=\"username\" column=\"user_name\"/>\r\n  <result property=\"password\" column=\"hashed_password\"/>\r\n</resultMap>\r\n```\r\n\r\n然后在引用它的语句中设置 `resultMap` 属性就行了（注意我们去掉了 `resultType` 属性）。比如:\r\n\r\n```xml\r\n<select id=\"selectUsers\" resultMap=\"userResultMap\">\r\n  select user_id, user_name, hashed_password\r\n  from some_table\r\n  where id = #{id}\r\n</select>\r\n```\r\n\r\n### 高级结果映射\r\n\r\n```xml\r\n<!-- 非常复杂的结果映射 -->\r\n<resultMap id=\"detailedBlogResultMap\" type=\"Blog\">\r\n    \r\n    <constructor>\r\n        <idArg column=\"blog_id\" javaType=\"int\"/>\r\n    </constructor>\r\n    \r\n    <result property=\"title\" column=\"blog_title\"/>\r\n    \r\n    <association property=\"author\" javaType=\"Author\">\r\n        <id property=\"id\" column=\"author_id\"/>\r\n        <result property=\"username\" column=\"author_username\"/>\r\n        <result property=\"password\" column=\"author_password\"/>\r\n        <result property=\"email\" column=\"author_email\"/>\r\n        <result property=\"bio\" column=\"author_bio\"/>\r\n        <result property=\"favouriteSection\" column=\"author_favourite_section\"/>\r\n    </association>\r\n    \r\n    <collection property=\"posts\" ofType=\"Post\">\r\n        <id property=\"id\" column=\"post_id\"/>\r\n        <result property=\"subject\" column=\"post_subject\"/>\r\n        <association property=\"author\" javaType=\"Author\"/>\r\n        <collection property=\"comments\" ofType=\"Comment\">\r\n            <id property=\"id\" column=\"comment_id\"/>\r\n        </collection>\r\n        <collection property=\"tags\" ofType=\"Tag\" >\r\n            <id property=\"id\" column=\"tag_id\"/>\r\n        </collection>\r\n        <discriminator javaType=\"int\" column=\"draft\">\r\n            <case value=\"1\" resultType=\"DraftPost\"/>\r\n        </discriminator>\r\n        \r\n    </collection>\r\n</resultMap>\r\n```\r\n\r\n### 结果映射（resultMap）\r\n\r\n- ` constructor` 用于在实例化类时，注入结果到构造方法中\r\n  - `idArg` ID 参数；标记出作为 ID 的结果可以帮助提高整体性能\r\n  - `arg` 将被注入到构造方法的一个普通结果\r\n- `id` 一个 ID 结果；标记出作为 ID 的结果可以帮助提高整体性能\r\n- `result`  注入到字段或 JavaBean 属性的普通结果\r\n- `association`  一个复杂类型的关联；许多结果将包装成这种类型\r\n  - 嵌套结果映射 – 关联可以是 `resultMap` 元素，或是对其它结果映射的引用\r\n- `collection`  一个复杂类型的集合\r\n  - 嵌套结果映射 – 集合可以是 `resultMap` 元素，或是对其它结果映射的引用\r\n- `discriminator`  使用结果值来决定使用哪个 `resultMap`\r\n  - `case`  基于某些值的结果映射\r\n    - 嵌套结果映射 – `case` 也是一个结果映射，因此具有相同的结构和元素；或者引用其它的结果映射\r\n\r\n### id & result\r\n\r\n```xml\r\n<id property=\"id\" column=\"post_id\"/>\r\n<result property=\"subject\" column=\"post_subject\"/>\r\n```\r\n\r\n这些元素是结果映射的基础。*id* 和 *result* 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。\r\n\r\n这两者之间的唯一不同是，*id* 元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。 这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候。\r\n\r\n这两个元素都有的属性：\r\n\r\n| 属性          | 描述                                                         |\r\n| :------------ | :----------------------------------------------------------- |\r\n| `property`    | 映射到列结果的字段或属性。如果 JavaBean 有这个名字的属性（property），会先使用该属性。否则 MyBatis 将会寻找给定名称的字段（field）。 无论是哪一种情形，你都可以使用常见的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 |\r\n| `column`      | 数据库中的列名，或者是列的别名。一般情况下，这和传递给 `resultSet.getString(columnName)` 方法的参数一样。 |\r\n| `javaType`    | 一个 Java 类的全限定名，或一个类型别名。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 |\r\n| `jdbcType`    | 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可以为空值的列指定这个类型。 |\r\n| `typeHandler` | 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的全限定名，或者是类型别名。 |\r\n\r\n### 构造方法\r\n\r\n看看下面这个构造方法:\r\n\r\n```java\r\npublic class User {\r\n   //...\r\n   public User(Integer id, String username, int age) {\r\n     //...\r\n  }\r\n//...\r\n}\r\n```\r\n\r\n为了将结果注入构造方法，MyBatis 需要通过某种方式定位相应的构造方法。 在下面的例子中，MyBatis 搜索一个声明了三个形参的构造方法，参数类型以 `java.lang.Integer`, `java.lang.String` 和 `int` 的顺序给出。\r\n\r\n```xml\r\n<constructor>\r\n   <idArg column=\"id\" javaType=\"int\"/>\r\n   <arg column=\"username\" javaType=\"String\"/>\r\n   <arg column=\"age\" javaType=\"_int\"/>\r\n</constructor>\r\n```\r\n\r\n当你在处理一个带有多个形参的构造方法时，很容易搞乱 arg 元素的顺序。 从版本 3.4.3 开始，可以在指定参数名称的前提下，以任意顺序编写 arg 元素。 为了通过名称来引用构造方法参数，你可以添加 `@Param` 注解，或者使用 \'-parameters\' 编译选项并启用 `useActualParamName` 选项（默认开启）来编译项目。下面是一个等价的例子。\r\n\r\n```xml\r\n<constructor>\r\n   <idArg column=\"id\" javaType=\"int\" name=\"id\" />\r\n   <arg column=\"age\" javaType=\"_int\" name=\"age\" />\r\n   <arg column=\"username\" javaType=\"String\" name=\"username\" />\r\n</constructor>\r\n```\r\n\r\n如果存在名称和类型相同的属性，那么可以省略 `javaType` 。\r\n\r\n剩余的属性和规则和普通的 id 和 result 元素是一样的。\r\n\r\n| 属性        | 描述                                                         |\r\n| :---------- | :----------------------------------------------------------- |\r\n| `select`    | 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性中指定的列检索数据，作为参数传递给此 select 语句。具体请参考关联元素。 |\r\n| `resultMap` | 结果映射的 ID，可以将嵌套的结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 `ResultSet`。这样的 `ResultSet` 将会将包含重复或部分数据重复的结果集。为了将结果集正确地映射到嵌套的对象树中，MyBatis 允许你 “串联”结果映射，以便解决嵌套结果集的问题。想了解更多内容，请参考下面的关联元素。 |\r\n| `name`      | 构造方法形参的名字。从 3.4.3 版本开始，通过指定具体的参数名，你可以以任意顺序写入 arg 元素。参看上面的解释。 |\r\n\r\n### 关联\r\n\r\n```xml\r\n<association property=\"author\" column=\"blog_author_id\" javaType=\"Author\">\r\n  <id property=\"id\" column=\"author_id\"/>\r\n  <result property=\"username\" column=\"author_username\"/>\r\n</association>\r\n```\r\n\r\nMyBatis 有两种不同的方式加载关联：\r\n\r\n- 嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。\r\n- 嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。\r\n\r\n| 属性          | 描述                                                         |\r\n| :------------ | :----------------------------------------------------------- |\r\n| `property`    | 映射到列结果的字段或属性。如果用来匹配的 JavaBean 存在给定名字的属性，那么它将会被使用。否则 MyBatis 将会寻找给定名称的字段。 无论是哪一种情形，你都可以使用通常的点式分隔形式进行复杂属性导航。 比如，你可以这样映射一些简单的东西：“username”，或者映射到一些复杂的东西上：“address.street.number”。 |\r\n| `javaType`    | 一个 Java 类的完全限定名，或一个类型别名（关于内置的类型别名，可以参考上面的表格）。 如果你映射到一个 JavaBean，MyBatis 通常可以推断类型。然而，如果你映射到的是 HashMap，那么你应该明确地指定 javaType 来保证行为与期望的相一致。 |\r\n| `jdbcType`    | 只需要在可能执行插入、更新和删除的且允许空值的列上指定 JDBC 类型。这是 JDBC 的要求而非 MyBatis 的要求。如果你直接面向 JDBC 编程，你需要对可能存在空值的列指定这个类型。 |\r\n| `typeHandler` | 我们在前面讨论过默认的类型处理器。使用这个属性，你可以覆盖默认的类型处理器。 这个属性值是一个类型处理器实现类的完全限定名，或者是类型 |\r\n\r\n#### 关联的嵌套 Select 查询\r\n\r\n| 属性        | 描述                                                         |\r\n| :---------- | :----------------------------------------------------------- |\r\n| `column`    | 数据库中的列名，或者是列的别名。一般情况下，这和传递给 `resultSet.getString(columnName)` 方法的参数一样。 注意：在使用复合主键的时候，**你可以使用 `column=\"{prop1=col1,prop2=col2}\"` 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。**这会使得 `prop1` 和 `prop2` 作为参数对象，被设置为对应嵌套 Select 语句的参数。 |\r\n| `select`    | 用于加载复杂类型属性的映射语句的 ID，它会从 column 属性指定的列中检索数据，作为参数传递给目标 select 语句。 具体请参考下面的例子。注意：在使用复合主键的时候，你可以使用 `column=\"{prop1=col1,prop2=col2}\"` 这样的语法来指定多个传递给嵌套 Select 查询语句的列名。这会使得 `prop1` 和 `prop2` 作为**参数对象**，被设置为对应嵌套 Select 语句的参数。 |\r\n| `fetchType` | 可选的。有效值为 `lazy` 和 `eager`。 指定属性后，将在映射中忽略全局配置参数 `lazyLoadingEnabled`，使用属性的值。 |\r\n\r\n示例：\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n  <association property=\"author\" column=\"author_id\" javaType=\"Author\" select=\"selectAuthor\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectBlog\" resultMap=\"blogResult\">\r\n  SELECT * FROM BLOG WHERE ID = #{id}\r\n</select>\r\n\r\n<select id=\"selectAuthor\" resultType=\"Author\">\r\n  SELECT * FROM AUTHOR WHERE ID = #{id}\r\n</select>\r\n```\r\n\r\nN+1 问题：\r\n\r\n- 你执行了一个单独的 SQL 语句来获取结果的一个列表（就是“+1”）。\r\n- 对列表返回的每条记录，你执行一个 select 查询语句来为每条记录加载详细信息（就是“N”）。\r\n\r\n这个问题会导致成百上千的 SQL 语句被执行。MyBatis 能够对这样的查询进行延迟加载。\r\n\r\n#### 关联的嵌套结果映射\r\n\r\n| 属性            | 描述                                                         |\r\n| :-------------- | :----------------------------------------------------------- |\r\n| `resultMap`     | 结果映射的 ID，可以将此关联的嵌套结果集映射到一个合适的对象树中。 它可以作为使用额外 select 语句的替代方案。它可以将多表连接操作的结果映射成一个单一的 `ResultSet`。这样的 `ResultSet` 有部分数据是重复的。 为了将结果集正确地映射到嵌套的对象树中, MyBatis 允许你“串联”结果映射，以便解决嵌套结果集的问题。使用嵌套结果映射的一个例子在表格以后。 |\r\n| `columnPrefix`  | 当连接多个表时，你可能会不得不使用列别名来避免在 `ResultSet` 中产生重复的列名。指定 columnPrefix 列名前缀允许你将带有这些前缀的列映射到一个外部的结果映射中。 详细说明请参考后面的例子。 |\r\n| `notNullColumn` | 默认情况下，在至少一个被映射到属性的列不为空时，子对象才会被创建。 你可以在这个属性上指定非空的列来改变默认行为，指定后，Mybatis 将只在这些列非空时才创建一个子对象。可以使用逗号分隔来指定多个列。默认值：未设置（unset）。 |\r\n| `autoMapping`   | 如果设置这个属性，MyBatis 将会为本结果映射开启或者关闭自动映射。 这个属性会覆盖全局的属性 autoMappingBehavior。注意，本属性对外部的结果映射无效，所以不能搭配 `select` 或 `resultMap` 元素使用。默认值：未设置（unset）。 |\r\n\r\n将两张表连接在一起，而不是执行一个独立的查询语句：\r\n\r\n```xml\r\n<select id=\"selectBlog\" resultMap=\"blogResult\">\r\n  select\r\n    B.id            as blog_id,\r\n    B.title         as blog_title,\r\n    B.author_id     as blog_author_id,\r\n    A.id            as author_id,\r\n    A.username      as author_username,\r\n    A.password      as author_password,\r\n    A.email         as author_email,\r\n    A.bio           as author_bio\r\n  from Blog B left outer join Author A on B.author_id = A.id\r\n  where B.id = #{id}\r\n</select>\r\n```\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n  <id property=\"id\" column=\"blog_id\" />\r\n  <result property=\"title\" column=\"blog_title\"/>\r\n  <association property=\"author\" column=\"blog_author_id\" javaType=\"Author\" resultMap=\"authorResult\"/>\r\n</resultMap>\r\n\r\n<resultMap id=\"authorResult\" type=\"Author\">\r\n  <id property=\"id\" column=\"author_id\"/>\r\n  <result property=\"username\" column=\"author_username\"/>\r\n  <result property=\"password\" column=\"author_password\"/>\r\n  <result property=\"email\" column=\"author_email\"/>\r\n  <result property=\"bio\" column=\"author_bio\"/>\r\n</resultMap>\r\n```\r\n\r\n在上面的例子中，你可以看到，博客（Blog）作者（author）的关联元素委托名为 “authorResult” 的结果映射来加载作者对象的实例。也可以让 `resultMap` 里面的内容放到 `association` 里面。\r\n\r\n**非常重要：你应该总是指定一个或多个可以唯一标识（ID）结果的属性。 虽然，即使不指定这个属性，MyBatis 仍然可以工作，但是会产生严重的性能问题。 只需要指定可以唯一标识结果的最少属性。显然，你可以选择主键（复合主键也可以）。**\r\n\r\n如果要给博客添加一个共同作者（co-author），select 语句添加这些：\r\n\r\n```\r\n	CA.id           as co_author_id,\r\n    CA.username     as co_author_username,\r\n    CA.password     as co_author_password,\r\n    CA.email        as co_author_email,\r\n    CA.bio          as co_author_bio\r\n```\r\n\r\ncoAuthor 属性映射为：\r\n\r\n```xml\r\n <association property=\"coAuthor\"\r\n    resultMap=\"authorResult\"\r\n    columnPrefix=\"co_\" />\r\n```\r\n\r\n#### 关联的多结果集\r\n\r\n| 属性            | 描述                                                         |\r\n| :-------------- | :----------------------------------------------------------- |\r\n| `column`        | 当使用多个结果集时，该属性指定结果集中用于与 `foreignColumn` 匹配的列（多个列名以逗号隔开），以识别关系中的父类型与子类型。 |\r\n| `foreignColumn` | 指定外键对应的列名，指定的列将与父类型中 `column` 的给出的列进行匹配。 |\r\n| `resultSet`     | 指定用于加载复杂类型的结果集名字。                           |\r\n\r\n在例子中，存储过程执行下面的查询并返回两个结果集。第一个结果集会返回博客（Blog）的结果，第二个则返回作者（Author）的结果。\r\n\r\n```sql\r\nSELECT * FROM BLOG WHERE ID = #{id}\r\n\r\nSELECT * FROM AUTHOR WHERE ID = #{id}\r\n```\r\n\r\n在映射语句中，必须通过 `resultSets` 属性为每个结果集指定一个名字，多个名字使用逗号隔开。\r\n\r\n```xml\r\n<select id=\"selectBlog\" resultSets=\"blogs,authors\" resultMap=\"blogResult\" statementType=\"CALLABLE\">\r\n  {call getBlogsAndAuthors(#{id,jdbcType=INTEGER,mode=IN})}\r\n</select>\r\n```\r\n\r\n现在我们可以指定使用 “authors” 结果集的数据来填充 “author” 关联：\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n  <id property=\"id\" column=\"id\" />\r\n  <result property=\"title\" column=\"title\"/>\r\n  <association property=\"author\" javaType=\"Author\" resultSet=\"authors\" column=\"author_id\" foreignColumn=\"id\">\r\n    <id property=\"id\" column=\"id\"/>\r\n    <result property=\"username\" column=\"username\"/>\r\n    <result property=\"password\" column=\"password\"/>\r\n    <result property=\"email\" column=\"email\"/>\r\n    <result property=\"bio\" column=\"bio\"/>\r\n  </association>\r\n</resultMap>\r\n```\r\n\r\n#### 集合\r\n\r\n```xml\r\n<collection property=\"posts\" ofType=\"domain.blog.Post\">\r\n  <id property=\"id\" column=\"post_id\"/>\r\n  <result property=\"subject\" column=\"post_subject\"/>\r\n  <result property=\"body\" column=\"post_body\"/>\r\n</collection>\r\n```\r\n\r\n集合元素和关联元素几乎是一样的。\r\n\r\n个博客（Blog）只有一个作者（Author)。但一个博客有很多文章（Post)。 在博客类中，这可以用下面的写法来表示：\r\n\r\n```java\r\nprivate List<Post> posts;\r\n```\r\n\r\n要像上面这样，映射嵌套结果集合到一个 List 中，可以使用集合元素。 和关联元素一样，我们可以使用嵌套 Select 查询，或基于连接的嵌套结果映射集合。\r\n\r\n##### 集合的嵌套 Select 查询\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n  <collection property=\"posts\" javaType=\"ArrayList\" column=\"id\" ofType=\"Post\" select=\"selectPostsForBlog\"/>\r\n</resultMap>\r\n\r\n<select id=\"selectBlog\" resultMap=\"blogResult\">\r\n  SELECT * FROM BLOG WHERE ID = #{id}\r\n</select>\r\n\r\n<select id=\"selectPostsForBlog\" resultType=\"Post\">\r\n  SELECT * FROM POST WHERE BLOG_ID = #{id}\r\n</select>\r\n```\r\n\r\n “ofType” 属性非常重要，它用来将 JavaBean（或字段）属性的类型和集合存储的类型区分开来。\r\n\r\n##### 集合的嵌套结果映射\r\n\r\n```xml\r\n<select id=\"selectBlog\" resultMap=\"blogResult\">\r\n    select\r\n    B.id as blog_id,\r\n    B.title as blog_title,\r\n    B.author_id as blog_author_id,\r\n    P.id as post_id,\r\n    P.subject as post_subject,\r\n    P.body as post_body,\r\n    from Blog B\r\n    left outer join Post P on B.id = P.blog_id\r\n    where B.id = #{id}\r\n</select>\r\n```\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n    <id property=\"id\" column=\"blog_id\" />\r\n    <result property=\"title\" column=\"blog_title\"/>\r\n    <collection property=\"posts\" ofType=\"Post\">\r\n        <id property=\"id\" column=\"post_id\"/>\r\n        <result property=\"subject\" column=\"post_subject\"/>\r\n        <result property=\"body\" column=\"post_body\"/>\r\n    </collection>\r\n</resultMap>\r\n```\r\n\r\n##### 集合的多结果集\r\n\r\n使用存储过程查询，返回一个博客的结果集，一个文章的结果集：\r\n\r\n```sql\r\nSELECT * FROM BLOG WHERE ID = #{id}\r\n\r\nSELECT * FROM POST WHERE BLOG_ID = #{id}\r\n```\r\n\r\n```xml\r\n<select id=\"selectBlog\" resultSets=\"blogs,posts\" resultMap=\"blogResult\">\r\n  {call getBlogsAndPosts(#{id,jdbcType=INTEGER,mode=IN})}\r\n</select>\r\n```\r\n\r\n指定 “posts” 集合将会使用存储在 “posts” 结果集中的数据进行填充：\r\n\r\n```xml\r\n<resultMap id=\"blogResult\" type=\"Blog\">\r\n  <id property=\"id\" column=\"id\" />\r\n  <result property=\"title\" column=\"title\"/>\r\n  <collection property=\"posts\" ofType=\"Post\" resultSet=\"posts\" column=\"id\" foreignColumn=\"blog_id\">\r\n    <id property=\"id\" column=\"id\"/>\r\n    <result property=\"subject\" column=\"subject\"/>\r\n    <result property=\"body\" column=\"body\"/>\r\n  </collection>\r\n</resultMap>\r\n```\r\n\r\n#### 鉴别器\r\n\r\n```xml\r\n<discriminator javaType=\"int\" column=\"draft\">\r\n  <case value=\"1\" resultType=\"DraftPost\"/>\r\n</discriminator>\r\n```\r\n\r\n有时候，一个数据库查询可能会返回多个不同的结果集（但总体上还是有一定的联系的）。 鉴别器（discriminator）元素就是被设计来应对这种情况的，另外也能处理其它情况，例如类的继承层次结构。 鉴别器的概念很好理解——它很像 Java 语言中的 switch 语句。\r\n\r\n一个鉴别器的定义需要指定 column 和 javaType 属性。column 指定了 MyBatis 查询被比较值的地方。 而 javaType 用来确保使用正确的相等测试。例如：\r\n\r\n```xml\r\n<resultMap id=\"vehicleResult\" type=\"Vehicle\">\r\n  <id property=\"id\" column=\"id\" />\r\n  <result property=\"vin\" column=\"vin\"/>\r\n    ...\r\n  <result property=\"color\" column=\"color\"/>\r\n  <discriminator javaType=\"int\" column=\"vehicle_type\">\r\n    <case value=\"1\" resultMap=\"carResult\"/>\r\n    <case value=\"2\" resultMap=\"truckResult\"/>\r\n    <case value=\"3\" resultMap=\"vanResult\"/>\r\n    <case value=\"4\" resultMap=\"suvResult\"/>\r\n  </discriminator>\r\n</resultMap>\r\n```\r\n\r\n在这个示例中，MyBatis 会从结果集中得到每条记录，然后比较它的 vehicle type 值。 如果它匹配任意一个鉴别器的 case，就会使用这个 case 指定的结果映射。 这个过程是互斥的，也就是说，剩余的结果映射将被忽略。 如果不能匹配任何一个 case，MyBatis 就只会使用鉴别器块外定义的结果映射。 \r\n\r\n## 自动映射\r\n\r\n在简单的场景下，MyBatis 可以为你自动映射查询结果。但如果遇到复杂的场景，你需要构建一个结果映射。你可以混合使用这两种策略。\r\n\r\n当自动映射查询结果时，MyBatis 会获取结果中返回的列名并在 Java 类中查找相同名字的属性（忽略大小写）。\r\n\r\n通常数据库列使用大写字母组成的单词命名，单词间用下划线分隔；而 Java 属性一般遵循驼峰命名法约定。为了在这两种命名方式之间启用自动映射，需要将 `mapUnderscoreToCamelCase` 设置为 true。\r\n\r\n有三种自动映射等级：\r\n\r\n- `NONE` - 禁用自动映射。仅对手动映射的属性进行映射。\r\n- `PARTIAL` - 对除在内部定义了嵌套结果映射（也就是连接的属性）以外的属性进行映射\r\n- `FULL` - 自动映射所有属性。\r\n\r\n默认值是 `PARTIAL`。\r\n\r\n## 缓存\r\n\r\nMyBatis 内置了一个强大的事务性查询缓存机制，它可以非常方便地配置和定制。\r\n\r\n默认情况下，只启用了本地的会话缓存，它仅仅对一个会话中的数据进行缓存。 要启用全局的二级缓存，只需要在你的 SQL 映射文件中添加一行：\r\n\r\n```xml\r\n<cache/>\r\n```\r\n\r\n基本上就是这样。这个简单语句的效果如下:\r\n\r\n- 映射语句文件中的所有 select 语句的结果将会被缓存。\r\n- 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。\r\n- 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。\r\n- 缓存**不会**定时进行刷新（也就是说，没有刷新间隔）。\r\n- 缓存会保存列表或对象（无论查询方法返回哪种）的 **1024** 个引用。\r\n- 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。\r\n\r\n**提示** *缓存只作用于 cache 标签所在的映射文件中的语句。如果你混合使用 Java API 和 XML 映射文件，在共用接口中的语句将不会被默认缓存。你需要使用 @CacheNamespaceRef 注解指定缓存作用域。*\r\n\r\n这些属性可以通过 cache 元素的属性来修改。比如：\r\n\r\n```xml\r\n<cache\r\n  eviction=\"FIFO\"\r\n  flushInterval=\"60000\"\r\n  size=\"512\"\r\n  readOnly=\"true\"/>\r\n```\r\n\r\n可用的清除策略有：\r\n\r\n- `LRU` – 最近最少使用：移除最长时间不被使用的对象。（默认）\r\n- `FIFO` – 先进先出：按对象进入缓存的顺序来移除它们。\r\n- `SOFT` – 软引用：基于垃圾回收器状态和软引用规则移除对象。\r\n- `WEAK` – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。\r\n\r\nflushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值是一个以毫秒为单位的时间量。 默认不设置，没有刷新间隔。\r\n\r\nsize（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。\r\n\r\nreadOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。\r\n\r\n**提示** *二级缓存是事务性的。这意味着，当 SqlSession 完成并提交时，或是完成并回滚，但没有执行 flushCache=true 的 insert/delete/update 语句时，缓存会获得更新。*\r\n\r\n### 自定义缓存\r\n\r\n可以实现自己的缓存或者是使用第三方缓存来覆盖缓存行为。\r\n\r\n```xml\r\n<cache type=\"com.domain.something.MyCustomCache\">\r\n  <property name=\"cacheFile\" value=\"/tmp/my-custom-cache.tmp\"/>\r\n</cache>\r\n```\r\n\r\n**提示** *上一节中对缓存的配置（如清除策略、可读或可读写等），不能应用于自定义缓存。*\r\n\r\n如果你想改变默认的行为，只需要设置 flushCache 和 useCache 属性。\r\n\r\n```xml\r\n<select ... flushCache=\"false\" useCache=\"true\"/>\r\n```\r\n\r\n### cache-ref\r\n\r\n对某一命名空间的语句，只会使用该命名空间的缓存进行缓存或刷新。 但你可能会想要在多个命名空间中共享相同的缓存配置和实例。要实现这种需求，你可以使用 cache-ref 元素来引用另一个缓存。\r\n\r\n```xml\r\n<cache-ref namespace=\"com.someone.application.data.SomeMapper\"/>\r\n```\r\n\r\n# 动态 SQL\r\n\r\n- if\r\n- choose (when, otherwise)\r\n- trim (where, set)\r\n- foreach\r\n\r\n## if\r\n\r\n使用动态 SQL 最常见情景是根据条件包含 where 子句的一部分。比如：\r\n\r\n```xml\r\n<select id=\"findActiveBlogWithTitleLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG\r\n  WHERE state = ‘ACTIVE’\r\n  <if test=\"title != null\">\r\n    AND title like #{title}\r\n  </if>\r\n</select>\r\n```\r\n\r\n## choose、when、otherwise\r\n\r\n传入了 “title” 就按 “title” 查找，传入了 “author” 就按 “author” 查找的情形。若两者都没有传入，就返回标记为 featured 的 BLOG（精选的 Blog）。\r\n\r\n```xml\r\n<select id=\"findActiveBlogLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG WHERE state = ‘ACTIVE’\r\n  <choose>\r\n    <when test=\"title != null\">\r\n      AND title like #{title}\r\n    </when>\r\n    <when test=\"author != null and author.name != null\">\r\n      AND author_name like #{author.name}\r\n    </when>\r\n    <otherwise>\r\n      AND featured = 1\r\n    </otherwise>\r\n  </choose>\r\n</select>\r\n```\r\n\r\n## trim、where、set\r\n\r\n如果将 \"status = ACTIVE\" 也设置为动态条件：\r\n\r\n```xml\r\n<select id=\"findActiveBlogLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG\r\n  WHERE\r\n  <if test=\"state != null\">\r\n    state = #{state}\r\n  </if>\r\n  <if test=\"title != null\">\r\n    AND title like #{title}\r\n  </if>\r\n</select>\r\n```\r\n\r\n如果没有匹配的条件，SQL 会变成：\r\n\r\n```sql\r\nSELECT * FROM BLOG\r\nWHERE\r\n```\r\n\r\n或者匹配的只有第二个条件：\r\n\r\n```sql\r\nSELECT * FROM BLOG\r\nWHERE\r\nAND title like ‘someTitle’\r\n```\r\n\r\n这两个结果都会查询失败，可以把他们改成：\r\n\r\n```xml\r\n<select id=\"findActiveBlogLike\"\r\n     resultType=\"Blog\">\r\n  SELECT * FROM BLOG\r\n  <where>\r\n    <if test=\"state != null\">\r\n         state = #{state}\r\n    </if>\r\n    <if test=\"title != null\">\r\n        AND title like #{title}\r\n    </if>\r\n  </where>\r\n</select>\r\n```\r\n\r\n*where* 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，*where* 元素也会将它们去除。\r\n\r\n也可以通过自定义 trim 元素来定制 *where* 元素的功能。比如，和 *where* 元素等价的自定义 trim 元素为：\r\n\r\n```xml\r\n<trim prefix=\"WHERE\" prefixOverrides=\"AND |OR \">\r\n  ...\r\n</trim>\r\n```\r\n\r\n*prefixOverrides* 属性会忽略通过管道符分隔的文本序列（注意此例中的空格是必要的）。上述例子会移除所有 *prefixOverrides* 属性中指定的内容，并且插入 *prefix* 属性中指定的内容。\r\n\r\n*set* 元素可以用于动态包含需要更新的列，忽略其它不更新的列。比如：\r\n\r\n```xml\r\n<update id=\"updateAuthorIfNecessary\">\r\n  update Author\r\n    <set>\r\n      <if test=\"username != null\">username=#{username},</if>\r\n      <if test=\"password != null\">password=#{password},</if>\r\n      <if test=\"email != null\">email=#{email},</if>\r\n      <if test=\"bio != null\">bio=#{bio}</if>\r\n    </set>\r\n  where id=#{id}\r\n</update>\r\n```\r\n\r\n*set* 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号。\r\n\r\n与 *set* 元素等价的自定义 *trim* 元素：\r\n\r\n```xml\r\n<trim prefix=\"SET\" suffixOverrides=\",\">\r\n  ...\r\n</trim>\r\n```\r\n\r\n## foreach\r\n\r\n动态 SQL 的另一个常见使用场景是对集合进行遍历。比如：\r\n\r\n```xml\r\n<select id=\"selectPostIn\" resultType=\"domain.blog.Post\">\r\n  SELECT *\r\n  FROM POST P\r\n  WHERE ID in\r\n  <foreach item=\"item\" index=\"index\" collection=\"list\"\r\n      open=\"(\" separator=\",\" close=\")\">\r\n        #{item}\r\n  </foreach>\r\n</select>\r\n```\r\n\r\n**提示** 你可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 *foreach*。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。\r\n\r\n## script\r\n\r\n要在带注解的映射器接口类中使用动态 SQL，可以使用 *script* 元素。比如:\r\n\r\n```java\r\n    @Update({\"<script>\",\r\n      \"update Author\",\r\n      \"  <set>\",\r\n      \"    <if test=\'username != null\'>username=#{username},</if>\",\r\n      \"    <if test=\'password != null\'>password=#{password},</if>\",\r\n      \"    <if test=\'email != null\'>email=#{email},</if>\",\r\n      \"    <if test=\'bio != null\'>bio=#{bio}</if>\",\r\n      \"  </set>\",\r\n      \"where id=#{id}\",\r\n      \"</script>\"})\r\n    void updateAuthorValues(Author author);\r\n```\r\n\r\n## bind\r\n\r\n`bind` 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：\r\n\r\n```xml\r\n<select id=\"selectBlogsLike\" resultType=\"Blog\">\r\n  <bind name=\"pattern\" value=\"\'%\' + _parameter.getTitle() + \'%\'\" />\r\n  SELECT * FROM BLOG\r\n  WHERE title LIKE #{pattern}\r\n</select>\r\n```\r\n\r\n## 多数据库支持\r\n\r\n如果配置了 databaseIdProvider，你就可以在动态代码中使用名为 “_databaseId” 的变量来为不同的数据库构建特定的语句。比如下面的例子：\r\n\r\n```xml\r\n<insert id=\"insert\">\r\n  <selectKey keyProperty=\"id\" resultType=\"int\" order=\"BEFORE\">\r\n    <if test=\"_databaseId == \'oracle\'\">\r\n      select seq_users.nextval from dual\r\n    </if>\r\n    <if test=\"_databaseId == \'db2\'\">\r\n      select nextval for seq_users from sysibm.sysdummy1\"\r\n    </if>\r\n  </selectKey>\r\n  insert into users values (#{id}, #{name})\r\n</insert>\r\n```\r\n\r\n# Java API\r\n\r\n## 目录结构\r\n\r\n推荐的目录结构：\r\n\r\n```\r\n/my_application\r\n  /bin\r\n  /devlib\r\n  /lib                <-- MyBatis *.jar 文件在这里。\r\n  /src\r\n    /org/myapp/\r\n      /action\r\n      /data           <-- MyBatis 配置文件在这里，包括映射器类、XML 配置、XML 映射文件。\r\n        /mybatis-config.xml\r\n        /BlogMapper.java\r\n        /BlogMapper.xml\r\n      /model\r\n      /service\r\n      /view\r\n    /properties       <-- 在 XML 配置中出现的属性值在这里。\r\n  /test\r\n    /org/myapp/\r\n      /action\r\n      /data\r\n      /model\r\n      /service\r\n      /view\r\n    /properties\r\n  /web\r\n    /WEB-INF\r\n      /web.xml\r\n```\r\n\r\n## SqlSession\r\n\r\nSqlSessions 是由 SqlSessionFactory 实例创建的。而 SqlSessionFactory 本身是由 SqlSessionFactoryBuilder 创建的，它可以从 XML、注解或 Java 配置代码来创建 SqlSessionFactory。\r\n\r\n### SqlSessionFactoryBuilder\r\n\r\nSqlSessionFactoryBuilder 有五个 build() 方法。\r\n\r\n```java\r\nSqlSessionFactory build(InputStream inputStream)\r\nSqlSessionFactory build(InputStream inputStream, String environment)\r\nSqlSessionFactory build(InputStream inputStream, Properties properties)\r\nSqlSessionFactory build(InputStream inputStream, String env, Properties props)\r\nSqlSessionFactory build(Configuration config)\r\n```\r\n\r\n第一种方法是最常用的，它接受一个指向 XML 文件（也就是之前讨论的 mybatis-config.xml 文件）的 InputStream 实例。可选的参数是 environment 和 properties。\r\n\r\n从 xml 文件创建的示例：\r\n\r\n```java\r\nString resource = \"org/mybatis/builder/mybatis-config.xml\";\r\nInputStream inputStream = Resources.getResourceAsStream(resource);\r\nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\r\nSqlSessionFactory factory = builder.build(inputStream);\r\n```\r\n\r\n最后一个 build 方法接受一个 Configuration 实例。前面的所有配置开关都存在于 Configuration 类，只不过它们是以 Java API 形式暴露的。\r\n\r\n```java\r\nDataSource dataSource = BaseDataTest.createBlogDataSource();\r\nTransactionFactory transactionFactory = new JdbcTransactionFactory();\r\n\r\nEnvironment environment = new Environment(\"development\", transactionFactory, dataSource);\r\n\r\nConfiguration configuration = new Configuration(environment);\r\nconfiguration.setLazyLoadingEnabled(true);\r\nconfiguration.setEnhancementEnabled(true);\r\nconfiguration.getTypeAliasRegistry().registerAlias(Blog.class);\r\nconfiguration.getTypeAliasRegistry().registerAlias(Post.class);\r\nconfiguration.getTypeAliasRegistry().registerAlias(Author.class);\r\nconfiguration.addMapper(BoundBlogMapper.class);\r\nconfiguration.addMapper(BoundAuthorMapper.class);\r\n\r\nSqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();\r\nSqlSessionFactory factory = builder.build(configuration);\r\n```\r\n\r\n### SqlSessionFactory\r\n\r\nSqlSessionFactory 有六个方法创建 SqlSession 实例。通常来说，当你选择其中一个方法时，你需要考虑以下几点：\r\n\r\n- **事务处理**：你希望在 session 作用域中使用事务作用域，还是使用自动提交（auto-commit）？（对很多数据库和/或 JDBC 驱动来说，等同于关闭事务支持）\r\n- **数据库连接**：你希望 MyBatis 帮你从已配置的数据源获取连接，还是使用自己提供的连接？\r\n- **语句执行**：你希望 MyBatis 复用 PreparedStatement 和/或批量更新语句（包括插入语句和删除语句）吗？\r\n\r\n\r\n\r\n```java\r\nSqlSession openSession()\r\nSqlSession openSession(boolean autoCommit)\r\nSqlSession openSession(Connection connection)\r\nSqlSession openSession(TransactionIsolationLevel level)\r\nSqlSession openSession(ExecutorType execType, TransactionIsolationLevel level)\r\nSqlSession openSession(ExecutorType execType)\r\nSqlSession openSession(ExecutorType execType, boolean autoCommit)\r\nSqlSession openSession(ExecutorType execType, Connection connection)\r\nConfiguration getConfiguration();\r\n```\r\n\r\n默认的 openSession() 方法没有参数，它会创建具备如下特性的 SqlSession：\r\n\r\n- 事务作用域将会开启（也就是不自动提交）。\r\n- 将由当前环境配置的 DataSource 实例中获取 Connection 对象。\r\n- 事务隔离级别将会使用驱动或数据源的默认设置。\r\n- 预处理语句不会被复用，也不会批量处理更新。\r\n\r\n注意，我们没有提供同时设置 `Connection` 和 `autoCommit` 的方法，这是因为 MyBatis 会依据传入的 Connection 来决定是否启用 autoCommit。\r\n\r\n`ExecutorType` 这个枚举类型定义了三个值:\r\n\r\n- `ExecutorType.SIMPLE`：该类型的执行器没有特别的行为。它为每个语句的执行创建一个新的预处理语句。\r\n- `ExecutorType.REUSE`：该类型的执行器会复用预处理语句。\r\n- `ExecutorType.BATCH`：该类型的执行器会批量执行所有更新语句，如果 SELECT 在多个更新中间执行，将在必要时将多条更新语句分隔开来，以方便理解。\r\n\r\n**提示** *getConfiguration()会返回一个 Configuration 实例，你可以在运行时使用它来检查 MyBatis 的配置。*\r\n\r\n### SqlSession\r\n\r\n#### 语句执行方法\r\n\r\n这些方法被用来执行定义在 SQL 映射 XML 文件中的 SELECT、INSERT、UPDATE 和 DELETE 语句。\r\n\r\n```java\r\n<T> T selectOne(String statement, Object parameter)\r\n<E> List<E> selectList(String statement, Object parameter)\r\n<T> Cursor<T> selectCursor(String statement, Object parameter)\r\n<K,V> Map<K,V> selectMap(String statement, Object parameter, String mapKey)\r\nint insert(String statement, Object parameter)\r\nint update(String statement, Object parameter)\r\nint delete(String statement, Object parameter)\r\n```\r\n\r\n由于并不是所有语句都需要参数，所以这些方法都具有一个不需要参数的重载形式。\r\n\r\nselectOne 和 selectList 的不同仅仅是 selectOne 必须返回一个对象或 null 值。如果返回值多于一个，就会抛出异常。如果你不知道返回对象会有多少，请使用 selectList。\r\n\r\nselectMap 稍微特殊一点，它会将返回对象的其中一个属性作为 key 值，将对象作为 value 值，从而将多个结果集转为 Map 类型值。\r\n\r\n游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载。\r\n\r\n```java\r\ntry (Cursor<MyEntity> entities = session.selectCursor(statement, param)) {\r\n   for (MyEntity entity:entities) {\r\n      // 处理单个实体\r\n   }\r\n}\r\n```\r\n\r\n最后，还有 select 方法的三个高级版本，它们允许你限制返回行数的范围，或是提供自定义结果处理逻辑，通常在数据集非常庞大的情形下使用。\r\n\r\n```java\r\n<E> List<E> selectList (String statement, Object parameter, RowBounds rowBounds)\r\n<T> Cursor<T> selectCursor(String statement, Object parameter, RowBounds rowBounds)\r\n<K,V> Map<K,V> selectMap(String statement, Object parameter, String mapKey, RowBounds rowbounds)\r\nvoid select (String statement, Object parameter, ResultHandler<T> handler)\r\nvoid select (String statement, Object parameter, RowBounds rowBounds, ResultHandler<T> handler)\r\n```\r\n\r\nRowBounds 参数会告诉 MyBatis 略过指定数量的记录，并限制返回结果的数量。RowBounds 类的 offset 和 limit 值只有在构造函数时才能传入，其它时候是不能修改的。\r\n\r\n```java\r\nint offset = 100;\r\nint limit = 25;\r\nRowBounds rowBounds = new RowBounds(offset, limit);\r\n```\r\n\r\nResultHandler 参数允许自定义每行结果的处理过程。你可以将它添加到 List 中、创建 Map 和 Set，甚至丢弃每个返回值，只保留计算后的统计结果。\r\n\r\n```java\r\npackage org.apache.ibatis.session;\r\npublic interface ResultHandler<T> {\r\n  void handleResult(ResultContext<? extends T> context);\r\n}\r\n```\r\n\r\n从版本 3.4.6 开始，`ResultHandler` 会在存储过程的 REFCURSOR 输出参数中传递使用的 `CALLABLE` 语句。\r\n\r\nResultContext 参数允许你访问结果对象和当前已被创建的对象数目，另外还提供了一个返回值为 Boolean 的 stop 方法，你可以使用此 stop 方法来停止 MyBatis 加载更多的结果。\r\n\r\n使用 ResultHandler 的时候需要注意以下两个限制：\r\n\r\n- 使用带 ResultHandler 参数的方法时，收到的数据不会被缓存。\r\n- 当使用高级的结果映射集（resultMap）时，MyBatis 很可能需要数行结果来构造一个对象。如果你使用了 ResultHandler，你可能会接收到关联（association）或者集合（collection）中尚未被完整填充的对象。\r\n\r\n#### 立即批量更新方法\r\n\r\n当你将 `ExecutorType` 设置为 `ExecutorType.BATCH` 时，可以使用这个方法清除（执行）缓存在 JDBC 驱动类中的批量更新语句。\r\n\r\n```java\r\nList<BatchResult> flushStatements()\r\n```\r\n\r\n#### 事务控制方法\r\n\r\n有四个方法用来控制事务作用域。当然，如果你已经设置了自动提交或你使用了外部事务管理器，这些方法就没什么作用了。\r\n\r\n```java\r\nvoid commit()\r\nvoid commit(boolean force)\r\nvoid rollback()\r\nvoid rollback(boolean force)\r\n```\r\n\r\n默认情况下 MyBatis 不会自动提交事务，除非它侦测到调用了插入、更新或删除方法改变了数据库。如果你没有使用这些方法提交修改，那么你可以在 commit 和 rollback 方法参数中传入 true 值，来保证事务被正常提交（注意，在自动提交模式或者使用了外部事务管理器的情况下，设置 force 值对 session 无效）。\r\n\r\n大部分情况下你无需调用 rollback()，因为 MyBatis 会在你没有调用 commit 时替你完成回滚操作。不过，当你要在一个可能多次提交或回滚的 session 中详细控制事务，回滚操作就派上用场了。\r\n\r\n#### 本地缓存\r\n\r\nMybatis 使用到了两种缓存：本地缓存（local cache）和二级缓存（second level cache）。\r\n\r\n每当一个新 session 被创建，MyBatis 就会创建一个与之相关联的本地缓存。任何在 session 执行过的查询结果都会被保存在本地缓存中，所以，当再次执行参数相同的相同查询时，就不需要实际查询数据库了。本地缓存将会在做出修改、事务提交或回滚，以及关闭 session 时清空。\r\n\r\n默认情况下无法将本地缓存完全禁用。但是你可以通过设置 localCacheScope=STATEMENT 来只在语句执行时使用缓存。\r\n\r\n注意，如果 localCacheScope 被设置为 SESSION，对返回的对象（例如 list）做出的任何修改将会影响本地缓存的内容，进而将会影响到在本次 session 中从缓存返回的值。因此，不要对 MyBatis 所返回的对象作出更改，以防后患。\r\n\r\n你可以随时调用以下方法来清空本地缓存：\r\n\r\n```java\r\nvoid clearCache()\r\n```\r\n\r\n#### 确保 SqlSession 被关闭\r\n\r\n```java\r\nvoid close()\r\n```\r\n\r\n保证妥善关闭的最佳代码模式是这样的：\r\n\r\n```java\r\nSqlSession session = sqlSessionFactory.openSession();\r\ntry (SqlSession session = sqlSessionFactory.openSession()) {\r\n    // 假设下面三行代码是你的业务逻辑\r\n    session.insert(...);\r\n    session.update(...);\r\n    session.delete(...);\r\n    session.commit();\r\n}\r\n```\r\n\r\n**提示** *和 SqlSessionFactory 一样，你可以调用当前使用的 SqlSession 的 getConfiguration 方法来获得 Configuration 实例。*\r\n\r\n#### 使用映射器\r\n\r\n```java\r\n<T> T getMapper(Class<T> type)\r\n```\r\n\r\n一个映射器类就是一个仅需声明与 SqlSession 方法相匹配方法的接口。下面的示例展示了一些方法签名以及它们是如何映射到 SqlSession 上的。\r\n\r\n```java\r\npublic interface AuthorMapper {\r\n  // (Author) selectOne(\"selectAuthor\",5);\r\n  Author selectAuthor(int id);\r\n  // (List<Author>) selectList(“selectAuthors”)\r\n  List<Author> selectAuthors();\r\n  // (Map<Integer,Author>) selectMap(\"selectAuthors\", \"id\")\r\n  @MapKey(\"id\")\r\n  Map<Integer, Author> selectAuthors();\r\n  // insert(\"insertAuthor\", author)\r\n  int insertAuthor(Author author);\r\n  // updateAuthor(\"updateAuthor\", author)\r\n  int updateAuthor(Author author);\r\n  // delete(\"deleteAuthor\",5)\r\n  int deleteAuthor(int id);\r\n}\r\n```\r\n\r\n**提示** *映射器接口不需要去实现任何接口或继承自任何类。只要方法签名可以被用来唯一识别对应的映射语句就可以了。*\r\n\r\n**提示** *映射器接口可以继承自其他接口。*唯一的限制是，不能在两个具有继承关系的接口中拥有相同的方法签名（这是潜在的危险做法，不可取）。\r\n\r\n可以传递多个参数给一个映射器方法。在多个参数的情况下，默认它们将会以 param 加上它们在参数列表中的位置来命名，比如：#{param1}、#{param2}等。如果你想（在有多个参数时）自定义参数的名称，那么你可以在参数上使用 @Param(\"paramName\") 注解。\r\n\r\n##### 映射器注解\r\n\r\n| 注解                                                         | 使用对象 | XML 等价形式                                               | 描述                                                         |\r\n| :----------------------------------------------------------- | :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |\r\n| `@CacheNamespace`                                            | `类`     | `<cache>`                                                  | 为给定的命名空间（比如类）配置缓存。属性：`implemetation`、`eviction`、`flushInterval`、`size`、`readWrite`、`blocking`、`properties`。 |\r\n| `@Property`                                                  | N/A      | `<property>`                                               | 指定参数值或占位符（placeholder）（该占位符能被 `mybatis-config.xml` 内的配置属性替换）。属性：`name`、`value`。（仅在 MyBatis 3.4.2 以上可用） |\r\n| `@CacheNamespaceRef`                                         | `类`     | `<cacheRef>`                                               | 引用另外一个命名空间的缓存以供使用。注意，即使共享相同的全限定类名，在 XML 映射文件中声明的缓存仍被识别为一个独立的命名空间。属性：`value`、`name`。如果你使用了这个注解，你应设置 `value` 或者 `name` 属性的其中一个。`value` 属性用于指定能够表示该命名空间的 Java 类型（命名空间名就是该 Java 类型的全限定类名），`name` 属性（这个属性仅在 MyBatis 3.4.2 以上可用）则直接指定了命名空间的名字。 |\r\n| `@ConstructorArgs`                                           | `方法`   | `<constructor>`                                            | 收集一组结果以传递给一个结果对象的构造方法。属性：`value`，它是一个 `Arg` 数组。 |\r\n| `@Arg`                                                       | N/A      | `<arg>` `<idArg>`                                          | ConstructorArgs 集合的一部分，代表一个构造方法参数。属性：`id`、`column`、`javaType`、`jdbcType`、`typeHandler`、`select`、`resultMap`。id 属性和 XML 元素 `<idArg>` 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。从版本 3.5.4 开始，该注解变为可重复注解。 |\r\n| `@TypeDiscriminator`                                         | `方法`   | `<discriminator>`                                          | 决定使用何种结果映射的一组取值（case）。属性：`column`、`javaType`、`jdbcType`、`typeHandler`、`cases`。cases 属性是一个 `Case` 的数组。 |\r\n| `@Case`                                                      | N/A      | `<case>`                                                   | 表示某个值的一个取值以及该取值对应的映射。属性：`value`、`type`、`results`。results 属性是一个 `Results` 的数组，因此这个注解实际上和 `ResultMap` 很相似，由下面的 `Results` 注解指定。 |\r\n| `@Results`                                                   | `方法`   | `<resultMap>`                                              | 一组结果映射，指定了对某个特定结果列，映射到某个属性或字段的方式。属性：`value`、`id`。value 属性是一个 `Result` 注解的数组。而 id 属性则是结果映射的名称。从版本 3.5.4 开始，该注解变为可重复注解。 |\r\n| `@Result`                                                    | N/A      | `<result>` `<id>`                                          | 在列和属性或字段之间的单个结果映射。属性：`id`、`column`、`javaType`、`jdbcType`、`typeHandler`、`one`、`many`。id 属性和 XML 元素 `<id>` 相似，它是一个布尔值，表示该属性是否用于唯一标识和比较对象。one 属性是一个关联，和 `<association>` 类似，而 many 属性则是集合关联，和 `<collection>` 类似。这样命名是为了避免产生名称冲突。 |\r\n| `@One`                                                       | N/A      | `<association>`                                            | 复杂类型的单个属性映射。属性： `select`，指定可加载合适类型实例的**映射语句**（也就是映射器方法）**全限定名**； `fetchType`，指定在该映射中覆盖全局配置参数 `lazyLoadingEnabled`； `resultMap`(available since 3.5.5), which is the fully qualified name of a result map that map to a single container object from select result； `columnPrefix`(available since 3.5.5), which is column prefix for grouping select columns at nested result map. **提示** 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。 |\r\n| `@Many`                                                      | N/A      | `<collection>`                                             | 复杂类型的集合属性映射。属性： `select`，指定可加载合适类型实例集合的映射语句（也就是映射器方法）全限定名； `fetchType`，指定在该映射中覆盖全局配置参数 `lazyLoadingEnabled` `resultMap`(available since 3.5.5), which is the fully qualified name of a result map that map to collection object from select result； `columnPrefix`(available since 3.5.5), which is column prefix for grouping select columns at nested result map. **提示** 注解 API 不支持联合映射。这是由于 Java 注解不允许产生循环引用。 |\r\n| `@MapKey`                                                    | `方法`   |                                                            | 供返回值为 Map 的方法使用的注解。它使用对象的某个**属性**作为 key，将对象 List 转化为 Map。属性：`value`，指定作为 Map 的 key 值的对象属性名。 |\r\n| `@Options`                                                   | `方法`   | 映射语句的属性                                             | 该注解允许你指定大部分开关和配置选项，它们通常在映射语句上作为属性出现。与在注解上提供大量的属性相比，`Options` 注解提供了一致、清晰的方式来指定选项。属性：`useCache=true`、`flushCache=FlushCachePolicy.DEFAULT`、`resultSetType=DEFAULT`、`statementType=PREPARED`、`fetchSize=-1`、`timeout=-1`、`useGeneratedKeys=false`、`keyProperty=\"\"`、`keyColumn=\"\"`、`resultSets=\"\"`, `databaseId=\"\"`。注意，Java 注解无法指定 `null` 值。因此，一旦你使用了 `Options` 注解，**你的语句就会被上述属性的默认值所影响**。要注意避免默认值带来的非预期行为。 The `databaseId`(Available since 3.5.5), in case there is a configured `DatabaseIdProvider`, the MyBatis use the `Options` with no `databaseId` attribute or with a `databaseId` that matches the current one. If found with and without the `databaseId` the latter will be discarded.      注意：`keyColumn` 属性只在某些数据库中有效（如 Oracle、PostgreSQL 等）。要了解更多关于 `keyColumn` 和 `keyProperty` 可选值信息，请查看“insert, update 和 delete”一节。 |\r\n| `@Insert`<br />`@Update`<br />`@Delete`<br />`@Select`       | `方法`   | `<insert>`<br />`<update>`<br />`<delete>`<br />`<select>` | 每个注解分别代表将会被执行的 SQL 语句。它们用字符串数组（或单个字符串）作为参数。如果传递的是字符串数组，字符串数组会被连接成单个完整的字符串，每个字符串之间加入一个空格。这有效地避免了用 Java 代码构建 SQL 语句时产生的“丢失空格”问题。当然，你也可以提前手动连接好字符串。属性：`value`，指定用来组成单个 SQL 语句的字符串数组。 The `databaseId`(Available since 3.5.5), in case there is a configured `DatabaseIdProvider`, the MyBatis use a statement with no `databaseId` attribute or with a `databaseId` that matches the current one. If found with and without the `databaseId` the latter will be discarded. |\r\n| `@InsertProvider`<br />`@UpdateProvider`<br />`@DeleteProvider`<br />`@SelectProvider` | `方法`   | `<insert>`<br />`<update>`<br />`<delete>`<br />`<select>` | 允许构建动态 SQL。这些备选的 SQL 注解允许你指定返回 SQL 语句的类和方法，以供运行时执行。（从 MyBatis 3.4.6 开始，可以使用 `CharSequence` 代替 `String` 来作为返回类型）。当执行映射语句时，MyBatis 会实例化注解指定的类，并调用注解指定的方法。你可以通过 `ProviderContext` 传递映射方法接收到的参数、\"Mapper interface type\" 和 \"Mapper method\"（仅在 MyBatis 3.4.5 以上支持）作为参数。（MyBatis 3.4 以上支持传入多个参数） 属性：`value`、`type`、`method`、`databaseId`。 `value` and `type` 属性用于指定类名 (The `type` attribute is alias for `value`, you must be specify either one. But both attributes can be omit when specify the `defaultSqlProviderType` as global configuration)。 `method` 用于指定该类的方法名（从版本 3.5.1 开始，可以省略 `method` 属性，MyBatis 将会使用 `ProviderMethodResolver` 接口解析方法的具体实现。如果解析失败，MyBatis 将会使用名为 `provideSql` 的降级实现）。**提示** 接下来的“SQL 语句构建器”一章将会讨论该话题，以帮助你以更清晰、更便于阅读的方式构建动态 SQL。 The `databaseId`(Available since 3.5.5), in case there is a configured `DatabaseIdProvider`, the MyBatis will use a provider method with no `databaseId` attribute or with a `databaseId` that matches the current one. If found with and without the `databaseId` the latter will be discarded. |\r\n| `@Param`                                                     | `参数`   | N/A                                                        | 如果你的映射方法接受多个参数，就可以使用这个注解自定义每个参数的名字。否则在默认情况下，除 `RowBounds` 以外的参数会以 \"param\" 加参数位置被命名。例如 `#{param1}`, `#{param2}`。如果使用了 `@Param(\"person\")`，参数就会被命名为 `#{person}`。 |\r\n| `@SelectKey`                                                 | `方法`   | `<selectKey>`                                              | 这个注解的功能与 `<selectKey>` 标签完全一致。该注解只能在 `@Insert` 或 `@InsertProvider` 或 `@Update` 或 `@UpdateProvider` 标注的方法上使用，否则将会被忽略。如果标注了 `@SelectKey` 注解，MyBatis 将会忽略掉由 `@Options` 注解所设置的生成主键或设置（configuration）属性。属性：`statement` 以字符串数组形式指定将会被执行的 SQL 语句，`keyProperty` 指定作为参数传入的对象对应属性的名称，该属性将会更新成新的值，`before` 可以指定为 `true` 或 `false` 以指明 SQL 语句应被在插入语句的之前还是之后执行。`resultType` 则指定 `keyProperty` 的 Java 类型。`statementType` 则用于选择语句类型，可以选择 `STATEMENT`、`PREPARED` 或 `CALLABLE` 之一，它们分别对应于 `Statement`、`PreparedStatement` 和 `CallableStatement`。默认值是 `PREPARED`。 The `databaseId`(Available since 3.5.5), in case there is a configured `DatabaseIdProvider`, the MyBatis will use a statement with no `databaseId` attribute or with a `databaseId` that matches the current one. If found with and without the `databaseId` the latter will be discarded. |\r\n| `@ResultMap`                                                 | `方法`   | N/A                                                        | 这个注解为 `@Select` 或者 `@SelectProvider` 注解指定 XML 映射中 `<resultMap>` 元素的 id。这使得注解的 select 可以复用已在 XML 中定义的 ResultMap。如果标注的 select 注解中存在 `@Results` 或者 `@ConstructorArgs` 注解，这两个注解将被此注解覆盖。 |\r\n| `@ResultType`                                                | `方法`   | N/A                                                        | 在使用了结果处理器的情况下，需要使用此注解。由于此时的返回类型为 void，所以 Mybatis 需要有一种方法来判断每一行返回的对象类型。如果在 XML 有对应的结果映射，请使用 `@ResultMap` 注解。如果结果类型在 XML 的 `<select>` 元素中指定了，就不需要使用其它注解了。否则就需要使用此注解。比如，如果一个标注了 @Select 的方法想要使用结果处理器，那么它的返回类型必须是 void，并且必须使用这个注解（或者 @ResultMap）。这个注解仅在方法返回类型是 void 的情况下生效。 |\r\n| `@Flush`                                                     | `方法`   | N/A                                                        | 如果使用了这个注解，定义在 Mapper 接口中的方法就能够调用 `SqlSession#flushStatements()` 方法。（Mybatis 3.3 以上可用） |\r\n\r\n##### 映射注解示例\r\n\r\n这个例子展示了如何使用 @SelectKey 注解来在插入前读取数据库序列的值：\r\n\r\n```java\r\n@Insert(\"insert into table3 (id, name) values(#{nameId}, #{name})\")\r\n@SelectKey(statement=\"call next value for TestSequence\", keyProperty=\"nameId\", before=true, resultType=int.class)\r\nint insertTable3(Name name);\r\n```\r\n\r\n这个例子展示了如何使用 @SelectKey 注解来在插入后读取数据库自增列的值：\r\n\r\n```java\r\n@Insert(\"insert into table2 (name) values(#{name})\")\r\n@SelectKey(statement=\"call identity()\", keyProperty=\"nameId\", before=false, resultType=int.class)\r\nint insertTable2(Name name);\r\n```\r\n\r\n这个例子展示了如何使用 `@Flush` 注解来调用 `SqlSession#flushStatements()`：\r\n\r\n```java\r\n@Flush\r\nList<BatchResult> flush();\r\n```\r\n\r\n这些例子展示了如何通过指定 @Result 的 id 属性来命名结果集：\r\n\r\n```java\r\n@Results(id = \"userResult\", value = {\r\n  @Result(property = \"id\", column = \"uid\", id = true),\r\n  @Result(property = \"firstName\", column = \"first_name\"),\r\n  @Result(property = \"lastName\", column = \"last_name\")\r\n})\r\n@Select(\"select * from users where id = #{id}\")\r\nUser getUserById(Integer id);\r\n\r\n@Results(id = \"companyResults\")\r\n@ConstructorArgs({\r\n  @Arg(column = \"cid\", javaType = Integer.class, id = true),\r\n  @Arg(column = \"name\", javaType = String.class)\r\n})\r\n@Select(\"select * from company where id = #{id}\")\r\nCompany getCompanyById(Integer id);\r\n```\r\n\r\n这个例子展示了如何使用单个参数的 @SqlProvider 注解：\r\n\r\n```java\r\n@SelectProvider(type = UserSqlBuilder.class, method = \"buildGetUsersByName\")\r\nList<User> getUsersByName(String name);\r\n\r\nclass UserSqlBuilder {\r\n  public static String buildGetUsersByName(final String name) {\r\n    return new SQL(){{\r\n      SELECT(\"*\");\r\n      FROM(\"users\");\r\n      if (name != null) {\r\n        WHERE(\"name like #{value} || \'%\'\");\r\n      }\r\n      ORDER_BY(\"id\");\r\n    }}.toString();\r\n  }\r\n}\r\n```\r\n\r\n这个例子展示了如何使用多个参数的 @SqlProvider 注解：\r\n\r\n```java\r\n@SelectProvider(type = UserSqlBuilder.class, method = \"buildGetUsersByName\")\r\nList<User> getUsersByName(\r\n    @Param(\"name\") String name, @Param(\"orderByColumn\") String orderByColumn);\r\n\r\nclass UserSqlBuilder {\r\n\r\n  // 如果不使用 @Param，就应该定义与 mapper 方法相同的参数\r\n  public static String buildGetUsersByName(\r\n      final String name, final String orderByColumn) {\r\n    return new SQL(){{\r\n      SELECT(\"*\");\r\n      FROM(\"users\");\r\n      WHERE(\"name like #{name} || \'%\'\");\r\n      ORDER_BY(orderByColumn);\r\n    }}.toString();\r\n  }\r\n\r\n  // 如果使用 @Param，就可以只定义需要使用的参数\r\n  public static String buildGetUsersByName(@Param(\"orderByColumn\") final String orderByColumn) {\r\n    return new SQL(){{\r\n      SELECT(\"*\");\r\n      FROM(\"users\");\r\n      WHERE(\"name like #{name} || \'%\'\");\r\n      ORDER_BY(orderByColumn);\r\n    }}.toString();\r\n  }\r\n}\r\n```\r\n\r\n这个例子可以配置一个 sql provider 类应用到所有映射方法：\r\n\r\n```java\r\nConfiguration configuration = new Configuration();\r\nconfiguration.setDefaultSqlProviderType(TemplateFilePathProvider.class); \r\n```\r\n\r\n```java\r\n// 可以不用指定 type/value 属性\r\n// 如果省略这两个属性，MyBatis 会使用 defaultSqlProviderType 指定的类\r\n\r\npublic interface UserMapper {\r\n\r\n  @SelectProvider // Same with @SelectProvider(TemplateFilePathProvider.class)\r\n  User findUser(int id);\r\n}\r\n```\r\n\r\n以下例子展示了 `ProviderMethodResolver`（3.5.1 后可用）的默认实现使用方法：\r\n\r\n```java\r\n@SelectProvider(UserSqlProvider.class)\r\nList<User> getUsersByName(String name);\r\n\r\n// 在你的 provider 类中实现 ProviderMethodResolver 接口\r\nclass UserSqlProvider implements ProviderMethodResolver {\r\n  // 默认实现中，会将映射器方法的调用解析到实现的同名方法上\r\n  public static String getUsersByName(final String name) {\r\n    return new SQL(){{\r\n      SELECT(\"*\");\r\n      FROM(\"users\");\r\n      if (name != null) {\r\n        WHERE(\"name like #{value} || \'%\'\");\r\n      }\r\n      ORDER_BY(\"id\");\r\n    }}.toString();\r\n  }\r\n}\r\n```\r\n\r\n这个示例展示了在注解中使用 `databaseId` 属性：\r\n\r\n```java\r\n@Select(value = \"SELECT SYS_GUID() FROM dual\", databaseId = \"oracle\") // Use this statement if DatabaseIdProvider provide \"oracle\"\r\n@Select(value = \"SELECT uuid_generate_v4()\", databaseId = \"postgres\") // Use this statement if DatabaseIdProvider provide \"postgres\"\r\n@Select(\"SELECT RANDOM_UUID()\") // Use this statement if the DatabaseIdProvider not configured or not matches databaseId\r\nString generateId();\r\n```\r\n\r\n# SQL 语句构建器\r\n\r\n## SQL 类\r\n\r\n```java\r\n// 匿名内部类风格\r\npublic String deletePersonSql() {\r\n  return new SQL() {{\r\n    DELETE_FROM(\"PERSON\");\r\n    WHERE(\"ID = #{id}\");\r\n  }}.toString();\r\n}\r\n\r\n// Builder / Fluent 风格\r\npublic String insertPersonSql() {\r\n  String sql = new SQL()\r\n    .INSERT_INTO(\"PERSON\")\r\n    .VALUES(\"ID, FIRST_NAME\", \"#{id}, #{firstName}\")\r\n    .VALUES(\"LAST_NAME\", \"#{lastName}\")\r\n    .toString();\r\n  return sql;\r\n}\r\n\r\n// 动态条件（注意参数需要使用 final 修饰，以便匿名内部类对它们进行访问）\r\npublic String selectPersonLike(final String id, final String firstName, final String lastName) {\r\n  return new SQL() {{\r\n    SELECT(\"P.ID, P.USERNAME, P.PASSWORD, P.FIRST_NAME, P.LAST_NAME\");\r\n    FROM(\"PERSON P\");\r\n    if (id != null) {\r\n      WHERE(\"P.ID like #{id}\");\r\n    }\r\n    if (firstName != null) {\r\n      WHERE(\"P.FIRST_NAME like #{firstName}\");\r\n    }\r\n    if (lastName != null) {\r\n      WHERE(\"P.LAST_NAME like #{lastName}\");\r\n    }\r\n    ORDER_BY(\"P.LAST_NAME\");\r\n  }}.toString();\r\n}\r\n\r\npublic String deletePersonSql() {\r\n  return new SQL() {{\r\n    DELETE_FROM(\"PERSON\");\r\n    WHERE(\"ID = #{id}\");\r\n  }}.toString();\r\n}\r\n\r\npublic String insertPersonSql() {\r\n  return new SQL() {{\r\n    INSERT_INTO(\"PERSON\");\r\n    VALUES(\"ID, FIRST_NAME\", \"#{id}, #{firstName}\");\r\n    VALUES(\"LAST_NAME\", \"#{lastName}\");\r\n  }}.toString();\r\n}\r\n\r\npublic String updatePersonSql() {\r\n  return new SQL() {{\r\n    UPDATE(\"PERSON\");\r\n    SET(\"FIRST_NAME = #{firstName}\");\r\n    WHERE(\"ID = #{id}\");\r\n  }}.toString();\r\n}\r\n```\r\n\r\n| 方法                                                         | 描述                                                         |\r\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| `SELECT(String)`<br />`SELECT(String...)`                    | 开始新的或追加到已有的 `SELECT`子句。可以被多次调用，参数会被追加到 `SELECT` 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。 |\r\n| `SELECT_DISTINCT(String)`<br />`SELECT_DISTINCT(String...)`  | 开始新的或追加到已有的 `SELECT`子句，并添加 `DISTINCT` 关键字到生成的查询中。可以被多次调用，参数会被追加到 `SELECT` 子句。 参数通常使用逗号分隔的列名和别名列表，但也可以是数据库驱动程序接受的任意参数。 |\r\n| `FROM(String)`<br />`FROM(String...)`                        | 开始新的或追加到已有的 `FROM`子句。可以被多次调用，参数会被追加到 `FROM`子句。 参数通常是一个表名或别名，也可以是数据库驱动程序接受的任意参数。 |\r\n| `JOIN(String)`<br />`JOIN(String...)`<br />`INNER_JOIN(String)`<br />`INNER_JOIN(String...)`<br />`LEFT_OUTER_JOIN(String)`<br />`LEFT_OUTER_JOIN(String...)`<br />`RIGHT_OUTER_JOIN(String)`<br />`RIGHT_OUTER_JOIN(String...)` | 基于调用的方法，添加新的合适类型的 `JOIN` 子句。 参数可以包含一个由列和连接条件构成的标准连接。 |\r\n| `WHERE(String)`<br />`WHERE(String...)`                      | 插入新的 `WHERE` 子句条件，并使用 `AND` 拼接。可以被多次调用，对于每一次调用产生的新条件，会使用 `AND` 拼接起来。要使用 `OR` 分隔，请使用 `OR()`。 |\r\n| `OR()`                                                       | 使用 `OR` 来分隔当前的 `WHERE` 子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 `SQL`。 |\r\n| `AND()`                                                      | 使用 `AND` 来分隔当前的 `WHERE`子句条件。 可以被多次调用，但在一行中多次调用会生成错误的 `SQL`。由于 `WHERE` 和 `HAVING`都会自动使用 `AND` 拼接, 因此这个方法并不常用，只是为了完整性才被定义出来。 |\r\n| `GROUP_BY(String)`<br />`GROUP_BY(String...)`                | 追加新的 `GROUP BY` 子句，使用逗号拼接。可以被多次调用，每次调用都会使用逗号将新的条件拼接起来。 |\r\n| `HAVING(String)`<br />`HAVING(String...)`                    | 追加新的 `HAVING` 子句。使用 AND 拼接。可以被多次调用，每次调用都使用`AND`来拼接新的条件。要使用 `OR` 分隔，请使用 `OR()`。 |\r\n| `ORDER_BY(String)`<br />`ORDER_BY(String...)`                | 追加新的 `ORDER BY` 子句，使用逗号拼接。可以多次被调用，每次调用会使用逗号拼接新的条件。 |\r\n| `LIMIT(String)`<br />`LIMIT(int)`                            | 追加新的 `LIMIT` 子句。 仅在 SELECT()、UPDATE()、DELETE() 时有效。 当在 SELECT() 中使用时，应该配合 OFFSET() 使用。（于 3.5.2 引入） |\r\n| `OFFSET(String)`<br />`OFFSET(long)`                         | 追加新的 `OFFSET` 子句。 仅在 SELECT() 时有效。 当在 SELECT() 时使用时，应该配合 LIMIT() 使用。（于 3.5.2 引入） |\r\n| `OFFSET_ROWS(String)`<br />`OFFSET_ROWS(long)`               | 追加新的 `OFFSET n ROWS` 子句。 仅在 SELECT() 时有效。 该方法应该配合 FETCH_FIRST_ROWS_ONLY() 使用。（于 3.5.2 加入） |\r\n| `FETCH_FIRST_ROWS_ONLY(String)`<br />`FETCH_FIRST_ROWS_ONLY(int)` | 追加新的 `FETCH FIRST n ROWS ONLY` 子句。 仅在 SELECT() 时有效。 该方法应该配合 OFFSET_ROWS() 使用。（于 3.5.2 加入） |\r\n| `DELETE_FROM(String)`                                        | 开始新的 delete 语句，并指定删除表的表名。通常它后面都会跟着一个 WHERE 子句！ |\r\n| `INSERT_INTO(String)`                                        | 开始新的 insert 语句，并指定插入数据表的表名。后面应该会跟着一个或多个 VALUES() 调用，或 INTO_COLUMNS() 和 INTO_VALUES() 调用。 |\r\n| `SET(String)` `SET(String...)`                               | 对 update 语句追加 \"set\" 属性的列表                          |\r\n| `UPDATE(String)`                                             | 开始新的 update 语句，并指定更新表的表名。后面都会跟着一个或多个 SET() 调用，通常也会有一个 WHERE() 调用。 |\r\n| `VALUES(String, String)`                                     | 追加数据值到 insert 语句中。第一个参数是数据插入的列名，第二个参数则是数据值。 |\r\n| `INTO_COLUMNS(String...)`                                    | 追加插入列子句到 insert 语句中。应与 INTO_VALUES() 一同使用。 |\r\n| `INTO_VALUES(String...)`                                     | 追加插入值子句到 insert 语句中。应与 INTO_COLUMNS() 一同使用。 |\r\n| `ADD_ROW()`                                                  | 添加新的一行数据，以便执行批量插入。（于 3.5.2 引入）        |\r\n\r\n**提示** 注意，SQL 类将原样插入 `LIMIT`、`OFFSET`、`OFFSET n ROWS` 以及 `FETCH FIRST n ROWS ONLY` 子句。\r\n\r\n从版本 3.5.2 开始，你可以像下面这样构建批量插入语句：\r\n\r\n```java\r\npublic String insertPersonsSql() {\r\n  return new SQL()\r\n    .INSERT_INTO(\"PERSON\")\r\n    .INTO_COLUMNS(\"ID\", \"FULL_NAME\")\r\n    .INTO_VALUES(\"#{mainPerson.id}\", \"#{mainPerson.fullName}\")\r\n    .ADD_ROW()\r\n    .INTO_VALUES(\"#{subPerson.id}\", \"#{subPerson.fullName}\")\r\n    .toString();\r\n}\r\n```\r\n\r\n从版本 3.5.2 开始，你可以像下面这样构建限制返回结果数的 SELECT 语句,：\r\n\r\n```java\r\npublic String selectPersonsWithOffsetLimitSql() {\r\n  // SELECT id, name FROM PERSON\r\n  //     LIMIT #{limit} OFFSET #{offset}\r\n  return new SQL()\r\n    .SELECT(\"id\", \"name\")\r\n    .FROM(\"PERSON\")\r\n    .LIMIT(\"#{limit}\")\r\n    .OFFSET(\"#{offset}\")\r\n    .toString();\r\n}\r\n\r\npublic String selectPersonsWithFetchFirstSql() {\r\n  // SELECT id, name FROM PERSON\r\n  //     OFFSET #{offset} ROWS FETCH FIRST #{limit} ROWS ONLY\r\n  return new SQL()\r\n    .SELECT(\"id\", \"name\")\r\n    .FROM(\"PERSON\")\r\n    .OFFSET_ROWS(\"#{offset}\")\r\n    .FETCH_FIRST_ROWS_ONLY(\"#{limit}\")\r\n    .toString();\r\n}\r\n```\r\n\r\n# 日志\r\n\r\n内置日志工厂将会把日志工作委托给下面的实现之一：\r\n\r\n- SLF4J\r\n- Apache Commons Logging\r\n- Log4j 2\r\n- Log4j\r\n- JDK logging\r\n\r\nMyBatis 内置日志工厂会基于运行时检测信息选择日志委托实现。它会（按上面罗列的顺序）使用第一个查找到的实现。当没有找到这些实现时，将会禁用日志功能。\r\n\r\n不少应用服务器（如 Tomcat 和 WebShpere）的类路径中已经包含 Commons Logging，会导致 MyBatis 把 Commons Logging 作为日志工具，你的 Log4J 配置将被忽略。这种情况如果想使用其它日志实现，可以配置：\r\n\r\n```xml\r\n<configuration>\r\n  <settings>\r\n    <setting name=\"logImpl\" value=\"LOG4J\"/>\r\n    ...\r\n  </settings>\r\n</configuration>\r\n```\r\n\r\n可选的值有：SLF4J、LOG4J、LOG4J2、JDK_LOGGING、COMMONS_LOGGING、STDOUT_LOGGING、NO_LOGGING，或者是实现了 `org.apache.ibatis.logging.Log` 接口，且构造方法以字符串为参数的类完全限定名。\r\n\r\n也可以调用以下任一方法来选择日志实现：\r\n\r\n```java\r\norg.apache.ibatis.logging.LogFactory.useSlf4jLogging();\r\norg.apache.ibatis.logging.LogFactory.useLog4JLogging();\r\norg.apache.ibatis.logging.LogFactory.useJdkLogging();\r\norg.apache.ibatis.logging.LogFactory.useCommonsLogging();\r\norg.apache.ibatis.logging.LogFactory.useStdOutLogging();\r\n```\r\n\r\n你应该在调用其它 MyBatis 方法之前调用以上的某个方法。另外，**仅当运行时类路径中存在该日志实现时**，日志实现的切换才会生效。\r\n\r\n## 日志配置\r\n\r\n接下来我们会以 Log4J 作为示范来演示配置日志。\r\n\r\n### 步骤 1：添加 Log4J 的 jar 包\r\n\r\n### 步骤 2：配置 Log4J\r\n\r\n假设你需要记录这个映射器的日志：\r\n\r\n```java\r\npackage org.mybatis.example;\r\npublic interface BlogMapper {\r\n  @Select(\"SELECT * FROM blog WHERE id = #{id}\")\r\n  Blog selectBlog(int id);\r\n}\r\n```\r\n\r\n在应用的类路径中创建一个名为 `log4j.properties` 的文件，文件的具体内容如下：\r\n\r\n```properties\r\n# 全局日志配置\r\nlog4j.rootLogger=ERROR, stdout\r\n# MyBatis 日志配置\r\nlog4j.logger.org.mybatis.example.BlogMapper=TRACE\r\n# 控制台输出\r\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\r\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\r\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\r\n```\r\n\r\n上述配置将使 Log4J 详细打印 `org.mybatis.example.BlogMapper` 的日志，对于应用的其它部分，只打印错误信息。\r\n\r\n也可以只打印特定语句的日志。以下配置将只打印语句 `selectBlog` 的日志：\r\n\r\n```properties\r\nlog4j.logger.org.mybatis.example.BlogMapper.selectBlog=TRACE\r\n```\r\n\r\n或者，也可以打印一组映射器的日志，只需要打开映射器所在的包的日志功能即可：\r\n\r\n```properties\r\nlog4j.logger.org.mybatis.example=TRACE\r\n```\r\n\r\n如果值相查看 SQL 语句，忽略返回的结果集，可以配置为 DEBUG 日志级别：\r\n\r\n```properties\r\nlog4j.logger.org.mybatis.example=DEBUG\r\n```\r\n\r\n**提示** *如果你使用的是 SLF4J 或 Log4j 2，MyBatis 会设置 tag 为 MYBATIS。*\r\n\r\nlog4j.properties 的其它配置信息可以参考 Log4J 网站。\r\n\r\n\r\n\r\n', '阅读 MyBatis 官方指导时所做的笔记', '鸡米花', 'IMG_3331.JPG', '1', '0', '8', '2021-08-13 16:13:02', '2021-08-13 16:13:02');
INSERT INTO `t_blog` VALUES ('5', 'shiro 学习笔记', '# 特性\r\n\r\nmaven 依赖\r\n\r\n```\r\n<dependency>\r\n            <groupId>org.apache.shiro</groupId>\r\n            <artifactId>shiro-core</artifactId>\r\n            <version>1.4.1</version>\r\n</dependency>\r\n```\r\n\r\n\r\n\r\n## 四大基石\r\n\r\n- 授权\r\n- 认证\r\n- 会话管理\r\n- 加密\r\n\r\n## 架构\r\n\r\nShiro 的架构有三个主要的概念：Subject、SecurityManager 和 Realms。下图是高级概述组件的交互：\r\n\r\n![ShiroBasicArchitecture](E:\\学习笔记\\assets\\ShiroBasicArchitecture.png)\r\n\r\n- Subject：本质上是当前执行用户的安全特定的“视图”。虽然“User”这个词通常意味着一个人，但一个 Subject 可以是一个人，但它也可以代表一个 3rd-party 服务、守护进程帐户、cron 工作，或者类似的东西——基本上是任何与软件交互的东西。所有 Subject 绑定（以及需要）到 SecurityManager。当你与一个 Subject 交互时，这些交互就会转化为与 SecurityManager 的 subject-specific 的交互。\r\n- SecurityManager：SecurityManager 是 Shiro 的架构的核心，它充当了一个“伞(umbrella)”对象，它协调其内部安全组件，并组成一个对象图。然而，一旦 SecurityManager 和它的内部对象图配置为应用程序，它通常是单独的，应用程序开发人员几乎把所有的时间都花在 Subject API上 。\r\n- Realms：Realms 作为一个 Shiro 和应用程序安全数据的“桥”或“连接器”。当涉及到与安全性相关的数据交互时，像用户帐户来执行身份验证(登录)和授权(访问控制)，Shiro 从一个或多个应用程序配置的 Realms 查找很多这些。在这个意义上，一个 Realms 本质上是一个特定于安全的 DAO：它封装了数据源的连接细节，并根据需要将相关数据提供给 Shiro。在配置 Shiro 时，必须指定至少一个 Realms 来使用身份验证和/或授权。Shiro 提供开箱即用的 Realms，用来连接到一些安全数据源，例如 LDAP、关系数据库(JDBC)、文本配置源，如 INI 和 properties 文件，以及更多。也可以插入自己的 Realms 实现来表示自定义数据源。\r\n\r\n## 详细架构\r\n\r\n下图显示了 Shiro 的核心架构概念，其次是每个对象的短摘要：\r\n\r\n![ShiroArchitecture](E:\\学习笔记\\assets\\ShiroArchitecture.png)\r\n\r\n#### Subject\r\n\r\n`org.apache.shiro.subject.Subject`\r\n\r\n目前与软件交互的实体(用户、3rd-party 服务、cron job等)的安全特定的“视图”。\r\n\r\n#### SecurityManager\r\n\r\n`org.apache.shiro.mgt.SecurityManager`\r\n\r\n如上所述，SecurityManager 是 Shiro 架构的核心。它主要是一个“伞”对象，它协调其管理的组件，以确保它们在一起工作顺利。它还管理 Shiro 对每个应用程序用户的视图，因此它知道如何执行每个用户的安全操作。\r\n\r\n#### Authenticator\r\n\r\n`org.apache.shiro.authc.Authenticator`\r\n\r\nAuthenticator 是负责执行和响应用户认证（log-in）的组件。当用户尝试登录时，逻辑被 Authenticator 执行。Authenticator 知道如何与一个或多个存储用户账户相关信息的 Realms 协调。由 Realms 提供的数据用于证实用户身份。\r\n\r\n##### Authentication Strategy\r\n\r\n`org.apache.shiro.authc.pam.AuthenticaionStrategy`\r\n\r\n如果配置了超过一个 Realms，AuthenticationStrategy 会协调 Realms 来决定身份验证尝试成功或失败的条件（例如，如果一个 realm 成功但是其它的失败了，是否为成功？必须所有 realms 都成功？只有第一个？）。\r\n\r\n#### Authorizer\r\n\r\n`org.apache.shiro.authz.Authorizer`\r\n\r\nAuthorizer 负责于应用程序中确定用户访问控制的组件。它是最终表示如果用户被允许做某事的机制。像 Authenticator，Authorizer 也知道如何去协调多个后端是数据源来访问角色和权限信息。Authorizer 使用这些信息来决定用户是否被允许执行给定的操作。\r\n\r\n#### SessionManager\r\n\r\n`org.apache.shiro.session.mgt.SessionManager`\r\n\r\nSessionManager 知道如何创建和管理用户 Session 生命周期，为所有环境中的用户提供一个健壮的会话体验。这是安全框架世界的一个独特的特性——Shiro 在任何环境中都有能力管理用户会话，即使没有 Web/Servlet 或 EJB 容器。在默认情况下，Shiro 将使用现有的会话机制(例如Servlet 容器)，但如果没有一个独立的应用程序或非 web 环境，它将使用其内置的企业会话管理来提供相同的编程体验。SessionDAO 存在，允许任何数据源用于持久化会话。\r\n\r\n##### SessionDAO\r\n\r\n`org.apache.shiro.session.mgt.eis.SessionDAO`\r\n\r\nSessionDAO 代表 SessionManager 执行会话持久性(CRUD)操作。这允许将任何数据存储插入到会话管理基础结构中。\r\n\r\n#### CacheManager\r\n\r\n`org.apache.shiro.cachee.CacheManager`\r\n\r\nCacheManager 创建和管理其他Shiro组件使用的 Cache 实例生命周期。因为 Shiro 可以访问很多后端数据源进行身份验证、授权和会话管理，在使用这些数据源时，缓存一直是框架中最一流的架构特性，以提高性能。任何现代开源和/或企业缓存产品都可以被插上，以提供一个快速而高效的用户体验。\r\n\r\n#### Cryptography\r\n\r\n`org.apache.shiro.crypto.*`\r\n\r\nCryptography 是企业安全框架的自然补充。Shiro 的 `crypto` 包包含易于使用和理解crytographic Ciphers、Hashes(aka中间件)和不同的编码解码器实现的表示。这个包的所有类都是精心设计的，易于使用和易于理解。任何使用 Java 原生加密支持的人都知道它可能是一种具有挑战性的。Shiro 的  crypto API 简化了复杂的 Java 机制，并使密码学很容易用于普通的人类。\r\n\r\n#### Realms\r\n\r\n`org.apache.shiro.realm.Realm`\r\n\r\n如上所述，Realms 是 Shiro 和应用程序安全数据之间的“桥”或“连接器”。当涉及到与安全性相关的数据交互时，像用户帐户来执行身份验证(登录)和授权(访问控制)，Shiro 从一个或多个配置的应用程序中查找这些东西中的许多。你可以配置你需要的领域(通常是一个数据源)，Shiro 将与它们协调，以验证和授权。\r\n\r\n### SecurityManager\r\n\r\n由于 Shiro 的 API 鼓励以 Subject 为中心的编程方法，大多数应用程序开发人员很少会直接与 SecurityManager 。即便如此，了解安全管理器的功能仍然很重要，特别是在配置一个应用程序时。\r\n\r\n## 设计\r\n\r\n应用程序的 SecurityManager 执行安全操作，并为所有应用程序用户管理状态。在 Shiro 的默认 SecurityManager 实现，包括：\r\n\r\n- Authentication\r\n- Authorization\r\n- Session Management\r\n- Cache Management\r\n- Realm coordination\r\n- Event propagation\r\n- “Remember Me” Services\r\n- Subject creation\r\n- Logout and more\r\n\r\n但这是一种尝试在单个组件中管理的功能。而且，如果把所有的东西都集中在一个实现类中，那么让这些东西变得灵活和可定制是非常困难的。\r\n\r\n为了简化配置和启用灵活的配置/可插入性，Shiro 的实现在设计中是高度模块化的——事实上，模块化管理(以及它的类层次结构)根本没有做太多事情。相反，SecurityManager 实现主要表现为轻量级的“容器”组件，几乎将所有行为委托给 嵌套/包装 组件。这个“包装器”的设计反映在上面的详细架构图中。\r\n\r\n当组件实际执行逻辑时，SecurityManager 实现就知道如何以及何时为正确的行为协调组件。\r\n\r\nSecurityManager 实现和组件都是 JavaBeans 兼容的，它允许你（或配置机制）通过标准的 JavaBeans accessor/mutator（get\\*/set\\*）很容易定制可插入的组件。这意味着Shiro的架构模块化可以转化为非常简单的定制行为配置。\r\n\r\n# 核心\r\n\r\n## Authentication\r\n\r\nAuthentication 是身份认证的过程，也就是说，证明一个用户实际上是他们所说的。对于用户来证明他们的身份，他们需要提供一些识别信息，以及你的系统理解和信任的身份证明。\r\n\r\n这是通过向 Shiro 提交用户的主体（principals）和证明（credentials）来完成的，看看它们是否符合应用程序的预期。\r\n\r\n- **Principals** 是一个 Subject 的 “identifying attributes”。Principals 可以是任何标识一个 Subject 的东西，例如名、姓、用户名、社保号等。当然，使用身份验证的最好的原则对于应用程序来说是独一无二的——通常是一个用户名或电子邮件地址。\r\n- **Credentials** 通常是只有 Subject 知道的秘密的值，用作证明他们实际上自己的“自称”身份的证据。一些常见的证书例子是密码、像指纹、视网膜这些生物识别数据、X.509 证书。\r\n\r\n*Shiro 可以表现任意数量的 principals，Shiro 期望应用程序正好只有一个 “Primary” principal。*\r\n\r\nprincipal/credential 对最常见的例子是用户名和密码。用户名是声称的身份，密码是匹配声称身份的证明。如果一个提交的密码匹配应用程序的预期，应用程序可能会很大程度上假设用户真的是他们说的，因为没有人应该知道相同的密码。\r\n\r\n### Authenticating Subjects\r\n\r\n验证一个 Subject 的过程可以有效地分解成三个不同的步骤：\r\n\r\n1. 收集 Subject 提交的 principals 和 credentials。\r\n2. 提交身份验证的 principals 和 credentials。\r\n3. 如果提交成功，允许访问，其它情况重新验证或禁止访问。\r\n\r\n#### Step 1\r\n\r\n```java\r\n//Example using most common scenario of username/password pair:\r\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n\r\n//\"Remember Me\" built-in: \r\ntoken.setRememberMe(true);\r\n```\r\n\r\n在这个特殊的例子中，我们使用 UsernamePasswordToken，支持最常见的用户名/密码身份验证方法。这是 `org.apache.shiro.authc.AuthenticationToken` 接口的一个实现，是 Shiro 认证系统使用的基本接口，以表示提交的主体和凭证。\r\n\r\n很重要的一点是，Shiro 不关心你如何获取此信息：也许数据是由提交 HTML 表单的用户获取的，或者可能是从 HTTP 标题中检索到的，或者可能是从 Swing 或 Flex GUI 密码表单中读取的，或者是通过命令行参数读取的。从应用程序最终用户收集信息的过程完全与 Shiro 的身份验证概念分离。\r\n\r\n你可以用你喜欢的方式构建并表示 AuthenticationToken 实例。\r\n\r\n这个例子也展示了我们希望 Shiro “Remember Me” 。\r\n\r\n#### Step 2\r\n\r\n在 principals 和 credentials 被收集并用 AuthenticationToken 实例表示后，我们需要提交这个 token 到 Shiro 来执行实际的身份验证尝试：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\ncurrentUser.login(token);\r\n```\r\n\r\n在获取当前执行的 Subject 后，我们进行了一个单独的 login 调用，传递入我们之前创建的 Authentication Token 实例。\r\n\r\n#### Step 3\r\n\r\n处理成功或失败。\r\n\r\n如果 login 方法安静的返回，就是这样，我们完成了！这个 Subject 通过认证了。应用程序线程可以不间断的继续并且所有进一步调用 SecurityUtils.getSubject() 会返回一个已认证的 Subject 实例，所有 subject.isAuthenticated() 会返回 true。\r\n\r\n如果登录尝试失败，例如错误的密码、尝试访问系统次数太多或账户被锁定。\r\n\r\nShiro 有丰富的运行时异常 AuthenticationException 层次，指示为什么尝试失败。你可以用 try/catch 块包裹 login ，捕捉任何你希望的异常，并相应地对它们做出反应。例如：\r\n\r\n```java\r\ntry {\r\n    currentUser.login(token);\r\n} catch ( UnknownAccountException uae ) { ...\r\n} catch ( IncorrectCredentialsException ice ) { ...\r\n} catch ( LockedAccountException lae ) { ...\r\n} catch ( ExcessiveAttemptsException eae ) { ...\r\n} ... catch your own ...\r\n} catch ( AuthenticationException ae ) {\r\n    //unexpected error?\r\n}\r\n\r\n//No problems, continue on as expected...\r\n```\r\n\r\n如果存在的异常类中的一个不满足你的需求，可以创建自定义 AuthenticationExceptions ，以表示特定的失败场景。\r\n\r\n*虽然你的代码可以对特定的异常做出反应，但安全最佳实践是只在失败的情况下向最终用户显示一个通用的故障消息，例如“错误的用户名或密码”。确保没有提供特定信息给攻击你的黑客。*\r\n\r\n### Remebered vs Authenticated\r\n\r\nShiro 支持“记住我”的概念，除了正常的登录过程。现在值得指出的是，Shiro 在一个 remembered Subject 和一个真实的 authenticated Subject 之间有一个非常精确的区别：\r\n\r\n- Remembered：一个记住的 Subject 不是匿名的，有一个已知的身份标识（例如 subject.getPrincipals() 不是空的）。但是这个标识在前一个会话中的认证被记住。如果 subject.isRemebered() 返回 true，Subject 认为是 remembered。\r\n- Authenticated：通过认证的 Subject 是在主体当前会话期间成功验证的(即在不抛出异常的情况下调用的 login 方法)。如果 subject.isAuthenticated() 返回 true，认为 subject 是认证的。\r\n\r\n*Remembered 和 authenticated 的状态是相互排斥的——一个 true 意味着另一个 false，反之亦然。*\r\n\r\n#### 为什么有区别？\r\n\r\n“认证”一词具有很强的证明内涵。也就是说，有一个预期的保证，这个 Subject 已经证明了他们是他所说的。\r\n\r\n当用户只是上次交互记住时，证明状态已经不再存在：被记住的身份给了系统一个用户可能是谁的想法，但在现实中，没有绝对保证被记住的 Subject 是期望的用户。一旦这个 Subject 被验证，它们不再被认为只被记住，因为它们的身份将在当前会话中得到验证。\r\n\r\n因此，尽管应用程序的许多部分仍然可以基于被记住的主体(例如自定义视图)执行用户特定的逻辑，但它通常不应该执行高度敏感的操作，直到用户通过执行成功的身份验证尝试合法地验证它们的身份。\r\n\r\n例如，检查 Subject 是否可以访问财务信息几乎总是依赖 isAuthenticated()，而不是 isRemembered()，以确保一个期望和已认证的身份。\r\n\r\n#### An illustrating example\r\n\r\n下面是一个相当常见的场景，可以解释为什么记住和身份验证之间的区别很重要。\r\n\r\n假如你在用亚马逊。你已经登录成功并且添加了几本书到购物车。但是你必须要离开去开会，但是忘记退出登录了。会议结束的时候，你又要回家了。\r\n\r\n第二天你来工作的时候，你意识到你还没有完成你的购物，所以你回到亚马逊网站。这次，亚马逊记住了你是谁，用你的名字问候你，还给你推荐一些个性化的书。对于亚马逊，subject.isRemembered() 会返回 true。\r\n\r\n但是，如果你访问你的账户去更新你的信用卡信息来买书时会发生什么？亚马逊记住了你（isRemembered()==true），它不能保证你是真实的你（例如，可能同时使用你的电脑）。\r\n\r\n所以在你执行像更新信用卡信息这样的敏感操作时，亚马逊会强制你登录，这样它们能够确保你的身份。登录后，你的身份通过亚马逊认证，isAuthenticated() 会返回 true。\r\n\r\n这种场景经常发生在许多类型的应用程序中，所以这个功能内置在 Shiro 中，这样你就在你的应用利用它。选择，是否使用 isRemembered() 或 isAuthenticated() 来自定义你的视图和工作流程取决于你。\r\n\r\n### Logging Out\r\n\r\n认证的反面是释放所有已知的标识状态。当 Subject 完成与应用程序交互时，你可以调用 subject.logout() 放弃所有识别信息：\r\n\r\n```java\r\ncurrentUser.logout(); //removes all identifying information and invalidates their session too.\r\n```\r\n\r\n当你调用 logout，所有已经在的 Session 会失效并且所有的身份会失去关联（例如在 web app，RememberMe cookie 也会被删除）。\r\n\r\nSubject 退出登录后，Subject 实例再次被认为是匿名的，除了 web 应用程序之外，如果需要，可以重新使用 login。\r\n\r\nWeb 应用注意：因为在 web 应用程序中被记住的标识通常是在 cookie 中持久化的，而 cookie 只能在响应体被提交之前删除，所以强烈建议在调用 subject.logout() 后立即将最终用户重定向到新的视图或页面。这保证任何与安全相关的 cookie 都按照预期删除。这是HTTP  cookie 功能的限制，而不是 Shiro 的限制。\r\n\r\n### Authentication Sequence\r\n\r\n现在看看尝试认证时 Shiro 里面会发生什么。从体系结构的章节中删除了以前的架构图，只剩下与身份验证相关的组件。在身份验证尝试中，每个数字都代表了一个步骤：\r\n\r\n![ShiroAuthenticationSequence](E:\\学习笔记\\assets\\ShiroAuthenticationSequence.png)\r\n\r\n**Step 1：**应用程序代码调用 Subject.login 方法，传入构造的 AuthenticationToken 实例，它代表终端用户的 principal 和 credentials。\r\n\r\n**Step 2：**Subject 实例，典型的是 DelegatingSubject（或子类）通过调用 securityManager.login(token) 委托给应用的 SecurityManager，真正的认证工作开始。\r\n\r\n**Step 3：**SecurityManager 作为一个基本的“伞”组件，接收这个 token 并且通过调用 authenticator.authenticate(token) 方法简单的委托给他的内部 Authenticator 实例。这几乎总是 ModularRealmAuthenticator 实例，它支持协调一个或多个 Realm 实例。ModularRealmAuthenticator 本质上提供一个 PAM 风格范例给 Apache Shiro（在 PAM 术语中，每个 Realm 都是一个“模块”）。\r\n\r\n**Step 4：**如果超过一个 Realm 被配置到应用，ModularRealmAuthenticator 实例会利用它配置的 AuthenticationStrategy 发起 multi-Realm 认证尝试。在 Realm 被调用进行身份验证之前，期间和之后，AuthenticationStrategy 将被调用以允许它对每个 Realm 的结果做出反应。\r\n\r\n*如果只配置了单个Realm，则直接调用它——在单个Realm应用程序中不需要 AuthenticationStrategy。*\r\n\r\n**Step 5：**将咨询每个配置的Realm，以查看它是否支持提交的 AuthenticationToken。\r\n如果是，调用支持的 Realm 的 getAuthenticationInfo 方法，以提交 token。getAuthenticationInfo 方法有效地表示特定 Realm 的单个身份验证尝试。\r\n\r\n#### Authenticator\r\n\r\n如前所述，Shiro SecurityManager 实现默认使用 ModularRealmAuthenticator 实例。ModularRealmAuthenticator 既支持单个 Realm 的应用程序，也支持多个 Realm 的应用程序。\r\n\r\n在单一 Realm 应用程序中，ModularRealmAuthenticator 将直接调用单一 Realm。\r\n如果配置了两个或多个 Realms，它将使用一个 AuthenticationStrategy 实例来协调尝试的发生方式。\r\n\r\n如果你想用自定义的 Authenticator 实现配置 SecurityManager，你可以在 shiro.ini 中这样做，例如：\r\n\r\n```ini\r\n[main]\r\n...\r\nauthenticator = com.foo.bar.CustomAuthenticator\r\n\r\nsecurityManager.authenticator = $authenticator\r\n```\r\n\r\n#### AuthenticationStrategy\r\n\r\n当为应用程序配置两个或多个 realms 时，ModularRealmAuthenticator 依赖于内部的 AuthenticationStrategy 组件来确定身份验证尝试成功或失败的条件。\r\n\r\n例如，如果只有一个 Realm 成功地验证了 AuthenticationToken，而其他所有 Realm 都失败了，那么验证尝试是否被认为是成功的？或者所有的 Realms 都必须通过认证才能被认为是成功的？或者，如果一个领域验证成功，是否有必要进一步咨询其他领域？AuthenticationStrategy 基于应用程序的需求做出适当的决策。\r\n\r\nAuthenticationStrategy 是一个无状态组件，在验证尝试期间被咨询4次(这4次交互所需的任何必要状态都将作为方法参数给出)：\r\n\r\n1. 在调用任何 Realms 之前\r\n2. 在调用单个 Realm 的 getAuthenticationInfo 方法之前\r\n3. 在调用单个 Realm 的 getAuthenticationInfo 方法之后\r\n4. 在所有的 Realms 被调用之后\r\n\r\n另外，AuthenticationStrategy 负责聚合每个成功 Realm 的结果，并将它们“绑定”到单个 AuthenticationInfo 表示中。最终聚合的 AuthenticationInfo 实例是由 Authenticator 实例返回的，也是 Shiro 用来表示 Subject 的最终标识(aka Principals)的对象。\r\n\r\n如果你在应用程序中使用多个 Realm 从多个数据源获取账户数据，则 AuthenticationStrategy 最终负责应用程序所看到的 Subject 标识的最终“合并”视图。\r\n\r\nShiro 有3个具体的 AuthenticationStrategy 实现：\r\n\r\n| AuthenticationStrategy 类    | 描述                                                         |\r\n| ---------------------------- | ------------------------------------------------------------ |\r\n| AtLeastOneSuccessfulStrategy | 如果一个（或多个）Realms 认证成功，整体尝试被认为是成功的。如果没有一个认证成功，尝试失败。 |\r\n| FirstSuccessfulStrategy      | 只有从第一个成功验证的 Realm 返回的信息会被使用。所有进一步的 Realms 会被忽视。如果没有一个成功验证，尝试会失败。 |\r\n| AllSuccessfulStrategy        | 所有配置的 Realms 都必须成功地验证，整体尝试才会成功。如果任何一个没有成功验证，则尝试失败。 |\r\n\r\nModularRealmsAuthenticator 默认使用 AtLeastOneSuccessfulStrategy 实现，你可以配置不同的策略：\r\n\r\n```ini\r\n[main]\r\n...\r\nauthcStrategy = org.apache.shiro.authc.pam.FirstSuccessfulStrategy\r\n\r\nsecurityManager.authenticator.authenticationStrategy = $authcStrategy\r\n\r\n...\r\n```\r\n\r\n如果要创建自己的 AuthenticationStrategy 实现，可以用 `org.apache.shiro.authc.pam.AbstractAuthenticationStrategy` 作为起始点。\r\n\r\n#### Realm Authentication Order\r\n\r\n在 iteration 指出 ModularRealmAuthenticator 与 Realm 实例交互的顺序是非常重要的。\r\n\r\nModularRealmAuthenticator 可以访问在 SecurityManager 上配置的 Realm 实例。在执行身份验证尝试时，它将遍历该集合，并对支持提交的 AuthenticationToken 的每个 Realm 进行迭代，调用 Realm 的 getAuthenticationInfo 方法。\r\n\r\n##### 隐式顺序\r\n\r\n 使用 Shiro 的 INI 配置格式时，应该按照你想要它们处理 AuthenticationToken 的顺序来配置。例如，在 shiro.ini，Realms 会按照在 INI 文件定义的顺序被咨询。例如有一个这样的 shiro.ini：\r\n\r\n```ini\r\nblahRealm = com.company.blah.Realm\r\n...\r\nfooRealm = com.company.foo.Realm\r\n...\r\nbarRealm = com.company.another.Realm\r\n```\r\n\r\nSecurityManager 将配置为这三个 Realms，并在身份验证尝试中，按照 blahRealm, fooRealm 和 barRealm 的顺序调用。\r\n\r\n这基本与下一行定义的效果相同：\r\n\r\n```ini\r\nsecurityManager.realms = $blahRealm, $fooRealm, $barRealm\r\n```\r\n\r\n使用这种方法，你不需要设置 securityManager 的 `realms` 属性——每个 realm 定义将自动添加到 realms 属性中。\r\n\r\n##### 显式顺序\r\n\r\n如果你想要显式地定义 realms 将与之相互作用的顺序，不管它们是如何定义的，你可以将 securityManager 的 realms 属性设置为显式集合属性。例如，如果使用前面的定义，但是想要 blahRealm 被最后咨询：\r\n\r\n```ini\r\nblahRealm = com.company.blah.Realm\r\n...\r\nfooRealm = com.company.foo.Realm\r\n...\r\nbarRealm = com.company.another.Realm\r\n\r\nsecurityManager.realms = $fooRealm, $barRealm, $blahRealm\r\n...\r\n```\r\n\r\n## Authorization\r\n\r\nAuthorization 也就是众所周知的权限控制。控制谁能够访问应用的什么资源。\r\n\r\n### 权限要素\r\n\r\n授权有三个核心元素，我们引用了 Shiro：权限、角色和用户。\r\n\r\n#### Permissions\r\n\r\nApache Shiro 的权限代表了安全策略的最原子元素。它们是关于行为的基本声明，并显式地表示在应用程序中可以做的事情。一个良好的权限声明基本上描述了资源，当一个 Subject 与这些资源交互时，可能会采取什么行动。\r\n\r\n一些权限声明示例：\r\n\r\n- 打开一个文件\r\n- 查看 “/user/list\" web 页面\r\n- 打印文档\r\n- 删除 ”jsmith“ 用户\r\n\r\n大多数资源将支持典型的 CRUD (创建、读取、更新、删除)操作，但是任何对特定资源类型有意义的操作都可以。基本的想法是，最少的权限声明是基于资源和行为的。\r\n\r\n在查看权限时，最重要的事情可能是，权限语句没有谁可以执行所代表的行为。它们只是在应用程序中可以完成的语句。\r\n\r\n*提示：权限语句只反映行为(与资源类型有关的行为)。他们不能反映出谁能够履行这种行为。*\r\n\r\n定义谁(用户)被允许做什么(权限)是在某种程度上对用户分配权限的行为。这通常是由应用程序的数据模型完成的，而且可以在应用程序上有很大的不同。\r\n\r\n例如，权限可以分组在一个角色中，这个角色可以与一个或多个用户对象相关联。或者一些应用程序可以让一组用户和一个组被分配一个角色，通过传递关联将意味着该组中的所有用户都隐式地授予了该角色的权限。\r\n\r\n对于用户来说，权限是如何授予的，有许多不同之处——应用程序决定如何根据应用程序的需求来建模这一点。\r\n\r\n##### Permission Granularity\r\n\r\n前面的权限示例在资源类型（门、文件、自定义的等）上指定操作（打开、读取、删除等）。在某些情况下，它们甚至指定非常细粒度的实例级行为——例如，“删除”(行为)“用户”(资源类型)与用户名“jsmith”(实例标识符)。在 Shiro ，你有能力定义这些语句的粒度。\r\n\r\n#### Roles\r\n\r\n角色是一个被命名的实体，它通常代表一组行为或职责。这些行为转化为你可以或不能用软件应用程序做的事情。角色通常被分配给用户帐户，所以通过关联，用户可以“做”的事情归功于不同的角色。\r\n\r\n有两种类型的角色，Shiro 支持这两个概念：\r\n\r\n- 隐式角色：大多数人将角色使用为隐式构造：你的应用程序只基于角色名的行为（即权限）。在隐含的角色中，软件级别上没有什么“角色X被允许执行行为A、B和C”。行为是由一个人的名字所暗示的。\r\n- 显式角色：然而，显式角色本质上是一个命名的实际权限语句集合。在这种形式中，应用程序（和 Shiro）确切地知道它的特定角色是什么。因为它知道可以执行的确切行为，没有猜测或暗示一个特定的角色能或不能做什么。\r\n\r\n*隐式角色虽然简单而常见的方法，隐含的角色可能会强加大量的软件维护和管理问题。*\r\n\r\nShiro 团队提倡使用权限和显式角色，而不是旧的隐式方法。你将对你的应用程序的安全经验有更大的控制。\r\n\r\n#### Users\r\n\r\n用户本质上是应用程序的“谁”。然而，正如我们之前所说的，这个 Subject 确实是 Shiro 的“用户”概念。\r\n\r\n用户（Subjects）可以通过其与角色或直接权限的关联来在应用程序中执行某些操作。你的应用程序的数据模型定义了一个 Subject 是如何被允许做什么事情的或不允许。\r\n\r\n例如，在你的数据模型中，可能你有个真实的 User 类并且你直接将权限分配给 User 实例。或者，你只是将权限分配给直接的角色，然后将角色分配给用户，因此通过关联，用户将“拥有”分配给它们角色的权限。又或者你可以用一个 “组” 的概念来表示这些东西。这取决于你——使用什么对你的应用来说是有意义的。\r\n\r\n你的数据模型定义了授权将如何运行。Shiro 依赖于一个 Readlm 实现，将你的数据模型关联细节转换成一个 Shiro 理解的格式。\r\n\r\n*最终，你的领域实现是与数据源（RDBMS、LDAP 等）通信。所以你的 Realm 告诉 Shiro 是否存在角色或权限。*\r\n\r\n### Authorizing Subjects\r\n\r\n在 Shiro 中执行授权可以以 3 种方式完成：\r\n\r\n- 编程——你可以在 Java 代码中执行授权检查，如 if 和 else 块。\r\n- JDK 注解——你可以将授权注解附加到 Java 方法。\r\n- JSP/GSP 标签库——你可以根据角色和权限控制 JSP 或 GSP 页面输出。\r\n\r\n#### 编程授权\r\n\r\n可能最简单最常见的执行授权方式是直接与当前的 Subject 实例直接交互。\r\n\r\n##### 基于角色的授权\r\n\r\n如果你想通过更简单的或传统的隐式角色来控制访问，你可以执行角色检查：\r\n\r\n###### 检查角色\r\n\r\n如果你想要简单地检查当前的 Subject 是否有角色，你可以在 Subject 实例上调用变体 hasRole* 方法。\r\n\r\n例如，查看 Subject 是否有特殊（单一）的角色，你可以调用 subject.hasRole(roleName) 方法：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\nif (currentUser.hasRole(\"administrator\")) {\r\n    //show the admin button \r\n} else {\r\n    //don\'t show the button?  Grey it out? \r\n}\r\n```\r\n\r\n根据你的需要，可以调用几个面向角色的 Subject 方法：\r\n\r\n| Subject 方法                              | 描述                                                         |\r\n| ----------------------------------------- | ------------------------------------------------------------ |\r\n| hasRole(String roleName)                  | 如果 Subject 有指定的角色返回 ture，否则返回 false。         |\r\n| hasRoles(List<String> roleNames)          | 返回与方法参数中对应的 hasRole 结果数组。如果需要执行许多角色检查，就可以作为性能增强工具(例如，在定制复杂视图时)。 |\r\n| hasAllRoles(Collection<String> roleNames) | 如果 Subject 有所有指定的角色，返回 true，否则返回 false。   |\r\n\r\n###### 角色断言\r\n\r\n查看 Subject 是否有一个角色的 boolean 值的另一种选择，你可以在执行逻辑之前简单断言你期望的角色。如果 Subject 没有期望的角色，会抛出一个 AuthorizationException 。如果有期望的角色，断言会安静的执行，逻辑将也会预期地继续。\r\n\r\n例如：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\n//guarantee that the current user is a bank teller and \r\n//therefore allowed to open the account: \r\ncurrentUser.checkRole(\"bankTeller\");\r\nopenBankAccount();\r\n```\r\n\r\n这种接近 hasRole* 方法的好处是代码可以更简单一点，如果 Subject 没有符合条件也不用自己构造 AuthorizationExceptions。\r\n\r\n根据需要，可以调用几个的基于角色的 Subject 断言方法：\r\n\r\n| Subject 方法                             | 描述                                                         |\r\n| ---------------------------------------- | ------------------------------------------------------------ |\r\n| checkRole(String roleName)               | 如果 Subject 有指定的角色会安静的返回，否则抛出 AuthorizationException。 |\r\n| checkRoles(Collection<String> roleNames) | 如果 Subject 有给定的所有权限会安静的返回，否则抛出 AuthorizationException。 |\r\n| checkRoles(String...roleNames)           | 和上面的 checkRoles 方法一样。                               |\r\n\r\n##### 基于权限的授权\r\n\r\n 如上所述，在我们的角色概述中，通常更好的方式控制访问是通过基于权限授权。基于权限的授权，因为它与你的应用程序的原始功能有很强的关联，当你的功能发生变化时，基于权限的授权源代码会更改，而不是在有安全策略更改的情况下。这意味着代码受到的影响比类似的基于角色的授权代码的影响要小得多。\r\n\r\n###### 检查权限\r\n\r\n如果你想要检查 Subject 是否被授权做某事，你可以调用任意一个 isPermitted* 方法的变体。有两种主要的检查权限方法——基于对象的 Permission 实例或字符串表示 Permission。\r\n\r\n**基于对象权限检查**\r\n\r\n执行权限检查的一种可能方式是实例化 Shiro 的 `org.apache.shiro.authz.Permission` 接口的实例，并把它传入到 \\*isPermissino 方法。\r\n\r\n例如，考虑下面的情况：办公室有一个唯一标识为 laserjet4400n 的 Printer。我们的软件需要在他们按下”print“按钮前检查当前用户是否被允许在这个打印机打印文档。\r\n\r\n```java\r\nPermission printPermission = new PrinterPermission(\"laserjet4400n\", \"print\");\r\n\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\nif (currentUser.isPermitted(printPermission)) {\r\n    //show the Print button \r\n} else {\r\n    //don\'t show the button?  Grey it out?\r\n}\r\n```\r\n\r\n基于对象的权限是有用的，如果：\r\n\r\n- 你想要编译时类型安全\r\n- 你想要保证权限被正确地表示和使用\r\n- 你想要显式控制权限解析逻辑执行\r\n- 你想要保证权限准确地反映应用程序资源\r\n\r\n根据需要，你可以调用几个的面向权限对象的 Subject 方法：\r\n\r\n| Subject 方法                                 | 描述                                                         |\r\n| -------------------------------------------- | ------------------------------------------------------------ |\r\n| isPermitted(Permission p)                    | 如果 Subject 被允许执行操作或访问 Permission 实例指定的资源返回 true，否则返回false。 |\r\n| isPermitted(List<Permission> perms)          | 返回一个 isPermitted 结果数组，该数组对应于方法参数中的索引。如果需要执行许多权限检查，则可作为性能增强。 |\r\n| isPermittedAll(Collection<Permission> perms) | 如果允许 Subject 的所有指定权限，则返回 true，否则返回 false。 |\r\n\r\n**基于字符串的权限检查**\r\n\r\n虽然基于对象的权限可能很有用(编译时类型安全、有保证的行为、自定义的隐含逻辑等)，但对于许多应用程序来说，它们有时感觉有点“笨拙”。另一种方法是使用普通的 Strings 来表示权限实例。\r\n\r\n例如，基于上面的打印权限示例，我们可以将相同的检查重新表述为基于字符串的权限检查：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\nif (currentUser.isPermitted(\"printer:print:laserjet4400n\")) {\r\n    //show the Print button\r\n} else {\r\n    //don\'t show the button?  Grey it out? \r\n}\r\n```\r\n\r\nprinter(资源类型)、print(操作)和 laserjet4400n(实例id)—都用字符串表示。\r\n\r\n这个特定的示例显示了 Shiro 默认的 `org.apache.shiro.authz.permission.WildcardPermission` 实现定义的一种以冒号分隔的特殊格式，大多数人会认为它很合适。\r\n\r\n也就是说，上面的代码块(大部分)是以下内容的快捷方式：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\nPermission p = new WildcardPermission(\"printer:print:laserjet4400n\");\r\n\r\nif (currentUser.isPermitted(p) {\r\n    //show the Print button\r\n} else {\r\n    //don\'t show the button?  Grey it out?\r\n}\r\n```\r\n\r\n虽然上面的 String 默认为 WildcardPermission 格式，但实际上你可以创建自己的 String 格式，如果你喜欢的话可以使用它。\r\n\r\n基于字符串的权限是有益的，因为你不会被迫实现接口，简单的字符串通常很容易读取。\r\n缺点是你没有类型安全，如果你需要超出字符串表示的范围的更复杂的行为，你将希望基于权限接口实现自己的权限对象。在实践中，大多数 Shiro 用户选择基于 string 的方法是为了简单，但最终应用程序的需求将决定哪一种方法更好。\r\n\r\n###### 权限断言\r\n\r\n作为检查布尔值以查看 Subject 是否被允许做某事的替代方法，你可以简单地断言在逻辑执行之前它们具有预期的权限。如果 Subject 不被允许，则会抛出一个 AuthorizationException。如果它们如预期的那样被允许，断言将安静地执行，逻辑将按预期继续。\r\n\r\n例如：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\n//guarantee that the current user is permitted \r\n//to open a bank account: \r\nPermission p = new AccountPermission(\"open\");\r\ncurrentUser.checkPermission(p);\r\nopenBankAccount();\r\n```\r\n\r\n或者一样的，通过字符串权限：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\n//guarantee that the current user is permitted \r\n//to open a bank account: \r\ncurrentUser.checkPermission(\"account:open\");\r\nopenBankAccount();\r\n```\r\n\r\n其它内容和角色断言一样。\r\n\r\n#### 基于注解授权\r\n\r\n除了 Subject API 调用之外，Shiro 还提供了 Java 5+ 注解的集合，如果你更喜欢基于元的授权控制。\r\n\r\n##### 配置\r\n\r\n在使用 Java 注解前，你需要在应用中启用 AOP 支持。有很多不同的 AOP 框架，不幸的是，在应用程序中没有标准的方法来启用 AOP。\r\n\r\n对于 Spring 应用，可以看 Spring 整合部分。\r\n\r\n##### @RequiresAuthentication\r\n\r\nRequiresAuthentication 注解需要在当前会话期间验证的当前的 Subject，以访问或调用的类/实例/方法。\r\n\r\n例如：\r\n\r\n```java\r\n@RequiresAuthentication\r\npublic void updateAccount(Account userAccount) {\r\n    //this method will only be invoked by a\r\n    //Subject that is guaranteed authenticated\r\n    ...\r\n}\r\n```\r\n\r\n这基本上相当于以下的基于 Subject 的逻辑：\r\n\r\n```java\r\npublic void updateAccount(Account userAccount) {\r\n    if (!SecurityUtils.getSubject().isAuthenticated()) {\r\n        throw new AuthorizationException(...);\r\n    }\r\n\r\n    //Subject is guaranteed authenticated here\r\n    ...\r\n}\r\n```\r\n\r\n##### @RequiresGuest\r\n\r\nRequiresGuest 要求当前 Subject 为 ”guest“，也就是说，他们没有认证或被前一次会话记住。\r\n\r\n例如：\r\n\r\n```java\r\n@RequiresGuest\r\npublic void signUp(User newUser) {\r\n    //this method will only be invoked by a\r\n    //Subject that is unknown/anonymous\r\n    ...\r\n}\r\n```\r\n\r\n等价的逻辑：\r\n\r\n```java\r\npublic void signUp(User newUser) {\r\n    Subject currentUser = SecurityUtils.getSubject();\r\n    PrincipalCollection principals = currentUser.getPrincipals();\r\n    if (principals != null && !principals.isEmpty()) {\r\n        //known identity - not a guest:\r\n        throw new AuthorizationException(...);\r\n    }\r\n\r\n    //Subject is guaranteed to be a \'guest\' here\r\n    ...\r\n}\r\n```\r\n\r\n##### @RequiresPermissions\r\n\r\nRequiresPermissions 注解要求当前 Subject 有一个或多个权限来执行这个注解方法。\r\n\r\n```java\r\n@RequiresPermissions(\"account:create\")\r\npublic void createAccount(Account account) {\r\n    //this method will only be invoked by a Subject\r\n    //that is permitted to create an account\r\n    ...\r\n}\r\n```\r\n\r\n```java\r\npublic void createAccount(Account account) {\r\n    Subject currentUser = SecurityUtils.getSubject();\r\n    if (!subject.isPermitted(\"account:create\")) {\r\n        throw new AuthorizationException(...);\r\n    }\r\n\r\n    //Subject is guaranteed to be permitted here\r\n    ...\r\n}\r\n```\r\n\r\n##### @RequiresRoles\r\n\r\nRequiresRoles 注解要求当前 Subject 有所有指定的角色。如果他们没有这些角色，这个方法不会被执行，并且会抛出一个 AuthorizationException。\r\n\r\n```java\r\n@RequiresRoles(\"administrator\")\r\npublic void deleteUser(User user) {\r\n    //this method will only be invoked by an administrator\r\n    ...\r\n}\r\n```\r\n\r\n```java\r\npublic void createAccount(Account account) {\r\n    Subject currentUser = SecurityUtils.getSubject();\r\n    if (!subject.isPermitted(\"account:create\")) {\r\n        throw new AuthorizationException(...);\r\n    }\r\n\r\n    //Subject is guaranteed to be permitted here\r\n    ...\r\n}\r\n```\r\n\r\n##### @RequiresUser\r\n\r\nRequiresUser 注解要求当前 Subject 是一个应用的用户来访问注解的类、实例或调用方法。“应用用户”被定义为具有已知身份的 Subject，即由于在当前会话中进行身份验证，或者从之前的会话中被记住的“记住”服务。\r\n\r\n```java\r\n@RequiresUser\r\npublic void updateAccount(Account account) {\r\n    //this method will only be invoked by a \'user\'\r\n    //i.e. a Subject with a known identity\r\n    ...\r\n}\r\n```\r\n\r\n```java\r\npublic void updateAccount(Account account) {\r\n    Subject currentUser = SecurityUtils.getSubject();\r\n    PrincipalCollection principals = currentUser.getPrincipals();\r\n    if (principals == null || principals.isEmpty()) {\r\n        //no identity - they\'re anonymous, not allowed:\r\n        throw new AuthorizationException(...);\r\n    }\r\n\r\n    //Subject is guaranteed to have a known identity here\r\n    ...\r\n}\r\n```\r\n\r\n### Authorization Sequence\r\n\r\n我们已经从体系结构的章节中删除了以前的架构图，只剩下与授权有关的组件。每个数字表示授权操作中的一步：\r\n\r\n![ShiroAuthorizationSequence](E:\\学习笔记\\assets\\ShiroAuthorizationSequence.png)\r\n\r\n**Step 1：**应用或框架代码调用任何 Subject hasRole\\*、checkRole\\*、isPermitted\\* 或 checkPermission\\* 方法变体，传入权限或角色标识。\r\n\r\n**Step 2：**Subject 实例，典型的是 DelegatingSubject（或子类）通过调用 securityManager 相近的 hasRole\\*、checkRole\\*、isPermitted\\* 或 checkPermission\\* 方法变体委派应用的 SecurityManager。（securityManager 实现 `org.apache.shiro.authz.Authorizer` 接口）。\r\n\r\n**Step 3：**SecurityManager 作为一个基本的“伞”组件，通过调用相应的方法中继/委派给其内部 `org.apache.shiro.authz.Authorizer` 实例。authorizer 实例默认是 ModularRealmAuthorizer 实例，它支持在任何授权操作中协调一个或多个 Realm 实例。\r\n\r\n**Step 4：**每个配置的 Realm 被检查，以查看它是否实现相同的授权界面。如果是这样，这个 Realm 拥有各自的 hasRole* 、checkRole* 、isPermitted* 或 checkPermitted* 方法被调用。\r\n\r\n#### ModularRealmAuthorizer\r\n\r\n如前所述，Shiro SecurityManager 实现默认使用 ModularRealmAuthorizer 实例。ModularRealmAuthorizer 同样支持单个 Realm 的应用程序，以及具有多个 Realm  的应用。\r\n\r\n对于所有授权操作，ModularRealmAuthorizer 会迭代所有它内部的 Realm 集合并且与每一个迭代顺序交互。每个 Realm 相互作用的功能如下：\r\n\r\n1. 如果 Realm 本身实现 Authorizer 接口，他各自的 Authorizer 方法（hasRole* ...）被调用。\r\n   1. 如果 Realm 的方法结果是异常，AuthorizationException 传播到 Subject 调用者。这种短路授权过程和任何剩余的 Realm 将不会被咨询授权操作。\r\n   2. 如果 Realm 的方法是 hasRole\\* 或 isPermitted\\* 变体，返回值为布尔类型并且返回 true，true 值是立即返回的，任何剩余的 Realm 都是短路的。\r\n2. 如果 Realm 不实现 Authorizer 接口，则忽略它。\r\n\r\n##### Realm 授权顺序\r\n\r\n重要的是要指出，就像身份验证一样，ModularRealmAuthorizer 将与迭代顺序的 Realm 实例交互。\r\n\r\nModularRealmAuthorizer 可以访问在 SecurityManager 上配置的 Realm 实例。在执行授权操作时，它将遍历该集合，并对实现授权接口本身的每个 Realm 进行迭代，调用域的各自授权方法。\r\n\r\n##### 配置全局的 PermissionResolver\r\n\r\n当执行基于字符串的权限检查时，Shiro 的大部分默认 Realm 实现在执行权限含义逻辑之前首先将此字符串转换为实际的 Permission 实例。这是因为权限是基于隐含逻辑来评估的，而不是直接的平等检查。隐含逻辑在代码中更好地表示，而不是通过字符串比较。因此，大多数领域需要转换，或者将提交的权限字符串解析为相应的代表权限实例。\r\n\r\n为了帮助这种转换，Shiro 支持 PermissionResolver 的概念。大多数 Shiro Realm 实现使用PermissionResolver 支持他们实现 Authorizer 接口的基于字符串的权限方法：当其中一个方法在 Realm 上调用时，它将使用 PermissionResolver 将字符串转换为权限实例，并以这种方式执行检查。\r\n\r\n所有 Shiro Realm 实现默认为一个内部通配符解析器，它假设 Shiro 的 WildcardPermission 字符串格式。\r\n\r\n如果你想创建自己的 PermissionResolver 实现，并且你希望所有配置的 Realm 实例来使用这个解析器，你可以在全局上为所有可以配置一个的 Realm 设置 PermissionResolver 。\r\n\r\n例如，在 shiro.ini：\r\n\r\n```ini\r\nglobalPermissionResolver = com.foo.bar.authz.MyPermissionResolver\r\n...\r\nsecurityManager.authorizer.permissionResolver = $globalPermissionResolver\r\n...\r\n```\r\n\r\n如果你想配置一个全局的 PermissionResolver，每个接收它的 Realm 都必须实现 PermissionResolverAware 接口。\r\n\r\n如果你不想配置全局 PermissionResolver 或不想实现 PermissionResolverAware 接口，你可以为 Realm 明确的配置 PermissionResovler 实例。\r\n\r\n```ini\r\npermissionResolver = com.foo.bar.authz.MyPermissionResolver\r\n\r\nrealm = com.foo.bar.realm.MyCustomRealm\r\nrealm.permissionResolver = $permissionResolver\r\n...\r\n```\r\n\r\n##### 配置全局的 RolePermissionResolver\r\n\r\n和 PermissionResolver 相似。然而，键区别是，输入字符串是角色名，而不是权限字符串。\r\n\r\n当需要转换一个 role 名到 Permission 实例的时候，Realm 内部会使用 RolePermissionResolver。\r\n\r\n这是一个特别有用的特性，用于支持遗留或不灵活的数据源，这些数据源可能没有权限的概念。\r\n\r\n由于将角色名称转换为权限的概念很特殊，因此 Shiro 的默认 Realm 实现不使用它们。\r\n\r\n然而，如果你想要创建自己的 RolePermissionResolver 并且有超过一个 Realm 实现想要配置它，你可以在全局范围内为所有可以配置的 Realm 设置 RolePermissionResolver。\r\n\r\nshiro.ini：\r\n\r\n```ini\r\nglobalRolePermissionResolver = com.foo.bar.authz.MyPermissionResolver\r\n...\r\nsecurityManager.authorizer.rolePermissionResolver = $globalRolePermissionResolver\r\n...\r\n```\r\n\r\n同样，使用全局 RolePermissionResolver 的 Realm 都必须实现 RolePermissionResolverAware 接口。\r\n\r\n可以为单个 Realm 配置：\r\n\r\n```ini\r\nrolePermissionResolver = com.foo.bar.authz.MyRolePermissionResolver\r\n\r\nrealm = com.foo.bar.realm.MyCustomRealm\r\nrealm.rolePermissionResolver = $rolePermissionResolver\r\n...\r\n```\r\n\r\n#### 自定义 Authorizer\r\n\r\n你可以创建一个自定义 Authorizer，并相应地配置 SecurityManager。\r\n\r\n例如，shiro.ini：\r\n\r\n```ini\r\n[main]\r\n...\r\nauthorizer = com.foo.bar.authz.CustomAuthorizer\r\n\r\nsecurityManager.authorizer = $authorizer\r\n```\r\n\r\n### 权限\r\n\r\nShiro 将 Permission 定义为定义显式行为或动作的语句。它只是应用程序中原始功能的陈述，仅此而已。权限是安全策略中最低级别的构造，它们仅显式地定义应用程序可以做什么。\r\n\r\n权限可以分组到角色中，该角色可以与一个或多个 User 对象关联。\r\n\r\n#### Wildcard Permission\r\n\r\n为了支持易于处理但仍然可读的权限语句，Shiro 提供了强大而直观的权限语法，我们将其称为 WildcardPermission。\r\n\r\n##### 简单使用\r\n\r\n假设你希望保护对公司打印机的访问，以便一些人可以打印到特定的打印机，而另一些人可以查询队列中当前有哪些作业。\r\n\r\n一个非常简单的方法是授予用户“queryPrinter”权限。然后，你可以通过调用以下命令查看用户是否具有 queryPrinter 权限：\r\n\r\n```java\r\nsubject.isPermitted(\"queryPrinter\")\r\n```\r\n\r\n基本上等价：\r\n\r\n```java\r\nsubject.isPermitted( new WildcardPermission(\"queryPrinter\") )\r\n```\r\n\r\n你还可以使用通配符授予用户“*”权限(为该权限构造其名称)，这意味着他们拥有整个应用程序的所有权限。\r\n\r\n但是在使用这种方法时，没有办法只说用户具有“所有打印机权限”。因此，通配符权限支持多级权限。\r\n\r\n#### 多部分\r\n\r\n通配符权限支持多级或多个部分的概念。例如，你可以通过授予用户权限来重构前面的简单示例\r\n\r\n```\r\nprinter:query\r\n```\r\n\r\n本例中的冒号是一个特殊字符，用于分隔权限字符串的下一部分。\r\n\r\n在本例中，第一部分是正在操作的域(打印机)，第二部分是正在执行的操作(查询)。\r\n上述其他例子将改为：\r\n\r\n```\r\nprinter:print\r\nprinter:manage\r\n```\r\n\r\n可以使用的部件数量没有限制，因此在应用程序中使用这些部件的方式取决于你的想象。\r\n\r\n#### 多值\r\n\r\n每个部分可以包含多个值。因此，与其同时授予用户“打印机:打印”和“打印机:查询”权限，你可以简单地授予他们一个：\r\n\r\n```\r\nprinter:print,query\r\n```\r\n\r\n这使他们能够 print 和 query 打印机。既然他们都被授予了这些操作，你可以检查用户是否有能力查询打印机通过调用：\r\n\r\n```java\r\nsubject.isPermitted(\"printer:query\")\r\n```\r\n\r\n它会返回 true。\r\n\r\n#### 所有值\r\n\r\n如果想要授予用户特定部分中的所有值，该怎么办？这样做比手动列出每个值要方便得多。同样，基于通配符，我们可以这样做。如果打印机域有3种可能的操作(query、print 和 manage)，则如下：\r\n\r\n```\r\nprinter:query,print,manage\r\n```\r\n\r\n可以简单的变成：\r\n\r\n```\r\nprinter:*\r\n```\r\n\r\n然后，对\" printer:XXX \"的任何权限检查将返回true。以这种方式使用通配符比显式列出操作更好地扩展，因为如果稍后向应用程序添加新操作，则不需要更新在该部分使用通配符的权限。\r\n\r\n最后，还可以在通配符权限字符串的任何部分中使用通配符令牌。例如，如果你想在所有域(不仅仅是打印机)授予一个用户“视图”操作，你可以授予：\r\n\r\n```\r\n*:view\r\n```\r\n\r\n#### 实例级访问控制\r\n\r\n通配符权限的另一个常见用法是建模实例级访问控制列表。在这个场景中，你将使用三个部分—第一部分是域，第二部分是操作，第三部分是被操作的实例。\r\n\r\n例如：\r\n\r\n```\r\nprinter:query:lp7200\r\nprinter:print:epsoncolor\r\n```\r\n\r\n#### 缺少的部分\r\n\r\n缺失的部分意味着用户可以访问与该部分对应的所有值。换句话说，\r\n\r\n```\r\nprinter:print\r\n```\r\n\r\n等价于：\r\n\r\n```\r\nprinter:print:*\r\n```\r\n\r\n但是，你只能保留字符串末尾的部分，所以：\r\n\r\n```\r\nprinter:lp7200\r\n```\r\n\r\n不等于：\r\n\r\n```\r\nprinter:*:lp7200\r\n```\r\n\r\n#### 检查权限\r\n\r\n虽然为了方便和可伸缩性，权限分配相当多地使用通配符构造，但运行时的权限检查应该始终基于可能的最特定的权限字符串。\r\n\r\n例如，如果用户有一个 UI，他们想打印一个文档到 lp7200 打印机，你应该通过执行以下代码来检查用户是否允许这样做：\r\n\r\n```java\r\nif ( SecurityUtils.getSubject().isPermitted(\"printer:print:lp7200\") ) {\r\n    //print the document to the lp7200 printer }\r\n}\r\n```\r\n\r\n这种检查非常具体，并明确地反映了用户在那个时刻试图做什么。\r\n\r\n然而，下面的方法对于运行时检查不太理想：\r\n\r\n```java\r\nif ( SecurityUtils.getSubject().isPermitted(\"printer:print\") ) {\r\n    //print the document }\r\n}\r\n```\r\n\r\n为什么？因为第二个例子说“你必须能够打印到任何打印机，以执行下面的代码块”。但是请记住 \"printer:print\" 等价于 \"printer:print:*\" ！\r\n\r\n因此，这是一个错误的检查。如果当前用户没有能力打印到任何打印机，但他们有能力打印，比如 lp7200 和 epsoncolor 打印机，该怎么办？那么上面的第二个例子将永远不允许他们打印到 lp7200 打印机，即使他们已经被授予了这个能力！\r\n\r\n所以经验法则是在执行权限检查时尽可能使用最特定的权限字符串。当然，如果你真的只希望在允许用户打印到任何打印机(可能，但可能)的情况下执行代码块，那么上面的第二个块可能是应用程序中其他地方的有效检查。你的应用程序将决定哪些检查是有意义的，但一般来说，越具体越好。\r\n\r\n#### 隐含，不是相等\r\n\r\n为什么运行时权限检查应该尽可能地具体，而权限分配可以更一般化一些？这是因为权限检查是通过隐含逻辑计算的，而不是通过相等性检查。\r\n\r\n也就是说，如果用户被赋予 user:\\* 权限，这意味着用户可以执行 user:view 操作。字符串 \"user:\\*\"显然不等于 \"user:view\" ，但前者隐含着后者。\"user:* \"描述了由 \"user:view\" 定义的功能的超集。\r\n\r\n为了支持隐含规则，所有权限都被转换为实现 `org.apache.shiro.authz.Permission` 接口的对象实例。这样就可以在运行时执行隐含逻辑，而隐含逻辑通常比简单的字符串相等检查更复杂。本文档中描述的所有通配符行为实际上都是通过 `org.apache.shiro.authz.permission.WildcardPermission` 类实现实现的。这里有更多的通配符权限字符串，通过暗示显示访问：\r\n\r\n```\r\nuser:*\r\n```\r\n\r\n也表示删除用户的能力：\r\n\r\n```\r\nuser:delete\r\n```\r\n\r\n#### 性能考虑\r\n\r\n权限检查比简单的等号比较要复杂得多，因此必须对每个分配的权限执行运行时隐含逻辑。\r\n当使用如上所示的权限字符串时，你隐式地使用了 Shiro 的默认 WildcardPermission，它执行必要的隐含逻辑。\r\n\r\n对于 Realm 实现，Shiro 的默认行为是，对于每个权限检查，分配给该用户的所有权限(在他们的组、角色或直接分配给他们的)都需要单独检查是否有含义。Shiro 通过在第一次成功检查后立即返回来“短路”这个过程，以提高性能，但它不是一个高招。\r\n\r\n当使用适当的 CacheManager  (Shiro确实支持Realm实现)时，当用户、角色和权限被缓存到内存中时，这通常会非常快。只需知道，使用这种默认行为，随着分配给用户或其角色或组的权限数量的增加，执行检查的时间必然会增加。\r\n\r\n如果一个 Realm 实现者有一个更有效的检查权限和执行这个隐含逻辑的方法，特别是如果基于应用程序的数据模型，他们应该实现作为他们的 Realm isPermitted* 方法实现的一部分。\r\n默认的 Realm/WildcardPermission 支持覆盖了80-90%的大多数用例，但对于在运行时需要存储和/或检查大量权限的应用程序来说，它可能不是最好的解决方案。\r\n\r\n## Realms\r\n\r\nRealm 是可以访问特定于应用程序的安全数据(如用户、角色和权限)的组件。Realm 将这些特定于应用程序的数据转换为 Shiro 能够理解的格式，这样 Shiro 就可以反过来提供一个易于理解的 Subject 编程 API，不管有多少数据源存在，也不管你的数据有多特定于应用程序。\r\n\r\nRealm 通常与数据源(如关系数据库、LDAP目录、文件系统或其他类似资源)具有一对一的相关性。因此，Realm 接口的实现使用特定于数据源的 API 来发现授权数据(角色、权限等)，如 JDBC、文件 IO、Hibernate 或 JPA，或任何其他数据访问 API。\r\n\r\n因为大多数数据源通常同时存储身份验证数据(凭证，如密码)和授权数据(如角色或权限)，所以每个 Shiro Realm 都可以执行身份验证和授权操作。\r\n\r\n#### Realm 配置\r\n\r\n如果使用 Shiro 的 INI 配置，就像在 [main] 部分中定义和引用任何其他对象一样，但是它们是以两种方式之一在 securityManager 上配置的：显式或隐式。\r\n\r\n##### 显式赋值\r\n\r\n根据到目前为止对 INI 配置的了解，这是一种显式的配置方法。定义一个或多个 Realm 之后，将它们设置为 securityManager 对象上的集合属性。\r\n\r\n例如：\r\n\r\n```ini\r\nfooRealm = com.company.foo.Realm\r\nbarRealm = com.company.another.Realm\r\nbazRealm = com.company.baz.Realm\r\n\r\nsecurityManager.realms = $fooRealm, $barRealm, $bazRealm\r\n```\r\n\r\n显式分配是确定的——你可以精确地控制使用哪个领域以及它们用于身份验证和授权的顺序。\r\n\r\n##### 隐式赋值\r\n\r\n如果更改 Realm 定义的顺序，隐式赋值可能会导致意外行为。建议你避免使用这种方法，并使用具有确定性行为的显式赋值。隐式赋值很可能会在未来的 Shiro 版本中被弃用/删除。\r\n\r\n如果出于某种原因，你不想显式配置 securityManager。属性，你可以允许 Shiro 检测所有配置的域并将它们直接分配给 securityManager。\r\n\r\n使用这种方法，领域将按照定义的顺序分配给 securityManager 实例。\r\n\r\n也就是说，下面的 shiro.ini 例子：\r\n\r\n```ini\r\nblahRealm = com.company.blah.Realm\r\nfooRealm = com.company.foo.Realm\r\nbarRealm = com.company.another.Realm\r\n\r\n# no securityManager.realms assignment here\r\n```\r\n\r\n和添加下面这行的基本有相同的效果：\r\n\r\n```ini\r\nsecurityManager.realms = $blahRealm, $fooRealm, $barRealm\r\n```\r\n\r\n为了确保行为的确定性，我们建议使用显式赋值而不是隐式赋值。\r\n\r\n#### Realm 认证\r\n\r\n##### 支持 AuthenticationTokens\r\n\r\n正如在身份验证序列中所提到的，就在咨询 Realm 以执行身份验证尝试之前，调用它的 supports 方法。如果返回值为 true，才会调用它的 getAuthenticationInfo(token) 方法。\r\n\r\n通常，realm 会检查提交的 token 的类型(接口或类)，看看是否可以处理它。例如，处理生物特征数据的 Realm 可能根本不理解 UsernamePasswordTokens，在这种情况下，它会在 supports 方法返回 false。\r\n\r\n##### 处理支持的 AuthenticationToken\r\n\r\n如果 Realm 支持提交的 AuthenticationToken，Authenticator 会调用 Realm 的 getAuthenticaionInfo(token) 方法。这有效地表示了使用 Realm 的后台数据源进行身份验证的尝试。方法，按顺序：\r\n\r\n1. 检查标识主体(帐户标识信息)的 token\r\n2. 根据 principal，在数据源中查找相应的帐户数据\r\n3. 确保令牌提供的凭据（credentials）与数据存储中存储的凭据相匹配\r\n4. 如果凭证匹配，则返回一个 AuthenticationInfo 实例，该实例以 Shiro 能够理解的格式封装帐户数据\r\n5. 如果凭据不匹配，则抛出 AuthenticationException\r\n\r\n这是所有 Realm getAuthenticationInfo 实现的最高级别工作流。在此方法期间，Realms 可以自由地做任何他们想做的事情，比如在审计日志中记录尝试，更新数据记录，或者任何对数据存储的身份验证尝试有意义的事情。\r\n\r\n唯一需要的是，如果凭证与给定的主体匹配，则返回一个非空的 AuthenticationInfo 实例，该实例表示来自该数据源的 Subject 帐户信息。\r\n\r\n*直接实现“Realm”接口可能很耗时，而且容易出错。大多数人选择继承 AuthorizingRealm 抽象类，而不是从头开始。这个类实现了通用的身份验证和授权工作流，以节省你的时间和精力。*\r\n\r\n##### 凭证匹配\r\n\r\n在上述领域身份验证工作流中，realm 必须验证 Subject 提交的凭据(例如密码)必须与存储在数据存储中的凭据匹配。如果匹配，则认为身份验证成功，系统已经验证了最终用户的身份。\r\n\r\n*每个 Realm 的责任是匹配提交的凭据与存储在领域的后台数据存储，而不是“Authenticators”的责任。每个“Realm”都熟悉凭证格式和存储，可以执行详细的凭证匹配，而“Authenticator”是一个通用的工作流组件。*\r\n\r\n凭证匹配过程在所有应用程序中几乎是相同的，通常只是由于比较的数据不同而不同。为了确保这个过程是可插入的，并且在必要时是可定制的，AuthenticatingRealm 及其子类支持 CredentialsMatcher 的概念来执行凭据比较。\r\n\r\n在发现帐户数据之后，它和提交的 AuthenticationToken 将被呈现给 CredentialsMatcher，以查看提交的内容是否与存储在数据存储中的内容匹配。\r\n\r\nShiro 有 CredentialsMatcher 实现让你开箱即用，比如 SimpleCredentialsMatcher 和 HashedCredentialsMatcher 实现，但是如果你想配置一个自定义实现自定义匹配的逻辑，你可以直接这样做：\r\n\r\n```java\r\nRealm myRealm = new com.company.shiro.realm.MyRealm();\r\nCredentialsMatcher customMatcher = new com.company.shiro.realm.CustomCredentialsMatcher();\r\nmyRealm.setCredentialsMatcher(customMatcher);\r\n```\r\n\r\n或者，使用 Shiro 的 INI 配置：\r\n\r\n```ini\r\n[main]\r\n...\r\ncustomMatcher = com.company.shiro.realm.CustomCredentialsMatcher\r\nmyRealm = com.company.shiro.realm.MyRealm\r\nmyRealm.credentialsMatcher = $customMatcher\r\n...\r\n```\r\n\r\n###### 简单的相等检查\r\n\r\n所有 Shiro 开箱即用的 Realm 实现都默认使用 SimpleCredentialsMatcher。 SimpleCredentialsMatcher 对存储的帐户凭据与在 AuthenticationToken 中提交的凭据进行简单的直接相等检查。\r\n\r\n例如，如果提交了 UsernamePasswordToken, SimpleCredentialsMatcher 将验证提交的密码是否与存储在数据库中的密码完全相同。\r\n\r\nSimpleCredentialsMatcher 不仅对 string 对象执行直接相等比较。它可以使用大多数常见的字节源，如字符串、字符数组、字节数组、文件和 InputStreams。\r\n\r\n###### 哈希凭证\r\n\r\n与以原始形式存储凭证并执行原始/普通比较不同，存储终端用户凭证(例如密码)的一种更安全的方法是在将它们存储到数据存储之前先对它们进行单向散列。\r\n\r\n这确保了最终用户的凭证永远不会以原始形式存储，并且没有人可以知道原始/原始值。这是一种比纯文本或原始比较更安全的机制，所有安全意识强的应用程序都应该采用这种方法，而不是非散列存储。\r\n\r\n为了支持这些首选的加密散列策略，Shiro 提供了 HashedCredentialsMatcher 实现来在 Realm 上配置，而不是前面提到的 SimpleCredentialsMatcher。\r\n\r\n哈希凭证和盐和多重哈希迭代的好处超出了本 Realm 文档的范围，但一定要阅读 HashedCredentialsMatcher JavaDoc，其中详细涵盖了这些原则。\r\n\r\n**哈希和相应的匹配器**\r\n\r\nShiro 提供了多个 HashedCredentialsMatcher 子类实现。你必须配置 Realm 上的特定实现，以匹配用于散列用户凭证的散列算法。\r\n\r\n例如，假设你的应用程序使用用户名/密码对进行身份验证。由于上面描述的散列凭证的好处，假设你希望在创建用户帐户时使用 SHA-256 算法对用户的密码进行单向散列。你将哈希用户输入的明文密码并保存该值：\r\n\r\n```java\r\nimport org.apache.shiro.crypto.hash.Sha256Hash;\r\nimport org.apache.shiro.crypto.RandomNumberGenerator;\r\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\r\n...\r\n\r\n//We\'ll use a Random Number Generator to generate salts.  This \r\n//is much more secure than using a username as a salt or not \r\n//having a salt at all.  Shiro makes this easy. \r\n//\r\n//Note that a normal app would reference an attribute rather \r\n//than create a new RNG every time: \r\nRandomNumberGenerator rng = new SecureRandomNumberGenerator();\r\nObject salt = rng.nextBytes();\r\n\r\n//Now hash the plain-text password with the random salt and multiple \r\n//iterations and then Base64-encode the value (requires less space than Hex): \r\nString hashedPasswordBase64 = new Sha256Hash(plainTextPassword, salt, 1024).toBase64();\r\n\r\nUser user = new User(username, hashedPasswordBase64);\r\n//save the salt with the new account.  The HashedCredentialsMatcher \r\n//will need it later when handling login attempts: \r\nuser.setPasswordSalt(salt);\r\nuserDAO.create(user);\r\n```\r\n\r\n由于你使用 SHA-256 哈希你的用户密码，你需要告诉 Shiro 使用适当的 HashedCredentialsMatcher 来匹配你的哈希首选项。在本例中，我们创建了一个随机 salt，并执行 1024 次哈希迭代以获得强安全性。下面是 Shiro INI的配置：\r\n\r\n```ini\r\n[main]\r\n...\r\ncredentialsMatcher = org.apache.shiro.authc.credential.Sha256CredentialsMatcher\r\n# base64 encoding, not hex in this example:\r\ncredentialsMatcher.storedCredentialsHexEncoded = false\r\ncredentialsMatcher.hashIterations = 1024\r\n# This next property is only needed in Shiro 1.0\\.  Remove it in 1.1 and later:\r\ncredentialsMatcher.hashSalted = true\r\n\r\n...\r\nmyRealm = com.company.....\r\nmyRealm.credentialsMatcher = $credentialsMatcher\r\n...\r\n```\r\n\r\n要确保它工作的最后一件事是，你的 Realm 实现必须返回一个 SaltedAuthenticationInfo 实例而不是一个普通的 AuthenticationInfo 实例。SaltedAuthenticationInfo 接口确保你在创建用户帐户时使用的盐（例如user.setpasswordsalt(salt);）可以被 HashedCredentialsMatcher 引用。\r\n\r\nHashedCredentialsMatcher 需要盐，以便对提交的 AuthenticationToken 执行相同的散列技术，以查看令牌是否与你保存在数据存储中的内容匹配。因此，如果你用户密码加盐(你也应该!!)，确保你的 Realm 实现通过返回 SaltedAuthenticationInfo 实例表示。\r\n\r\n##### 禁用认证\r\n\r\n如果出于某种原因，你不希望一个 Realm 对数据源执行身份验证(也许是因为你只希望域执行授权)，你可以通过 Realm 的方法 supports 总是返回 false 来禁用认证。然后在身份验证的尝试中，你的 Realm 永远不会被咨询。\r\n\r\n当然，如果你想认证 Subjects，最少需要一个 Realm 启用支持 AuthenticationTokens。\r\n\r\n#### Realm 授权\r\n\r\nSecurityManager 将 Permission 或 Role 检查的任务委托给 Authorizer，默认使用 ModularRealmAuthorizer。\r\n\r\n##### 基于角色授权\r\n\r\n当其中一个重载的方法 hasRoles 或 checkRoles 方法被调用时\r\n\r\n1. Subject 委派给 SecurityManager 以识别给定的角色是否被分配\r\n2. SecurityManager 委派给 Authorizer\r\n3. 然后 Authorizer 逐个引用所有 Authorizing Reslm，直到找到指定的角色。如果没有任何 Realm 授予 Subject 给定的角色，通过返回 false 拒绝访问\r\n4. Authorizing Realm 的 ‘AuthorizationInfo getRoles()’ 方法获得分配给 Subject 的所有角色\r\n5. 如果在调用 AuthorizationInfo.getRoles 返回的角色列表中找到给定的 Role，则授予访问权限\r\n\r\n##### 基于权限授权\r\n\r\n当一个重载的方法 isPermitted() 或 checkPermission() 被调用在 Subject 上：\r\n\r\n1. Subject 委托任务向 SecurityManager 授予或拒绝 Permission\r\n\r\n2. 然后 SecurityManager 将委托给 Authorizer\r\n\r\n3. 然后 Authorizer 逐个引用所有的 Authorizer Realm，直到它被授予权限，如果没有任何 Realm 授权，则拒绝授予 Subject 权限\r\n\r\n4. Authorizing Realm 按顺序完成下面来检查是否授权 Subject：\r\n\r\n   a. 首先，它通过调用 AuthorizationInfo 上的 getObjectPermissions() 和 getStringPermissions 方法来直接标识分配给 Subject 的所有权限，并聚合结果。\r\n\r\n   b. 如果注册了 RolePermissionResolver，它将通过调用 RolePermissionResolver.resolvepermissionsinrole() 来基于分配给 Subject 的所有角色检索 Permissions。\r\n\r\n   c. 对于来自 a 和 b 的聚合的 Permissions，将调用 implies() 方法来检查这些权限是否隐含为已检查的权限。\r\n\r\n## Session Managerment\r\n\r\nShiro Session 的特点：\r\n\r\n- 基于 POJO/J2SE（IoC 友好）——Shiro中的所有内容(包括会话和会话管理的所有方面)都是基于接口的，并使用 POJO 实现。这允许你轻松地使用任何 JavaBeans 兼容的配置格式配置所有会话组件，如 JSON、YAML、Spring XML 或类似的机制。\r\n- 轻松自定义会话存储——允许你精确地定制应用程序会话数据驻留的位置—例如，文件系统、内存、网络分布式缓存、关系数据库或专有数据存储。\r\n- 独立于容器集群!——Shiro 的会话可以轻松地使用任何随时可用的网络缓存集群产品。\r\n- 异构客户端访问——与 EJB 或 Web Session 不同，Shiro Session 可以跨各种客户端技术“共享”。\r\n- 事件监听器——可以监听生命周期事件，并对它们作出反应以获得自定义的应用程序行为——例如，在用户会话到期时更新用户记录。\r\n- 主机地址保留——Shiro Sessions 保留发起会话的主机的IP地址或主机名。\r\n- 不活动/过期支持——由于不像预期的活动，会话会到期，但通过 touch() 方法可以延长它们，如果需要的话，可以让它们“alive”。\r\n- 透明的网络使用——Shiro 的 web 支持完全实现并支持 Servlet 2.5 会话规范(HttpSession 接口及其所有相关 API)。\r\n- 可以用于 SSO——因为 Shiro 会话是基于 POJO 的，所以它们很容易存储在任何数据源中，如果需要，它们可以跨应用程序“共享”。\r\n\r\n### 使用 Sessions\r\n\r\n就像 Shiro 中的几乎所有东西一样，你通过与当前正在执行的 Subject 进行交互来获得 Session：\r\n\r\n```java\r\nSubject currentUser = SecurityUtils.getSubject();\r\n\r\nSession session = currentUser.getSession();\r\nsession.setAttribute( \"someKey\", someValue);\r\n```\r\n\r\ncurrentUser.getSession() 方法是调用 currentUser.getSession(true) 的快捷方式。\r\n\r\n对于那些熟悉 HttpServletRequest API 的人，Subject.getSession(boolean create) 方法的功能与 HttpServletRequest.getSession(boolean create) 方法相同：\r\n\r\n- 如果 Subject 已经有 Session 了，布尔参数会被忽略并且立即返回这个 Session。\r\n- 如果 Subject 还没有 Session 并且 create 参数为 true，会创建并返回一个新 Session。\r\n- 如果 Subject 还没有 Session 并且 create 参数为 false，不会创建新 Session，返回 null。\r\n\r\ngetSession 调用可以在任何应用程序中工作，甚至是非 web 应用程序。\r\n\r\n一旦你获得了 Subject 的 Session，你可以用它做很多事情，比如设置或检索属性，设置它的超时等等。\r\n\r\n### SessionManager\r\n\r\n顾名思义，SessionManager 管理应用程序中所有主题的会话——创建、删除、不活动和验证等。与 Shiro 中的其他核心架构组件一样，SessionManager 是由 SecurityManager 维护的顶级组件。\r\n\r\n默认的 SecurityManager 实现默认使用 DefaultSessionManager 开箱即用。DefaultSessionManager 实现提供了应用程序所需的所有企业级会话管理特性，如会话验证、清理等。这可以在任何应用程序中使用。\r\n\r\nWeb 应用程序使用不同的 SessionManager 实现。\r\n\r\n与 SecurityManager 管理的所有其他组件一样，SessionManager 可以通过所有 Shiro 的默认 SecurityManager 实现 (getSessionManager()/setSessionManager()) 上的JavaBeans 样式的getter/setter 方法获得或设置。或者例如，如果使用 shiro.ini 配置：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionManager = com.foo.my.SessionManagerImplementation\r\nsecurityManager.sessionManager = $sessionManager\r\n```\r\n\r\n从头创建 SessionManager 是一项复杂的任务，大多数人都不愿意自己完成。\r\n\r\n#### Session 超时\r\n\r\n默认情况下，Shiro 的 SessionManager 实现默认的会话超时时间为30分钟。也就是说，如果任何创建的会话在30分钟或更长时间内保持空闲，Session 被认为是过期的，将不再被允许使用。\r\n\r\n你可以设置默认的 SessionManager 实现的 globalSessionTimeout 属性来定义所有会话的默认超时值。\r\n\r\n```ini\r\n[main]\r\n...\r\n# 3,600,000 milliseconds = 1 hour\r\nsecurityManager.sessionManager.globalSessionTimeout = 3600000\r\n```\r\n\r\n**每个 Session 超时**\r\n\r\n前面的例子默认为所有创建的 Session 设置。你可以通过设置 timeout 属性控制每个 session 超时值。单位也是为毫秒。\r\n\r\n#### Session 监听器\r\n\r\nShiro 支持 SessionListener 的概念，允许你在重要会话事件发生时作出反应。你可以实现 SessionListener 接口(或扩展 SessionListenerAdapter)，并相应地对会话操作作出反应。\r\n\r\n由于默认的 SessionManager sessionListeners 属性是一个集合，你可以像 shiro.ini 中的任何其他集合一样，使用一个或多个监听器实现来配置 SessionManager：\r\n\r\n```ini\r\n[main]\r\n...\r\naSessionListener = com.foo.my.SessionListener\r\nanotherSessionListener = com.foo.my.OtherSessionListener\r\n\r\nsecurityManager.sessionManager.sessionListeners = $aSessionListener, $anotherSessionListener, etc.\r\n```\r\n\r\n当任何 Session 的事件发生时，SessionListeners 都会被通知——而不仅仅是特定的会话。\r\n\r\n#### Session 存储\r\n\r\n每当创建或更新会话时，它的数据都需要持久化到存储位置，以便应用程序在以后可以访问它。类似地，当会话无效且使用时间较长时，需要将其从存储中删除，以免耗尽会话数据存储空间。SessionManager 实现将这些创建/读取/更新/删除(CRUD)操作委托给内部组件 SessionDAO，它反映了数据访问对象(DAO)的设计模式。\r\n\r\nSessionDAO 的强大之处在于，你可以实现这个接口来与你希望的任何数据存储进行通信。这意味着你的会话数据可以驻留在内存中、文件系统中、关系数据库或 NoSQL 数据存储中，或你需要的任何其他位置。你可以控制持久性行为。\r\n\r\n你可以将任何 SessionDAO 实现配置为默认 SessionManager 实例的属性。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionDAO = com.foo.my.SessionDAO\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n```\r\n\r\n然而，正如你所料，Shiro 已经有了一些良好的 SessionDAO 实现，你可以使用它或子类来满足你自己的需求。\r\n\r\n上面的 securityManager.sessionManager.sessionDAO = $sessionDAO 赋值仅在使用 Shiro 本地会话管理器时有效。Web 应用程序默认情况下不使用本机会话管理器，而是保留 Servlet 容器的默认会话管理器，该会话管理器不支持 SessionDAO。如果你想在基于 web 的应用程序中启用 SessionDAO 来定制会话存储或会话集群，你必须首先配置本机 web 会话管理器。例如：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionManager = org.apache.shiro.web.session.mgt.DefaultWebSessionManager\r\nsecurityManager.sessionManager = $sessionManager\r\n\r\n# Configure a SessionDAO and then set it:\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n```\r\n\r\nShiro 的默认配置本机 SessionManager 使用仅在内存中的会话存储。这不适用于大多数生产应用程序。 大多数生产应用程序要么想配置所提供的 EHCache 支持(见下面)，要么想提供自己的 SessionDAO 实现。请注意，web 应用程序默认使用基于 servlet 容器的 SessionManager，不会出现这个问题。这只是在使用 Shiro 原生 SessionManager 时的问题。\r\n\r\n#### EHCache SessionDAO\r\n\r\n默认情况下 EHCache 是不启用的，但如果你不打算实现自己的 SessionDAO，强烈建议你启用 Shiro 的 SessionManagement 的 EHCache 支持。EHCache SessionDAO 将会话存储在内存中，并支持在内存受限时溢出到磁盘。这对于生产应用程序来说是非常必要的，以确保你不会在运行时随机“丢失”会话。\r\n\r\n如果你不是在写一个自定义的 SessionDAO，那么一定要在 Shiro 配置中启用 EHCache。除了会话，EHCache 还可以缓存身份验证和授权数据。\r\n\r\n为会话启用 EHCache 非常简单。首先，确保类路径中有 `shiro-ehcache-<version>.jar` 文件。\r\n\r\n在类路径中，第一个 shiro.ini 示例向你展示了如何使用 EHCache 来满足 Shiro 所有的缓存需求(不仅仅是会话支持)：\r\n\r\n```ini\r\n[main]\r\n\r\nsessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n\r\ncacheManager = org.apache.shiro.cache.ehcache.EhCacheManager\r\nsecurityManager.cacheManager = $cacheManager\r\n```\r\n\r\n最后一行，`securityManager.cacheManager = $cacheManager` ，配置一个 cacheManager 来满足 Shiro 的所有需求。这个 CacheManager 实例将自动向下传播到 SessionDAO (根据实现 CacheManagerAware 接口的 EnterpriseCacheSessionDAO 的性质)。\r\n\r\n不要忘记，在使用 Shiro 原生 SessionManager 实现时，分配 SessionDAO 是一个特性。Web 应用程序默认使用基于 Servlet 容器的 SessionManager，它不支持 SessionDAO。如果你想在 web 应用程序中使用基于 EHCache 的会话存储，请按照上面的解释配置一个本机 web SessionManager。\r\n\r\n##### EHCache Session Cache 配置\r\n\r\n默认情况下，EhCacheManager 使用一个特定于 Shiro 的 ehcache.xml 文件来设置会话缓存区域和必要的设置，以确保会话被正确地存储和检索。\r\n\r\n然而，如果你想改变缓存设置，或者配置你自己的 ehcache .xml 或 EHCache net.sf.ehcache.CacheManager 实例，你需要配置缓存区域以确保会话被正确处理。\r\n\r\n如果你查看默认的 ehcache.xml 文件，你会看到以下 shiro-activeSessionCache 缓存配置：\r\n\r\n```xml\r\n<cache name=\"shiro-activeSessionCache\"\r\n       maxElementsInMemory=\"10000\"\r\n       overflowToDisk=\"true\"\r\n       eternal=\"true\"\r\n       timeToLiveSeconds=\"0\"\r\n       timeToIdleSeconds=\"0\"\r\n       diskPersistent=\"true\"\r\n       diskExpiryThreadIntervalSeconds=\"600\"/>\r\n```\r\n\r\n如果你希望使用自己的 ehcache.xml 文件，请确保你已经为 Shiro 的需求定义了一个类似的缓存条目。最有可能的情况是，你可以更改 maxElementsInMemory 属性值来满足你的需要。然而，在你自己的配置中至少存在以下两个属性(且不更改)是非常重要的：\r\n\r\n- overflowToDisk=\"true\"- 这可以确保如果进程内存耗尽，会话不会丢失，并且可以序列化到磁盘上\r\n- eternal=\"true\"- 确保缓存条目(会话实例)不会过期或被缓存自动删除。这是必要的，因为 Shiro 是基于预定的进程来执行自己的验证的。如果我们关闭此功能，缓存可能会在 Shiro 不知情的情况下驱逐 Sessions，这可能会导致问题。\r\n\r\n##### EHCache Session Cache 名称\r\n\r\n默认情况下，EnterpriseCacheSessionDAO 会向 CacheManager 请求一个名为 “shiro-activeSessionCache” 的缓存。这个缓存名称/区域应该在 ehcache.xml 中配置，如上所述。\r\n\r\n如果你想使用不同的名称而不是默认的名称，你可以在 EnterpriseCacheSessionDAO 上配置该名称，例如：\r\n\r\n```ini\r\n...\r\nsessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO\r\nsessionDAO.activeSessionsCacheName = myname\r\n...\r\n```\r\n\r\n只要确保在 ehcache.xml 中有一个对应的条目匹配那个名字，并且你已经配置了overflowToDisk=\"true\" 和 eternal=\"true\"，就像上面提到的那样。\r\n\r\n#### 自定义 Session ID\r\n\r\nShiro 的 SessionDAO 实现使用内部 SessionIdGenerator 组件在每次创建新会话时生成一个新的 Session ID。生成ID，分配给新创建的 Session 实例，然后通过 SessionDAO 保存 Session。\r\n\r\n默认的 SessionIdGenerator 是 JavaUuidSessionIdGenerator，它基于 Java UUID生成String ID。此实现适用于所有生产环境。\r\n\r\n如果这不能满足你的需要，你可以实现 SessionIdGenerator 接口，并在 Shiro 的 SessionDAO 实例上配置实现。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionIdGenerator = com.my.session.SessionIdGenerator\r\nsecurityManager.sessionManager.sessionDAO.sessionIdGenerator = $sessionIdGenerator\r\n```\r\n\r\n#### Session 验证和调度\r\n\r\n必须验证会话,因此可以从会话数据存储中删除任何无效的(过期或停止的)会话。这可以确保数据存储不能在不使用的会话时间内填满。\r\n\r\n由于性能原因，会话只验证它们在被访问的时候被停止或过期(即 subject.getSession())。这意味着如果没有额外的定期验证，会话孤儿将开始填充会话数据存储。\r\n\r\n一个常见的例子是 web 浏览器场景：假设一个用户登录到一个 web 应用程序，创建了一个会话来保存数据(身份验证状态、购物车等)。如果用户没有注销并在应用程序不知道的情况下关闭浏览器，那么他们的会话本质上就是“闲置”(孤立)在会话数据存储中。SessionManager 无法检测到用户不再使用他们的浏览器，并且会话再也不会被访问(它是孤立的)。\r\n\r\n如果不定期清除遗弃的会话，它们将填满会话数据存储(这将很糟糕)。因此，为了防止没用会话的堆积，SessionManager 实现支持 SessionValidationScheduler 的概念。SessionValidationScheduler 负责定期验证会话，以确保在必要时清理会话。\r\n\r\n##### 默认SessionValidationScheduler\r\n\r\n在所有环境中，默认的 SessionValidationScheduler 是 ExecutorServiceSessionValidationScheduler，它使用 JDK 的 ScheduledExecutorService 来控制验证发生的频率。\r\n\r\n默认情况下，该实现将每小时执行一次验证。你可以通过指定一个 ExecutorServiceSessionValidationScheduler 的新实例并指定一个不同的间隔(以毫秒为单位)来改变验证发生的速率：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionValidationScheduler = org.apache.shiro.session.mgt.ExecutorServiceSessionValidationScheduler\r\n# Default is 3,600,000 millis = 1 hour:\r\nsessionValidationScheduler.interval = 3600000\r\n\r\nsecurityManager.sessionManager.sessionValidationScheduler = $sessionValidationScheduler\r\n```\r\n\r\n##### 自定义 SessionValidationScheduler\r\n\r\n如果希望提供自定义 SessionValidationScheduler 实现，可以将其指定为默认 SessionManager 实例的属性。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionValidationScheduler = com.foo.my.SessionValidationScheduler\r\nsecurityManager.sessionManager.sessionValidationScheduler = $sessionValidationScheduler\r\n```\r\n\r\n##### 禁用 Session Validation\r\n\r\n你可能正在使用企业缓存，并依赖缓存的生存时间设置来自动删除旧会话，或其它情况。在这些情况下，你可以关闭会话验证调度：\r\n\r\n```ini\r\n[main]\r\n...\r\nsecurityManager.sessionManager.sessionValidationSchedulerEnabled = false\r\n```\r\n\r\n从会话数据存储中检索会话时，仍然会对它们进行验证，但这将禁用 Shiro 的周期性验证。\r\n\r\n如果关闭 Shiro 的会话验证调度程序，则**必须**通过其他机制( cron job 等)执行周期性的会话验证。这是保证 Session 残留不会填满数据存储的唯一方法。\r\n\r\n##### 删除无效的 Session\r\n\r\n默认情况下，当 Shiro 检测到无效会话时，它会尝试通过 SessionDAO.delete(session) 方法将其从底层会话数据存储中删除。对于大多数应用程序来说，这是一种良好的实践，可以确保会话数据存储空间不会耗尽。\r\n\r\n但是，有些应用程序可能不希望 Shiro 自动删除会话。例如，如果应用程序提供了支持可查询数据存储的 SessionDAO，那么应用程序团队可能希望旧的或无效的会话在一段时间内可用。\r\n这将允许团队对数据存储运行查询，以查看例如，用户在上周创建了多少会话，或用户会话的平均持续时间，或类似的报告类型查询。\r\n\r\n在这些场景中，你可以完全关闭无效的会话删除。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nsecurityManager.sessionManager.deleteInvalidSessions = false\r\n```\r\n\r\n但是要小心！如果关闭此功能，则需要确保会话数据存储不会耗尽其空间。你必须自己从数据存储中删除无效的会话！\r\n\r\n还要注意，即使你阻止 Shiro 删除无效会话，你仍然应该以某种方式启用会话验证——可以通过 Shiro 现有的验证机制，也可以通过你自己提供的自定义机制。验证机制将更新你的会话记录，以反映无效状态(例如，何时失效，何时最后一次访问，等等)，即使你将在其他时间手动删除它们。\r\n\r\n要注意，禁用会话删除与禁用会话验证调度是不同的。你应该始终使用会话验证调度机制——无论是由 Shiro 直接支持的还是你自己支持的。\r\n\r\n### Session 集群\r\n\r\nApache Shiro 会话功能的一个非常令人兴奋的地方是，你可以在本地集群 Subject 会话，而不必再担心如何基于容器环境集群会话。也就是说，如果你使用 Shiro 的本机会话并配置会话集群，那么你可以在开发中部署到 Jetty 或 Tomcat，在生产中部署到 JBoss 或 Geronimo，或者部署到任何其他环境中—而不必担心特定于容器/环境的集群设置或配置。在 Shiro 中配置一次会话集群，无论你的部署环境如何，它都可以工作。\r\n\r\n由于 Shiro 采用基于 POJO 的 n 层架构，因此启用会话集群就像在会话持久性级别启用集群机制一样简单。也就是说，如果你配置了一个支持集群的 SessionDAO，那么这个 DAO 可以与集群机制交互，而 Shiro 的 SessionManager 永远不需要知道集群问题。\r\n\r\n**分布式缓存**\r\n\r\n分布式缓存如 Ehcache+TerraCotta、GigaSpaces Oracle Coherence 和 Memcached(以及许多其他的)已经解决了持久化分布式数据的问题。因此，在 Shiro 中启用 Session 集群就像配置 Shiro 使用分布式缓存一样简单。\r\n\r\n请注意，当启用分布式/企业缓存作为会话集群数据存储时，必须满足以下两种情况之一：\r\n\r\n- 分布式缓存有足够的集群范围内的内存来保留 \\_all\\_ 活动/当前会话\r\n- 如果分布式缓存没有足够的集群范围内存来保留所有活动会话，那么它必须支持磁盘溢出，以便会话不会丢失。\r\n\r\n如果缓存无法支持这两种情况中的任何一种，将导致会话随机丢失，这可能会让最终用户体验不好。\r\n\r\n#### EnterpriseCacheSessionDAO\r\n\r\nShiro 已经提供了一个 SessionDAO 实现，它将数据持久化到企业/分布式缓存中。\r\nEnterpriseCacheSessionDAO 希望在其上配置一个 Shiro Cache 或 CacheManager，这样它就可以利用缓存机制。\r\n\r\n例如，在 shiro.ini：\r\n\r\n```ini\r\n#This implementation would use your preferred distributed caching product\'s APIs:\r\nactiveSessionsCache = my.org.apache.shiro.cache.CacheImplementation\r\n\r\nsessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO\r\nsessionDAO.activeSessionsCache = $activeSessionsCache\r\n\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n```\r\n\r\n尽管你可以直接向 SessionDAO 中注入一个缓存实例，但通常更常见的是配置一个常用的 CacheManager 来使用 Shiro 的所有缓存需求(会话以及身份验证和授权数据)。在本例中，没有直接配置 Cache 实例，而是在 CacheManager 告诉 EnterpriseCacheSessionDAO 中缓存的名称的名称，该缓存应该用于存储活动会话。\r\n\r\n例如：\r\n\r\n```ini\r\n# This implementation would use your caching product\'s APIs:\r\ncacheManager = my.org.apache.shiro.cache.CacheManagerImplementation\r\n\r\n# Now configure the EnterpriseCacheSessionDAO and tell it what\r\n# cache in the CacheManager should be used to store active sessions:\r\nsessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO\r\n# This is the default value.  Change it if your CacheManager configured a different name:\r\nsessionDAO.activeSessionsCacheName = shiro-activeSessionsCache\r\n# Now have the native SessionManager use that DAO:\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n\r\n# Configure the above CacheManager on Shiro\'s SecurityManager\r\n# to use it for all of Shiro\'s caching needs:\r\nsecurityManager.cacheManager = $cacheManager\r\n```\r\n\r\n关于这个配置的有趣的事情是，在配置中没有任何地方可以告诉 sessionDAO 实例使用 Cache 或 CacheManager ！那么，sessionDAO 如何使用分布式缓存呢？\r\n\r\n当 Shiro 初始化 SecurityManager 时，它将检查 SessionDAO 是否实现 CacheManagerAware 接口。如果实现了，它将自动提供任何可用的全局配置的 CacheManager。\r\n\r\n所以当 Shiro 评估 `securityManager.cacheManager = $cacheManager` 这行时，它会发现 EnterpriseCacheSessionDAO 实现 CacheManagerAware 并且调用 setCacheManager 方法，用你配置的 CacheManager 作为方法参数。\r\n\r\n然后在运行时，当 EnterpriseCacheSessionDAO 需要 activeSessionsCache 时，它将请求 CacheManager 实例返回它，使用 activeSessionsCacheName 作为查找键获取缓 Cache 实例。 Cache 实例(由分布式/企业缓存产品的API支持)将用于存储和检索所有 SessionDAO  CRUD 操作的会话。\r\n\r\n#### Ehcahe + Terracotta\r\n\r\n人们在使用 Shiro 时已经成功使用的一种分布式缓存解决方案是 Ehcache + Terracotta 配对。\r\n\r\n一旦 Terracotta 集群与 Ehcache 一起工作，特定于 Shiro 的部分就非常简单了。阅读并遵循 Ehcache SessionDAO 文档，但是我们需要做一些修改。\r\n\r\n之前引用的 Ehcache Session Cache 配置将不起作用，需要 Terracotta 特有的配置。下面是一个示例配置，它已经经过了正确工作的测试。将其内容保存在一个文件中，并将其保存在一个 ehcache.xml 文件中：\r\n\r\n```xml\r\n<ehcache>\r\n    <terracottaConfig url=\"localhost:9510\"/>\r\n    <diskStore path=\"java.io.tmpdir/shiro-ehcache\"/>\r\n    <defaultCache\r\n            maxElementsInMemory=\"10000\"\r\n            eternal=\"false\"\r\n            timeToIdleSeconds=\"120\"\r\n            timeToLiveSeconds=\"120\"\r\n            overflowToDisk=\"false\"\r\n            diskPersistent=\"false\"\r\n            diskExpiryThreadIntervalSeconds=\"120\">\r\n        <terracotta/>\r\n    </defaultCache>\r\n    <cache name=\"shiro-activeSessionCache\"\r\n           maxElementsInMemory=\"10000\"\r\n           eternal=\"true\"\r\n           timeToLiveSeconds=\"0\"\r\n           timeToIdleSeconds=\"0\"\r\n           diskPersistent=\"false\"\r\n           overflowToDisk=\"false\"\r\n           diskExpiryThreadIntervalSeconds=\"600\">\r\n        <terracotta/>\r\n    </cache>\r\n    <!-- Add more cache entries as desired, for example,\r\n         Realm authc/authz caching: -->\r\n</ehcache>\r\n```\r\n\r\n当然，你需要更改 `<terracoottaconfig url=\"localhost:9510\"/>` 条目，以引用 Terracotta 服务器阵列的适当主机/端口。还要注意，与前面的配置不同，ehcache-activeSessionCache 元素**不会**将 diskPersistent 或 overflowToDisk 属性设置为true。它们都应该是false，因为集群配置中不支持 true 值。\r\n\r\n在保存了这个 ehcache.xml 文件之后，我们需要在 Shiro 的配置中引用它。假设你已经在类路径的根目录下实现了 Terracotta 特有的 Ehcache .xml 文件的访问，下面是 Shiro 的最终配置，使 Terracotta+Ehcache 集群能够满足 Shiro 的所有需求(包括Sessions)：\r\n\r\n```ini\r\nsessionDAO = org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO\r\n# This name matches a cache name in ehcache.xml:\r\nsessionDAO.activeSessionsCacheName = shiro-activeSessionsCache\r\nsecurityManager.sessionManager.sessionDAO = $sessionDAO\r\n\r\n# Configure The EhCacheManager:\r\ncacheManager = org.apache.shiro.cache.ehcache.EhCacheManager\r\ncacheManager.cacheManagerConfigFile = classpath:ehcache.xml\r\n\r\n# Configure the above CacheManager on Shiro\'s SecurityManager\r\n# to use it for all of Shiro\'s caching needs:\r\nsecurityManager.cacheManager = $cacheManager\r\n```\r\n\r\n记住，**顺序很重要**。通过在 securityManager 上最后配置 cacheManager，我们确保了 cacheManager 可以传播到所有之前配置的 CacheManagerAware 组件(如EnterpriseCachingSessionDAO)。\r\n\r\n### Session 和 Subject 状态\r\n\r\n#### 有状态应用(允许会话)\r\n\r\n默认情况下，Shiro 的 SecurityManager 实现将使用 Subject 的会话作为策略来存储 Subject 的身份(PrincipalCollection)和身份验证状态(Subject.isAuthenticated())以供继续引用。这通常发生在 Subject 登录后，或当 Subject 的身份被发现通过 RememberMe 服务。\r\n\r\n这种默认方法有几个好处：\r\n\r\n- 服务请求、调用或消息的任何应用程序都可以将会话 ID 与请求/调用/消息有效负载关联起来，这就是 Shiro 将用户与入站请求关联起来所需要的全部内容。例如，如果使用 Subject.Builder，这是获取相关主题所需要的所有内容：\r\n\r\n  ```java\r\n  Serializable sessionId = //get from the inbound request or remote method invocation payload Subject requestSubject = new Subject.Builder().sessionId(sessionId).buildSubject();\r\n  ```\r\n\r\n  这对于大多数 web 应用程序以及任何编写远程通信或消息传递框架的人来说都是非常方便的。(这实际上是 Shiro 的 web 支持如何在自己的框架代码中将 Subject 与 ServletRequests 关联起来的)。\r\n\r\n- 在初始请求中找到的任何“RememberMe”身份都可以在第一次访问时持久化到会话中。这确保了 Subject 的记忆标识可以跨请求保存，而不需要对每个请求进行反序列化和解密。例如，在一个 web 应用程序中，如果在会话中已经知道身份，就没有必要在每次请求时读取加密的 RememberMe cookie。这可以很好地提高性能。\r\n\r\n虽然上面的默认策略对于大多数应用程序来说是很好的(而且通常是可取的)，但是对于尽可能地尝试无状态的应用程序来说，这就不可取了。许多无状态架构要求请求之间不能存在持久状态，在这种情况下不允许使用 Session (Session本身就代表持久状态)。\r\n\r\n但是这个要求的代价是方便的——Subject 状态不能跨请求保留。这意味着具有此需求的应用程序必须确保每个请求都能以其他方式表示 Subject 状态。\r\n\r\n这几乎总是通过对应用程序处理的每个请求/调用/消息进行身份验证来实现。例如，大多数无状态 web 应用程序通常通过强制执行 HTTP 基本身份验证来支持这一点，允许浏览器代表终端用户验证每个请求。远程或消息传递框架必须确保将 Subject 主体和凭据附加到每个调用或消息有效负载，通常由框架代码执行。\r\n\r\n#### 禁用 Subject 状态 Session 存储\r\n\r\n从 Shiro 1.2 及后续版本开始，希望禁用 Shiro 将 Subject 状态持久化到会话的内部实现策略的应用程序可以通过以下操作在所有 Subject 上完全禁用该策略：\r\n\r\n在 shiro.ini 配置下面的属性：\r\n\r\n```ini\r\n[main]\r\n...\r\nsecurityManager.subjectDAO.sessionStorageEvaluator.sessionStorageEnabled = false\r\n...\r\n```\r\n\r\n这将防止 Shiro 使用 Subject 的会话跨所有 Subject 的请求/调用/消息存储 Subject 的状态。只要确保对每个请求进行身份验证，这样 Shiro 就会知道任何给定请求/调用/消息的 Subject 是谁。\r\n\r\n这将禁止 Shiro 自己的实现使用 Sessions 作为存储策略。它没有完全禁用 Sessions。如果你自己的任何代码显式调用 subject.getSession() 或 subject.getSession(true)，会话仍然会被创建。\r\n\r\n#### 混合的方式\r\n\r\n但是如果你想要一个混合的方法呢？如果一些 Subject 应该有 Session 而另一些不应该有怎么办？这种混合方法对许多应用程序都是有益的。例如：\r\n\r\n- 也许人类 Subject (例如web浏览器用户)应该能够使用 Sessions 来获得上述好处。\r\n- 也许非人类 Subject (例如API客户端或第三方应用程序)不应该创建会话，因为他们与软件的交互可能是间歇性的和/或不稳定的。\r\n- 也许某种类型的所有 Subject 或从某个位置访问系统的所有 Subject 都应该在会话中持久化状态，但其他所有 Subject 都不应该。\r\n\r\n如果需要这种混合方法，可以实现 SessionStorageEvaluator。\r\n\r\n##### SessionStorageEvaluator\r\n\r\n如果你想要精确地控制哪些 Subject 可能将其状态持久化到会话中，你可以实现`org.apache.shiro.mgt.SessionStorageEvaluator` 接口，并确切地告诉 Shiro 哪些 Subject 应该支持会话存储。\r\n\r\n这个接口只有一个方法：\r\n\r\n```java\r\npublic interface SessionStorageEvaluator {\r\n\r\n    public boolean isSessionStorageEnabled(Subject subject);\r\n\r\n}\r\n```\r\n\r\n###### Subject 检查\r\n\r\n在实现 isSessionStorageEnabled(subject) 接口方法时，你总是可以查看 Subject，并获得做出决定所需的任何内容。当然，所有期望的 Subject 方法都可以使用(getPrincipals()等)，但是特定于环境的 Subject 实例也很有价值。\r\n\r\n例如，在 web 应用程序中，如果必须基于当前 ServletRequest 中的数据做出决策，你可以获得请求或响应，因为运行时的 Subject 实例实际上是一个 WebSubject 实例：\r\n\r\n```java\r\npublic boolean isSessionStorageEnabled(Subject subject) {\r\n    boolean enabled = false;\r\n    if (WebUtils.isWeb(Subject)) {\r\n        HttpServletRequest request = WebUtils.getHttpRequest(subject);\r\n        //set \'enabled\' based on the current request.\r\n    } else {\r\n        //not a web request - maybe a RMI or daemon invocation?\r\n        //set \'enabled\' another way...\r\n    }\r\n\r\n    return enabled;\r\n}\r\n```\r\n\r\n##### 配置\r\n\r\n在你实现了 SessionStorageEvaluator 接口之后，你可以在 shiro.ini 中配置它：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionStorageEvaluator = com.mycompany.shiro.subject.mgt.MySessionStorageEvaluator\r\nsecurityManager.subjectDAO.sessionStorageEvaluator = $sessionStorageEvaluator\r\n\r\n...\r\n```\r\n\r\n#### Web Application\r\n\r\n通常，web 应用程序希望简单地在每个请求的基础上启用或禁用会话创建，而不管哪个 Subject 正在执行请求。这通常用于支持 REST 和 Messaging/RMI 体系结构。例如，可能允许普通终端用户(使用浏览器的人)创建和使用会话，但远程 API 客户机使用 REST 或 SOAP，根本不应该有会话(因为它们对每个请求进行身份验证，这在REST/SOAP体系结构中很常见)。\r\n\r\n为了支持这种混合/每个请求功能，已经将一个 noSessionCreation 过滤器添加到 Shiro的“池”中，用于 web 应用程序的默认筛选器。这个过滤器将防止在请求中创建新的会话，以保证无状态。在 shiro.ini [urls] 部分，通常在所有其他人面前定义这个过滤器，以确保会话永远不会被使用。\r\n\r\n```ini\r\n[urls]\r\n...\r\n/rest/** = noSessionCreation, authcBasic, ...\r\n```\r\n\r\n该过滤器允许在任何现有会话中使用会话使用，但不允许在过滤请求期间创建新的会话。也就是说，任何在下面四种方法调用\r\n\r\n在还没有 Session 的请求或 Subject 调用下面四种方法之一，任何一种方法都将自动触发 DisabledSessionException：\r\n\r\n- `httpServletRequest.getSession()`\r\n- `httpServletRequest.getSession(true)`\r\n- `subject.getSession()`\r\n- `subject.getSession(true)`\r\n\r\n如果一个 Subject 在访问 noSessionCreation-protected-URL 之前已经有一个会话，那么以上4个调用仍将像预期的那样工作。\r\n\r\n最后，在所有情况下，以下调用将永远被允许使用：\r\n\r\n- `httpServletRequest.getSession(false)`\r\n- `subject.getSession(false)`\r\n\r\n# Web Application\r\n\r\n## 配置\r\n\r\n将 Shiro 集成到任何 web 应用程序中最简单的方法是在 web.xml 中配置 Servlet ContextListener 和 Filter，以理解如何读取 Shiro 的 INI 配置。INI 配置格式本身的大部分定义在配置页面的 INI 部分，但我们将涵盖一些额外的特定于 web 的部分在这里。\r\n\r\nSpring Framework 用户不会执行这个设置。如果你使用 Spring，你会想要阅读 Spring 特定的 web 配置。\r\n\r\n### web.xml\r\n\r\n#### Shiro 1.2 及以后版本\r\n\r\n在 Shiro 1.2 及以后版本中，标准的 web 应用程序通过在 web.xml 中添加以下 XML 块来初始化 Shiro：\r\n\r\n```xml\r\n<listener>\r\n    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>\r\n</listener>\r\n\r\n...\r\n\r\n<filter>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>\r\n</filter>\r\n\r\n<filter-mapping>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n    <dispatcher>REQUEST</dispatcher>\r\n    <dispatcher>FORWARD</dispatcher>\r\n    <dispatcher>INCLUDE</dispatcher>\r\n    <dispatcher>ERROR</dispatcher>\r\n</filter-mapping>\r\n```\r\n\r\n这假设 Shiro INI 配置文件位于以下两个位置之一，使用最先找到的位置：\r\n\r\n1. /WEB-INF/shiro.ini\r\n2. shiro.ini 文件在类路径根目录\r\n\r\n下面是上面的配置的作用：\r\n\r\n- EnvironmentLoaderListener 初始化 Shiro WebEnvironment 实例(包含 Shiro 需要操作的所有东西，包括 SecurityManager)，并使其在 ServletContext 中可访问。如果你需要在任何时候获得这个 WebEnvironment 实例，你可以调用WebUtils.getRequiredWebEnvironment(servletContext)。\r\n- ShiroFilter 将使用此 WebEnvironment 对任何过滤的请求执行所有必要的安全操作。\r\n- 最后，过滤器映射定义确保所有请求都被 ShiroFilter 过滤，大多数 web 应用都推荐 ShiroFilter，以确保任何请求都能得到保护。\r\n\r\n通常需要在任何其他“filter-mapping”声明之前定义“ShiroFilter filter-mapping”，以确保 Shiro 也能在这些过滤器中发挥作用。\r\n\r\nshiro 过滤器是一个标准的 servlet 过滤器，根据 servlet 规范，其默认编码为 ISO-8859-1。但是，客户端可以使用 Content-Type 报头的 charset 属性选择使用不同的编码发送身份验证数据。\r\n\r\n##### 自定义 WebEnvironment 类\r\n\r\n默认情况下，EnvironmentLoaderListener 将创建一个 IniWebEnvironment 实例，该实例假设 Shiro 基于 ini 的配置。如果你愿意，你可以通过在 web.xml 中指定 ServletContext context-param 来指定一个自定义 WebEnvironment 实例：\r\n\r\n```xml\r\n<context-param>\r\n    <param-name>shiroEnvironmentClass</param-name>\r\n    <param-value>com.foo.bar.shiro.MyWebEnvironment</param-value>\r\n</context-param>\r\n```\r\n\r\n这允许你自定义如何解析配置格式并将其表示为 WebEnvironment 实例。你可以子类化现有的 IniWebEnvironment 来定制行为，或者完全支持不同的配置格式。例如，如果有人想用 XML 而不是 INI 配置 Shiro，他们可以创建一个基于 XML 的实现，例如com.foo.bar.shiro.XmlWebEnvironment。\r\n\r\n##### 自定义配置路径\r\n\r\n如果你想把你的配置放在另一个位置，你可以在 web.xml 中使用另一个上下文参数指定位置：\r\n\r\n```xml\r\n<context-param>\r\n    <param-name>shiroConfigLocations</param-name>\r\n    <param-value>YOUR_RESOURCE_LOCATION_HERE</param-value>\r\n</context-param>\r\n```\r\n\r\n默认情况下，param-value 应该是由 ServletContext.getResource 方法定义的规则可解析的。例如，/WEB-INF/some/path/shiro.ini。\r\n\r\n但你也可以使用 Shiro 的 ResourceUtils 类支持的适当的资源前缀来指定特定的文件系统、类路径或 URL 位置，例如：\r\n\r\n- file:/home/foobar/myapp/shiro.ini\r\n- classpath:com/foo/bar/shiro.ini\r\n- url:http://cofighost.mycompany.com/myapp/shiro.ini\r\n\r\n#### Shiro 1.1和更早的版本\r\n\r\n在1.1或更早的 web 应用程序中启用 Shiro 最简单的方法是定义 IniShiroFilter 并指定一个filter-mapping：\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>\r\n</filter>\r\n\r\n...\r\n\r\n<!-- Make sure any request you want accessible to Shiro is filtered. /* catches all -->\r\n<!-- requests.  Usually this filter mapping is defined first (before all others) to -->\r\n<!-- ensure that Shiro works in subsequent filters in the filter chain:             -->\r\n<filter-mapping>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <url-pattern>/*</url-pattern>\r\n    <dispatcher>REQUEST</dispatcher>\r\n    <dispatcher>FORWARD</dispatcher>\r\n    <dispatcher>INCLUDE</dispatcher>\r\n    <dispatcher>ERROR</dispatcher>\r\n</filter-mapping>\r\n```\r\n\r\n这个定义期望你的 INI 配置位于类路径的根目录下的 shiro.ini 文件中(例如classpath:shiro.ini)。\r\n\r\n##### 自定义路径\r\n\r\n如果你不想将你的 INI 配置放在 /WEB-INF/shiro.ini 或 classpath:shiro.ini 中，你可以根据需要指定一个自定义的资源位置。添加一个 configPath init-param 并指定资源位置：\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>\r\n    <init-param>\r\n        <param-name>configPath</param-name>\r\n        <param-value>/WEB-INF/anotherFile.ini</param-value>\r\n    </init-param>\r\n</filter>\r\n\r\n...\r\n```\r\n\r\n不限定的(无模式的或“无前缀的”) configPath 值被假定为 ServletContext 资源路径，可通过定义的规则解析 ServletContext.getResource 方法。\r\n\r\n**ServletContext 资源路径 - Shiro 1.2+**\r\n\r\nserletcontext 资源路径在 Shiro 1.2 及更高版本中可用。在1.1及之前版本中，所有 configPath 定义都必须指定 `classpath:`、`file:` 或 `url:` 前缀。\r\n\r\n你还可以通过使用 `classpath:`、`file:` 或 `url:` 前缀分别指示类路径、url 或文件系统位置来指定其他非 ServletContext 资源位置。例如：\r\n\r\n```xml\r\n...\r\n<init-param>\r\n    <param-name>configPath</param-name>\r\n    <param-value>url:http://configHost/myApp/shiro.ini</param-value>\r\n</init-param>\r\n...\r\n```\r\n\r\n##### 内联配置\r\n\r\n最后，还可以在 web.xml 中嵌入你的 INI 配置，而完全不需要使用 INI 文件。你可以使用config init-param 而不是 configPath 来实现：\r\n\r\n```xml\r\n<filter>\r\n    <filter-name>ShiroFilter</filter-name>\r\n    <filter-class>org.apache.shiro.web.servlet.IniShiroFilter</filter-class>\r\n    <init-param><param-name>config</param-name><param-value>\r\n\r\n    # INI Config Here\r\n\r\n    </param-value></init-param>\r\n</filter>\r\n...\r\n```\r\n\r\n内联配置对于小型或简单的应用程序通常很好，但由于以下原因，将其外部化到专门的 shiro.ini 文件中通常更方便：\r\n\r\n- 你可能需要大量编辑安全配置，并不想在 web.xml 文件中添加修订控制“噪音”\r\n- 你可能想要将安全配置与 web.xml 配置的其余部分分开\r\n- 你的安全配置可能会变大，你希望 web.xml 保持精简和易于阅读\r\n- 你有一个复杂的构建系统，其中相同的 shiro 配置可能需要在多个地方引用\r\n\r\n这取决于你——使用对你的项目有意义的东西。\r\n\r\n### Web INI 配置\r\n\r\n除了标准的 [main]， [users] 和 [roles] 章节已经在主配置章节中描述，你可以在 shiro.ini 文件中额外指定一个特定于 web 的 [urls] 章节：\r\n\r\n```ini\r\n# [main], [users] and [roles] above here\r\n...\r\n[urls]\r\n...\r\n```\r\n\r\n[urls] 部分允许你做一些在我们所见过的任何 web 框架中都不存在的事情：在你的应用程序中为任何匹配的 URL 路径定义特别过滤器链的能力！\r\n\r\n这比通常在 web.xml 中定义过滤器链要灵活、强大和简洁得多：即使你从未使用 Shiro 提供的任何其他特性，只使用这一特性，它本身就值得使用。\r\n\r\n#### [urls]\r\n\r\nurls 中每一行的格式如下：\r\n\r\n```ini\r\n_URL_Ant_Path_Expression_ = _Path_Specific_Filter_Chain_\r\n```\r\n\r\n例如：\r\n\r\n```ini\r\n...\r\n[urls]\r\n\r\n/index.html = anon\r\n/user/create = anon\r\n/user/** = authc\r\n/admin/** = authc, roles[administrator]\r\n/rest/** = authc, rest\r\n/remoting/rpc/** = authc, perms[\"remote:invoke\"]\r\n```\r\n\r\n等号(=)左边的标记是一个相对于 web 应用程序上下文根的 ant 式路径表达式。\r\n\r\n例如，假设你有以下 [urls] 行：\r\n\r\n```ini\r\n/account/** = ssl, authc\r\n```\r\n\r\n这一行声明“任何对我的应用程序的 /account 路径或它的任何子路径(/account/foo， /account/bar/baz 等)的请求将触发 \'ssl, authc\' 过滤器链”。\r\n\r\n注意，**所有路径表达式都是相对于应用程序的上下文根的**。这意味着，如果你某天将应用程序部署到 www.somehost.com/myapp，然后稍后将其部署到 www.anotherhost.com (没有\' myapp \'子路径)，模式匹配仍然有效。所有路径都相对于 HttpServletRequest.getContextPath() 值。\r\n\r\n##### 过滤器链定义\r\n\r\n等号(=)右侧的 token 是用逗号分隔的过滤器列表，用于对匹配该路径的请求执行过滤器。必须匹配以下格式：\r\n\r\n```\r\nfilter1[optional_config1], filter2[optional_config2], ..., filterN[optional_configN]\r\n```\r\n\r\n- filterN 是在[main]部分中定义的过滤器 bean 的名称\r\n- [optional_configN] 是一个可选的带括号字符串，对特定路径的特定过滤器有意义（*per-filter*，*path-specific* 配置！)如果过滤器不需要该 URL 路径的特定配置，你可以放弃括号，这样 filterN[] 就变成了 filterN。\r\n\r\n因为过滤器标记定义链(也就是List)，所以请记住顺序很重要！按照希望请求在链中流动的顺序定义逗号分隔的列表。\r\n\r\n最后，如果没有满足必要的条件(例如，执行重定向、响应 HTTP 错误代码、直接呈现等)，每个过滤器都可以自由地处理响应。否则，它将允许请求继续通过链到达最终目标视图。\r\n\r\n如果你想创建自己的 javax.servlet.Filter 实现，也可以这样做，确保你的过滤器时`org.apache.shiro.web.filter.PathMatchingFilter` 的子类。\r\n\r\n###### 可用的过滤器\r\n\r\n可用于过滤器链定义的过滤器的“池”定义在[main]部分。在 [main] 节中分配给它们的名称是要在过滤器链定义中使用的名称。例如：\r\n\r\n```ini\r\n[main]\r\n...\r\nmyFilter = com.company.web.some.FilterImplementation\r\nmyFilter.property1 = value1\r\n...\r\n\r\n[urls]\r\n...\r\n/some/path/** = myFilter\r\n```\r\n\r\n## 默认过滤器\r\n\r\n当运行一个 web 应用程序时，Shiro 会创建一些有用的默认过滤器实例，并让它们在[main]部分自动可用。你可以像配置任何其他 bean 一样在 main 中配置它们，并在链定义中引用它们。例如：\r\n\r\n```ini\r\n[main]\r\n...\r\n# Notice how we didn\'t define the class for the FormAuthenticationFilter (\'authc\') - it is instantiated and available already:\r\nauthc.loginUrl = /login.jsp\r\n...\r\n\r\n[urls]\r\n...\r\n# make sure the end-user is authenticated.  If not, redirect to the \'authc.loginUrl\' above,\r\n# and after successful authentication, redirect them back to the original account page they\r\n# were trying to view:\r\n/account/** = authc\r\n...\r\n```\r\n\r\n默认可用的 Filter 实例由 DefaultFilter enum 定义，枚举的 name 字段是配置可用的名称。它们是：\r\n\r\n| Filter Name       | Class                                                        |\r\n| :---------------- | :----------------------------------------------------------- |\r\n| anon              | [org.apache.shiro.web.filter.authc.AnonymousFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/AnonymousFilter.html) |\r\n| authc             | [org.apache.shiro.web.filter.authc.FormAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/FormAuthenticationFilter.html) |\r\n| authcBasic        | [org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BasicHttpAuthenticationFilter.html) |\r\n| authcBearer       | [org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/BearerHttpAuthenticationFilter.html) |\r\n| invalidRequest    | [org.apache.shiro.web.filter.InvalidRequestFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/InvalidRequestFilter.html) |\r\n| logout            | [org.apache.shiro.web.filter.authc.LogoutFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/LogoutFilter.html) |\r\n| noSessionCreation | [org.apache.shiro.web.filter.session.NoSessionCreationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/session/NoSessionCreationFilter.html) |\r\n| perms             | [org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PermissionsAuthorizationFilter.html) |\r\n| port              | [org.apache.shiro.web.filter.authz.PortFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/PortFilter.html) |\r\n| rest              | [org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/HttpMethodPermissionFilter.html) |\r\n| roles             | [org.apache.shiro.web.filter.authz.RolesAuthorizationFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/RolesAuthorizationFilter.html) |\r\n| ssl               | [org.apache.shiro.web.filter.authz.SslFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authz/SslFilter.html) |\r\n| user              | [org.apache.shiro.web.filter.authc.UserFilter](https://shiro.apache.org/static/current/apidocs/org/apache/shiro/web/filter/authc/UserFilter.html) |\r\n\r\n## 启用和禁用过滤器\r\n\r\n与任何过滤器链定义机制(web.xml、Shiro 的 INI 等)一样，只要在过滤器链定义中包含一个过滤器，就可以启用它，而从链定义中删除它就可以禁用它。\r\n\r\n但是 Shiro 1.2 中增加了一个新特性，即可以启用或禁用过滤器，而无需从过滤器链中删除它们。如果启用(默认设置)，则将按预期过滤请求。如果禁用，那么过滤器将允许请求立即传递到 FilterChain 中的下一个元素。通常可以根据配置属性触发筛选器的启用状态，甚至可以根据每个请求触发它。\r\n\r\nShiro 通过它的 OncePerRequestFilter 抽象父类来实现这一点。所有 Shiro 的开箱即用过滤器实现都是这个的子类，因此可以启用或禁用它们，而无需从过滤器链中删除它们。如果你也需要这个功能，你可以子类化这个类来实现你自己的过滤器。\r\n\r\n### 通用的启用/禁用\r\n\r\nOncePerRequestFilter (及其所有子类)支持跨所有请求以及在每个请求的基础上启用/禁用。\r\n\r\n通用启用或禁用所有请求的过滤器是通过设置其 enabled 属性为 true 或 false 来完成的。默认设置为 true，因为如果在链中配置了大多数过滤器，那么它们本质上就需要执行。\r\n\r\n例如，在 shiro.ini：\r\n\r\n```ini\r\n[main]\r\n...\r\n# configure Shiro\'s default \'ssl\' filter to be disabled while testing:\r\nssl.enabled = false\r\n\r\n[urls]\r\n...\r\n/some/path = ssl, authc\r\n/another/path = ssl, roles[admin]\r\n...\r\n```\r\n\r\n这个示例表明，可能有很多 URL 路径都要求必须使用 SSL 连接来保护请求。在开发过程中设置 SSL 会令人沮丧且耗时。在开发过程中，可以禁用 SSL 过滤器。在部署到生产环境时，你可以使用一个配置属性来启用它——这比手动更改所有 URL 路径或维护两个 Shiro 配置要容易得多。\r\n\r\n### 特定请求的启用/禁用\r\n\r\nOncePerRequestFilter 实际上是根据它的 isEnabled(request, response) 方法来确定过滤器是启用还是禁用。\r\n\r\n此方法默认返回 enabled 属性的值，该属性通常用于启用/禁用上面提到的所有请求。如果希望根据请求的特定条件启用或禁用过滤器，可以覆盖 OncePerRequestFilter isEnabled(request, response) 方法来执行更具体的检查。\r\n\r\n### 指定路径的启用/禁用\r\n\r\nShiro 的 PathMatchingFilter(OncePerRequestFilter 的一个子类)具有基于被过滤的特定路径对配置做出反应的能力。这意味着除了传入请求和响应之外，还可以根据路径和特定于路径的配置启用或禁用过滤器。\r\n\r\n如果你需要能够应对匹配路径和于路径配置，以确定如果启用或禁用一个过滤器，而不是覆盖 OncePerRequestFilter isEnabled(request, response)方法，你会覆盖 PathMatchingFilter isEnabled (request,response,path,pathConfig) 方法。\r\n\r\n### 全局过滤器\r\n\r\n从 Shiro 1.6 开始，添加了定义全局过滤器的能力。添加“全局过滤器”将为所有路由添加额外的过滤器，这包括以前配置的过滤器链以及未配置的路径。\r\n\r\n默认情况下，全局过滤器包含 invalidRequest 过滤器。这个过滤器可以阻止已知的恶意攻击。\r\n\r\n例如，可以自定义或禁用全局过滤器：\r\n\r\n```ini\r\n[main]\r\n...\r\n# disable Global Filters\r\nfilterChainResolver.globalFilters = null\r\n```\r\n\r\n定义全局过滤器列表：\r\n\r\n```ini\r\n[main]\r\n...\r\nfilterChainResolver.globalFilters = invalidRequest, port\r\n```\r\n\r\ninvalidRequest 过滤器会阻止带有非 ascii 字符、分号和反斜杠的请求，为了向后兼容，这些字符都可以被单独禁用。\r\n\r\n```ini\r\n[main]\r\n...\r\ninvalidRequest.blockBackslash = true\r\ninvalidRequest.blockSemicolon = true\r\ninvalidRequest.blockNonAscii = true\r\n...\r\n```\r\n\r\n注意：如果你当前允许 URL 重写以允许在 URL 中使用 jsessionid，则必须将blockSemicolon 设置为 false。\r\n\r\n### HTTP 严格传输安全(HSTS)\r\n\r\nSslFilter (及其所有子类)支持启用/禁用 HTTP 严格传输安全(HSTS)。\r\n\r\n例如，在 shiro.ini：\r\n\r\n```ini\r\n[main]\r\n...\r\n# configure Shiro\'s default \'ssl\' filter to enabled HSTS:\r\nssl.enabled = true\r\nssl.hsts.enabled = true\r\nssl.hsts.includeSubDomains = true\r\n\r\n[urls]\r\n...\r\n/some/path = ssl, authc\r\n/another/path = ssl, roles[admin]\r\n...\r\n```\r\n\r\n## Session Management\r\n\r\n### Servlet 容器 Session\r\n\r\n在 web 环境中，Shiro 默认的会话管理器 SessionManager 实现是 ServletContainerSessionManager。这个非常简单的实现将所有会话管理职责(如果 servlet 容器支持，包括会话集群)委托给运行时 servlet 容器。它本质上是 Shiro 的会话 API 到 servlet 容器的桥梁，除此之外几乎什么也做不了。\r\n\r\n使用此默认值的一个好处是，使用现有 servlet 容器会话配置(超时、任何特定于容器的集群机制等)的应用程序将按预期工作。\r\n\r\n此默认值的一个缺点是，你被绑定到 servlet 容器的特定会话行为。例如，如果想要集群会话，但是在生产中使用 Jetty 进行测试和使用 Tomcat，那么容器特定的配置(或代码)将是不可移植的。\r\n\r\n#### Servlet 容器 Session 超时\r\n\r\n如果使用默认的 servlet 容器支持，你可以按照预期在 web 应用程序的 web.xml 文件中配置会话超时。例如：\r\n\r\n```xml\r\n<session-config>\r\n  <!-- web.xml expects the session timeout in minutes: -->\r\n  <session-timeout>30</session-timeout>\r\n</session-config>\r\n```\r\n\r\n### 本地会话\r\n\r\n如果你想让你的会话配置设置和集群可以跨 servlet 容器移植(例如测试中的 Jetty，生产中的 Tomcat 或 JBoss)，或者你想控制特定的会话/集群特性，你可以启用 Shiro 的本地会话管理。\r\n\r\n这里的“Native”一词意味着 Shiro 自己的企业会话管理实现将被用来支持所有 Subject 和 HttpServletRequest 会话，并完全绕过 servlet 容器。但请放心——Shiro 直接实现 Servlet 规范的相关部分，因此任何现有的 web/http 相关代码都可以按照预期工作，永远不需要“知道” Shiro 是透明地管理会话的。\r\n\r\n#### DefaultWebSessionManager\r\n\r\n要为你的 web 应用启用本地会话管理，你需要配置一个本地 web 会话管理器来覆盖默认的基于 servlet 容器的会话管理器。可以通过在 Shiro 的 SecurityManager 上配置一个 DefaultWebSessionManager 实例来实现。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nsessionManager = org.apache.shiro.web.session.mgt.DefaultWebSessionManager\r\n# configure properties (like session timeout) here if desired\r\n\r\n# Use the configured native session manager:\r\nsecurityManager.sessionManager = $sessionManager\r\n```\r\n\r\n声明后，可以使用会话超时和集群配置等本地会话选项配置 DefaultWebSessionManager 实例，如会话管理部分所述。\r\n\r\n##### 本地会话超时\r\n\r\n配置 DefaultWebSessionManager 实例后，会话超时将按照会话管理，可以查看 SessionManager:Session Timeout。\r\n\r\n##### Session Cookie\r\n\r\nDefaultWebSessionManager 支持两个特定于 web 的配置属性：\r\n\r\n- sessionIdCookieEnable (boolean)\r\n- sessionIdCookie, Cookie 实例\r\n\r\nsessionIdCookie 属性本质上是一个模板——你配置 Cookie 实例属性，这个模板将用于在运行时使用适当的会话 ID 值设置实际的 HTTP \' Cookie \'头。\r\n\r\n###### Session Cookie 配置\r\n\r\nDefaultWebSessionManager 的 sessionIdCookie 默认实例是一个 SimpleCookie。这个简单的实现允许对你想要在 http Cookie 上配置的所有相关属性进行 JavaBeans 风格的属性配置。\r\n\r\n例如，你可以设置 Cookie 域：\r\n\r\n```ini\r\n[main]\r\n...\r\nsecurityManager.sessionManager.sessionIdCookie.domain = foo.com\r\n```\r\n\r\ncookie 的默认名称是 JSESSIONID，这符合 servlet 规范。此外，Shiro 的 cookie 支持 HttpOnly 和 SameSite 标志。默认情况下，sessionIdCookie 将 HttpOnly 设置为 true，将 SameSite 设置为 LAX，以增加安全性。\r\n\r\n即使在 Servlet 2.4 和 2.5 环境中，Shiro 的 Cookie 概念也支持 HttpOnly 标志(而 Servlet API 仅在2.6或更高版本中本地支持它)。\r\n\r\n###### 禁用 Session Cookie\r\n\r\n如果不希望使用会话 cookie，可以通过配置 sessionIdCookieEnabled 属性为 false 来禁用它们。例如：\r\n\r\n```ini\r\n[main]\r\n...\r\nsecurityManager.sessionManager.sessionIdCookieEnabled = false\r\n```\r\n\r\n## Remeber Me 服务\r\n\r\n如果 AuthenticationToken 实现了 `org.apache.shiro.authc.RememberMeAuthenticationToken` 接口，Shiro 将执行 \'rememberMe\' 服务。该接口指定了一个方法：\r\n\r\n```java\r\nboolean isRememberMe();\r\n```\r\n\r\n如果方法返回 true，Shiro 将跨 session 记住终端用户。\r\n\r\n常用的 UsernamePasswordToken 已经实现了 RememberMeAuthenticationToken 接口，并支持 rememberMe 登录。\r\n\r\n### 编程支持\r\n\r\n要以编程方式使用 rememberMe，可以在支持此配置的类上将该值设置为 true。例如，使用标准的 UsernamePasswordToken：\r\n\r\n```java\r\nUsernamePasswordToken token = new UsernamePasswordToken(username, password);\r\n\r\ntoken.setRememberMe(true);\r\n\r\nSecurityUtils.getSubject().login(token);\r\n...\r\n```\r\n\r\n### 基于表单登录\r\n\r\n对于 web 应用程序，默认情况下 authc 过滤器是 FormAuthenticationFilter。这支持读取 \'rememberMe\' 布尔值作为表单/请求参数。默认情况下，它期望请求参数被命名为 rememberMe。下面是一个支持 shiro.ini 配置的示例：\r\n\r\n```ini\r\n[main]\r\nauthc.loginUrl = /login.jsp\r\n\r\n[urls]\r\n\r\n# your login form page here:\r\nlogin.jsp = authc\r\n```\r\n\r\n在你的 web 表单中，有一个名为“记住我”的复选框：\r\n\r\n```html\r\n<form ...>\r\n\r\n    Username: <input type=\"text\" name=\"username\"/> <br/>\r\n    Password: <input type=\"password\" name=\"password\"/>\r\n    ...\r\n    <input type=\"checkbox\" name=\"rememberMe\" value=\"true\"/>Remember Me?\r\n    ...\r\n</form>\r\n```\r\n\r\n默认情况下，FormAuthenticationFilter 将查找名为 username、password 和 rememberMe 的请求参数。如果这些名称与表单中使用的表单字段名称不同，则需要在 FormAuthenticationFilter 上配置这些名称。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\nauthc.loginUrl = /whatever.jsp\r\nauthc.usernameParam = somethingOtherThanUsername\r\nauthc.passwordParam = somethingOtherThanPassword\r\nauthc.rememberMeParam = somethingOtherThanRememberMe\r\n...\r\n```\r\n\r\n### Cookie 配置\r\n\r\n你可以通过设置默认的 {{RememberMeManager}} 的各种 cookie 属性来配置 rememberMe cookie 的功能。例如，在 shiro.ini 中：\r\n\r\n```ini\r\n[main]\r\n...\r\n\r\nsecurityManager.rememberMeManager.cookie.name = foo\r\nsecurityManager.rememberMeManager.cookie.maxAge = blah\r\n...\r\n```\r\n\r\n### 自定义 RemeberMeManager\r\n\r\n需要注意的是，如果默认的基于 cookie 的 RememberMeManager 实现不能满足你的需求，你可以插入任何你喜欢的到 securityManager 中，就像你会配置任何其他对象引用一样：\r\n\r\n```ini\r\n[main]\r\n...\r\nrememberMeManager = com.my.impl.RememberMeManager\r\nsecurityManager.rememberMeManager = $rememberMeManager\r\n```\r\n\r\n## JSP / GSP 标签库\r\n\r\nApache Shiro 提供了一个支持 Subject 的 JSP/GSP 标记库，允许你根据当前 Subject 的状态控制 JSP、JSTL 或 GSP 页面输出。这对于基于查看 web 页面的当前用户的身份和授权状态来个性化视图非常有用。\r\n\r\n### 标签库配置\r\n\r\n标签库描述符(TLD)文件被捆绑在 shiro-web.jar 的 META-INF/shiro.tld 文件。要使用任何标记，请在 JSP 页面的顶部(或任何定义页面指令的地方)添加以下一行：\r\n\r\n```jsp\r\n<%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %>\r\n```\r\n\r\n### guest 标签\r\n\r\n只有当当前 Subject 被认为是“guest”时，guest 标记才会显示其包裹的内容。客人是任何没有身份的 Subject。也就是说，我们不知道用户是谁，因为他们没有登录，他们没有记住(从Remember Me服务)从以前的站点访问。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:guest>\r\n    Hi there!  Please <a href=\"login.jsp\">Login</a> or <a href=\"signup.jsp\">Signup</a> today!\r\n</shiro:guest>\r\n```\r\n\r\nguest 标签在逻辑上与 user 标签相反。\r\n\r\n### user 标签\r\n\r\n只有当当前 Subject 被认为是“user”时，用户标记才会显示其包裹的内容。在这个上下文中，“user” 被定义为具有已知身份的 Subject，可以来自成功的身份验证，也可以来自 “RememberMe” 服务。注意，这个标签与 `authenticated` 的标签在语义上不同，后者比这个标记有更多的限制。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:user>\r\n    Welcome back John!  Not John? Click <a href=\"login.jsp\">here<a> to login.\r\n</shiro:user>\r\n```\r\n\r\n### authenticated 标签\r\n\r\n仅当当前用户在当前会话中成功通过身份验证时，才显示正文内容。它比\' user \'标签具有更多的限制性。它在逻辑上与 \'notAuthenticated\' 标记相反。\r\n\r\n只有当当前 Subject 在当前会话中成功通过身份验证时，经过身份验证的标记才会显示其包裹的内容。它是一个比用户更严格的标签，用于在敏感的工作流中保证身份。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:authenticated>\r\n    <a href=\"updateAccount.jsp\">Update your contact information</a>.\r\n</shiro:authenticated>\r\n```\r\n\r\n在逻辑上，authenticated 标签与 notAuthenticated 标签相反。\r\n\r\n### notAuthenticated 标签\r\n\r\n如果当前 Subject 在当前会话没有经过成功认证 notAuthenticated 标签会显示包裹的内容。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:notAuthenticated>\r\n    Please <a href=\"login.jsp\">login</a> in order to update your credit card information.\r\n</shiro:notAuthenticated>\r\n```\r\n\r\n### principal 标签\r\n\r\nprincipal 标签将输出 Subject 的 principal(标识属性)或该 principal 的一个属性。\r\n\r\n如果没有任何标记属性，标记将呈现主体的 toString() 值。例如(假设主体是一个 String 用户名)：\r\n\r\n```jsp\r\nHello, <shiro:principal/>, how are you today?\r\n```\r\n\r\n这很大程度等价于下面的：\r\n\r\n```jsp\r\nHello, <%= SecurityUtils.getSubject().getPrincipal().toString() %>, how are you today?\r\n```\r\n\r\n#### 类型化 principal\r\n\r\n在默认情况下，principal 标记假定要打印的 principal 是 subject.getPrincipal() 值。但是，如果你想打印一个不是主 principal 的值，而是 Subject 的 principal 集合中的另一个值，你可以通过类型获取该主体，然后打印该值。\r\n\r\n例如，打印 Subject 的用户 ID(而不是用户名)，假设 ID 在 principal 集合中：\r\n\r\n```jsp\r\nUser ID: <principal type=\"java.lang.Integer\"/>\r\n```\r\n\r\n这(大部分)相当于以下内容：\r\n\r\n```jsp\r\nUser ID: <%= SecurityUtils.getSubject().getPrincipals().oneByType(Integer.class).toString() %>\r\n```\r\n\r\n#### Principal 属性\r\n\r\n但是，如果 principal (无论是默认的主 principal 还是上面的“类型化” principal)是一个复杂对象而不是简单的字符串，而你想引用该主体的属性，该怎么办？你可以使用 property 属性来指示要读取的属性的名称(必须通过与 JavaBeans 兼容的 getter 方法来访问)。例如(假设主主体是一个User对象)：\r\n\r\n```jsp\r\nHello, <shiro:principal property=\"firstName\"/>, how are you today?\r\n```\r\n\r\n等价于：\r\n\r\n```jsp\r\nHello, <%= SecurityUtils.getSubject().getPrincipal().getFirstName().toString() %>, how are you today?\r\n```\r\n\r\n或者，结合 type 属性：\r\n\r\n```jsp\r\nHello, <shiro:principal type=\"com.foo.User\" property=\"firstName\"/>, how are you today?\r\n```\r\n\r\n等价于：\r\n\r\n```jsp\r\nHello, <%= SecurityUtils.getSubject().getPrincipals().oneByType(com.foo.User.class).getFirstName().toString() %>, how are you today?\r\n```\r\n\r\n### hasRole 标签\r\n\r\n只有当当前 Subject 被分配了指定的角色时，hasRole 标记才会显示其包裹的内容。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:hasRole name=\"administrator\">\r\n    <a href=\"admin.jsp\">Administer the system</a>\r\n</shiro:hasRole>\r\n```\r\n\r\nhasRole 标签逻辑上与 lacksRole 标签相反。\r\n\r\n### lacksRole 标签\r\n\r\nlacksRole 标签只在当前 Subject 未被分配指定角色时显示其包裹的内容。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:lacksRole name=\"administrator\">\r\n    Sorry, you are not allowed to administer the system.\r\n</shiro:lacksRole>\r\n```\r\n\r\n### hasAnyRole 标签\r\n\r\n如果从以逗号分隔的角色名称列表中为当前 Subject 分配了任何指定的角色，则 hasAnyRole 标记将显示其包裹的内容。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:hasAnyRoles name=\"developer, project manager, administrator\">\r\n    You are either a developer, project manager, or administrator.\r\n</shiro:hasAnyRoles>\r\n```\r\n\r\nhasAnyRole 标签目前没有逻辑上相反的标签。\r\n\r\n### hasPermission 标签\r\n\r\n只有当当前 Subject “拥有”(隐含)指定的权限时，hasPermission 标签才会显示其包裹的内容。也就是说，用户具有指定的能力。\r\n\r\n例子：\r\n\r\n```jsp\r\n<shiro:hasPermission name=\"user:create\">\r\n    <a href=\"createUser.jsp\">Create a new User</a>\r\n</shiro:hasPermission>\r\n```\r\n\r\nhasPermission 标签在逻辑上与 lacksPermission 标签相反。\r\n\r\n### lacksPermission 标签\r\n\r\n只有当当前 Subject 没有(隐含)指定的权限时，lacksPermission 标签才会显示其包裹的内容。也就是说，用户没有指定的能力。\r\n\r\n例如：\r\n\r\n```jsp\r\n<shiro:lacksPermission name=\"user:delete\">\r\n    Sorry, you are not allowed to delete user accounts.\r\n</shiro:lacksPermission>\r\n```\r\n\r\n# 整合 Spring\r\n\r\n## 标准应用程序\r\n\r\n在你的应用程序类路径中包含 Shiro Spring 依赖(我们建议使用 Apache Maven 或 Gradle之类的工具来管理它)。\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.apache.shiro</groupId>\r\n    <artifactId>shiro-spring</artifactId>\r\n    <version>1.7.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-context</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n导入 Shiro Spring 配置：\r\n\r\n```java\r\n@Configuration\r\n@Import({ShiroBeanConfiguration.class,\r\n         ShiroConfiguration.class,\r\n         ShiroAnnotationProcessorConfiguration.class})\r\npublic class CliAppConfig {\r\n   ...\r\n}\r\n```\r\n\r\n以上配置的作用如下：\r\n\r\n| Configuration Class                                          | Description                                           |\r\n| :----------------------------------------------------------- | :---------------------------------------------------- |\r\n| org.apache.shiro.spring.config.ShiroBeanConfiguration        | 配置 Shiro 的生命周期和事件                           |\r\n| org.apache.shiro.spring.config.ShiroConfiguration            | 配置 Shiro Beans（SecurityManger、SessionManager 等） |\r\n| org.apache.shiro.spring.config.ShiroAnnotationProcessorConfiguration | 启用 Shiro 注解处理                                   |\r\n\r\n唯一剩下的就是配置一个 realm：\r\n\r\n```java\r\n@Bean\r\npublic Realm realm() {\r\n    ...\r\n}\r\n```\r\n\r\n最简单的方法设置 Shiro，使所有的 SecurityUtils.\\* 方法在所有情况下都有效，是使 SecurityManager bean 成为一个静态单例。**不要**在 web 应用程序中这样做——请参阅下面的 web 应用程序部分。\r\n\r\n```java\r\n@Autowired\r\nprivate SecurityManager securityManager;\r\n    \r\n @PostConstruct\r\n private void initStaticSecurityManager() {\r\n     SecurityUtils.setSecurityManager(securityManager);\r\n }\r\n```\r\n\r\n就是这样，现在你可以获取当前的 Subject：\r\n\r\n```java\r\nSecurityUtils.getSubject();\r\n```\r\n\r\n## Web 应用程序\r\n\r\nShiro 对 Spring web 应用程序有一流的支持。在 web 应用程序中，所有可访问 Shiro 的 web 请求都必须通过主 Shiro 过滤器。这个过滤器本身非常强大，允许基于任何 URL 路径表达式执行特别的自定义过滤器链。\r\n\r\n在你的应用程序类路径中包含 Shiro Spring web 依赖项(我们建议使用Apache Maven或Gradle等工具来管理它)。\r\n\r\n```xml\r\n<dependency>\r\n    <groupId>org.apache.shiro</groupId>\r\n    <artifactId>shiro-spring</artifactId>\r\n    <version>1.7.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.apache.shiro</groupId>\r\n    <artifactId>shiro-web</artifactId>\r\n    <version>1.7.1</version>\r\n</dependency>\r\n<dependency>\r\n    <groupId>org.springframework</groupId>\r\n    <artifactId>spring-webmvc</artifactId>\r\n    <version>${spring.version}</version>\r\n</dependency>\r\n```\r\n\r\n导入 Shiro Spring 配置：\r\n\r\n```java\r\n@Configuration\r\n@Import({ShiroBeanConfiguration.class,\r\n         ShiroAnnotationProcessorConfiguration.class,\r\n         ShiroWebConfiguration.class,\r\n         ShiroWebFilterConfiguration.class,\r\n         ShiroRequestMappingConfig.class})\r\npublic class ApplicationConfig {\r\n    ...\r\n}\r\n```\r\n\r\n以上配置的作用如下：\r\n\r\n| Configuration Class                                          | Description                                                  |\r\n| :----------------------------------------------------------- | :----------------------------------------------------------- |\r\n| org.apache.shiro.spring.config.ShiroBeanConfiguration        | 配置 Shiro 的生命周期和事件                                  |\r\n| org.apache.shiro.spring.config.ShiroAnnotationProcessorConfiguration | 启用 Shiro 的注解处理                                        |\r\n| org.apache.shiro.spring.web.config.ShiroWebConfiguration     | 配置 Shrio Bean 给 web 使用（SecurityManager、SessionManager 等） |\r\n| org.apache.shiro.spring.web.config.ShiroWebFilterConfiguration | 配置 Shiro 的 web 过滤器                                     |\r\n| org.apache.shiro.spring.web.config.ShiroRequestMappingConfig | 使用 Shiro 的 UrlPathHelper 实现配置 Spring，以确保两个框架处理的 URL 相同 |\r\n\r\n提供 Realm 实现：\r\n\r\n```java\r\n@Bean\r\npublic Realm realm() {\r\n    ...\r\n}\r\n```\r\n\r\n最后，一个 ShiroFilterChainDefinition 将任何应用程序特定的路径映射到一个给定的过滤器，以允许不同的路径不同的访问级别。\r\n\r\n```java\r\n@Bean\r\npublic ShiroFilterChainDefinition shiroFilterChainDefinition() {\r\n    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\r\n\r\n    // logged in users with the \'admin\' role\r\n    chainDefinition.addPathDefinition(\"/admin/**\", \"authc, roles[admin]\");\r\n\r\n    // logged in users with the \'document:read\' permission\r\n    chainDefinition.addPathDefinition(\"/docs/**\", \"authc, perms[document:read]\");\r\n\r\n    // all other paths require a logged in user\r\n    chainDefinition.addPathDefinition(\"/**\", \"authc\");\r\n    return chainDefinition;\r\n}\r\n```\r\n\r\n## 启用 Shiro 注解\r\n\r\n在独立应用和 web 应用中，你可能想要使用 Shiro 的注释进行安全检查(例如， @RequiresRoles，@RequiresPermissions 等)。这些注释可以通过在上面两部分中导入 ShiroAnnotationProcessorConfiguration Spring 配置来启用。\r\n\r\n简单地注解你的方法，以便使用它们：\r\n\r\n```java\r\n@RequiresPermissions(\"document:read\")\r\npublic void readDocument() {\r\n    ...\r\n}\r\n```\r\n\r\n### 注解和 Web 应用\r\n\r\n@Controller 类完全支持 Shiro 注释，例如：\r\n\r\n```java\r\n@Controller\r\npublic class AccountInfoController {\r\n\r\n    @RequiresRoles(\"admin\")\r\n    @RequestMapping(\"/admin/config\")\r\n    public String adminConfig(Model model) {\r\n        return \"view\";\r\n    }\r\n}\r\n```\r\n\r\n仍然需要一个至少具有一个定义的 ShiroFilterChainDefinition bean 才能工作，要么配置所有路径通过 anon 过滤器访问，要么配置一个“permissive”模式的过滤器，例如：authcBasic[permissive]。\r\n\r\n```java\r\n@Bean\r\npublic ShiroFilterChainDefinition shiroFilterChainDefinition() {\r\n    DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\r\n    chainDefinition.addPathDefinition(\"/**\", \"anon\"); // all paths are managed via annotations\r\n\r\n    // or allow basic authentication, but NOT require it.\r\n    // chainDefinition.addPathDefinition(\"/**\", \"authcBasic[permissive]\"); \r\n    return chainDefinition;\r\n}\r\n```\r\n\r\n## 缓存\r\n\r\n启用缓存就像提供一个 CacheManager bean 一样简单：\r\n\r\n``` java\r\n@Bean\r\nprotected CacheManager cacheManager() {\r\n    return new MemoryConstrainedCacheManager();\r\n}\r\n```\r\n\r\n## 配置属性\r\n\r\n| Key                                               | Default Value | Description                                              |\r\n| :------------------------------------------------ | :------------ | :------------------------------------------------------- |\r\n| shiro.sessionManager.deleteInvalidSessions        | `true`        | 从 session 存储中移除无效 session                        |\r\n| shiro.sessionManager.sessionIdCookieEnabled       | `true`        | 启用 cookie 的  session ID，以便 session 追踪            |\r\n| shiro.sessionManager.sessionIdUrlRewritingEnabled | `true`        | 启用 session URL 重写支持                                |\r\n| shiro.userNativeSessionManager                    | `false`       | 如果启用，Shiro 将管理 HTTP 会话而不是容器               |\r\n| shiro.sessionManager.cookie.name                  | `JSESSIONID`  | Session cookie  名                                       |\r\n| shiro.sessionManager.cookie.maxAge                | `-1`          | Session cookie  有效期                                   |\r\n| shiro.sessionManager.cookie.domain                | null          | Session cookie  域                                       |\r\n| shiro.sessionManager.cookie.path                  | null          | Session cookie  路径                                     |\r\n| shiro.sessionManager.cookie.secure                | `false`       | Session cookie  安全标志                                 |\r\n| shiro.rememberMeManager.cookie.name               | `rememberMe`  | RememberMe cookie 名                                     |\r\n| shiro.rememberMeManager.cookie.maxAge             | one year      | RememberMe cookie 有效期                                 |\r\n| shiro.rememberMeManager.cookie.domain             | null          | RememberMe cookie domain                                 |\r\n| shiro.rememberMeManager.cookie.path               | null          | RememberMe cookie path                                   |\r\n| shiro.rememberMeManager.cookie.secure             | `false`       | RememberMe cookie secure flag                            |\r\n| shiro.loginUrl                                    | `/login.jsp`  | 将未经身份验证的用户重定向到登录页面时使用的 Login URL   |\r\n| shiro.successUrl                                  | `/`           | 用户登录后的默认登录页面(如果在当前会话中找不到替代选项) |\r\n| shiro.unauthorizedUrl                             | null          | 如果用户未授权，则将用户重定向到的页面(403页)            |\r\n\r\n', '根据官方 Shiro 指导文档做的笔记', '鸡米花', 'IMG_3331.JPG', '1', '0', '7', '2021-08-15 00:18:57', '2021-08-15 00:18:57');
INSERT INTO `t_blog` VALUES ('6', 'Spring Mvc 笔记', '# Spring Web MVC\r\n\r\nSpring Web MVC 是一个建立在 Servlet API 上的 web 框架，并且包含 Spring 框架。这个名字是来自 spring-webmvc 模块，但是大家都喜欢交它 Spring MVC。\r\n\r\n和 Spring MVC 相似，Spring Framework 5.0 引入了响应式框架，名为 Spring WebFlux。\r\n\r\n## DispatcherServlet\r\n\r\nDispatcherServlet 作为一个 Servlet ，需要在 Java 配置文件或者 web.xml 声明。\r\n\r\n下面是一个用 Java 配置来注册和初始化 DispatcherServlet 的例子：\r\n\r\n```java\r\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\r\n    \r\n	@Override\r\n	public void onStartup(ServletContext servletCxt) {\r\n		// Load Spring web application configuration\r\n		AnnotationConfigWebApplicationContext ac = new AnnotationConfigWebApplicationContext();\r\n		ac.register(AppConfig.class);\r\n		ac.refresh();\r\n		// Create and register the DispatcherServlet\r\n		DispatcherServlet servlet = new DispatcherServlet(ac);\r\n		ServletRegistration.Dynamic registration = servletCxt.addServlet(\"app\", servlet);\r\n		registration.setLoadOnStartup(1);\r\n		registration.addMapping(\"/app/*\");\r\n	}\r\n}\r\n```\r\n\r\n提示：除了直接使用这个 API ，还可以继承 AbstractAnnotationConfigDispatcherSerlvetInitializer 并重写特定的方法。\r\n\r\n下面的例子演示使用 web.xml 注册和初始化：\r\n\r\n```xml\r\n<web-app>\r\n    <listener>\r\n	    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n    \r\n    <context-param>\r\n    	<param-name>contextConfigLocation</param-name>\r\n    	<param-value>/WEB-INF/app-context.xml</param-value>\r\n    </context-param>\r\n    \r\n    <servlet>\r\n        <servlet-name>app</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servletclass>\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value></param-value>\r\n        </init-param>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n    \r\n    <servlet-mapping>\r\n        <servlet-name>app</servlet-name>\r\n        <url-pattern>/app/*</url-pattern>\r\n    </servlet-mapping>\r\n</web-app>\r\n```\r\n\r\n### Context 层次\r\n\r\nDispatcherServlet 期望一个自己配置的 WebApplicationContext。可能会有多个由他们自己配置 WebApplicationContext 的 Servlet 实例共享一个根 WebApplicationContext 。\r\n\r\n根 WebApplicationContext 通常包含一些基础 bean，例如 DAO、业务逻辑，这就需要跨多个 Servlet 实例共享。这些 bean 可以被子 WebApplicationContext 继承或者覆盖。关系图：![DispatcherServlet关系图](E:\\学习笔记\\assets\\DispatcherServlet关系图.png)\r\n\r\n\r\n\r\n配置 WebApplicationContext 层次：\r\n\r\n```java\r\npublic class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\r\n    \r\n	@Override\r\n	protected Class<?>[] getRootConfigClasses() {\r\n		return new Class<?>[] { RootConfig.class };\r\n	}\r\n    \r\n    @Override\r\n    protected Class<?>[] getServletConfigClasses() {\r\n    	return new Class<?>[] { App1Config.class };\r\n    }\r\n    \r\n    @Override\r\n    protected String[] getServletMappings() {\r\n    	return new String[] { \"/app1/*\" };\r\n    }\r\n}\r\n```\r\n\r\n提示：如果不需要层次，可以在 getRootConfigClasses() 返回所有配置，在 getServletConfigClasses() 返回 null。\r\n\r\n刚刚的例子和下面的等价：\r\n\r\n```xml\r\n<web-app>\r\n    \r\n    <listener>\r\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\r\n    </listener>\r\n\r\n    <context-param>\r\n        <param-name>contextConfigLocation</param-name>\r\n        <param-value>/WEB-INF/root-context.xml</param-value>\r\n    </context-param>\r\n\r\n    <servlet>\r\n        <servlet-name>app1</servlet-name>\r\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servletclass>\r\n        <init-param>\r\n            <param-name>contextConfigLocation</param-name>\r\n            <param-value>/WEB-INF/app1-context.xml</param-value>\r\n        </init-param>\r\n        <load-on-startup>1</load-on-startup>\r\n    </servlet>\r\n\r\n    <servlet-mapping>\r\n        <servlet-name>app1</servlet-name>\r\n        <url-pattern>/app1/*</url-pattern>\r\n    </servlet-mapping>\r\n</web-app>\r\n```\r\n\r\n提示：如果不需要层次，可以只在 \"root\" 配置 context，在 Servlet 的 contextConfigLocation 参数留空。\r\n\r\n### 特殊的 Bean 类型\r\n\r\nDispatcherServlet 委派特殊的 bean 来完成处理请求和渲染适当的请求。\r\n\r\n| Bean 类型                                  | 解释                                                         |\r\n| ------------------------------------------ | ------------------------------------------------------------ |\r\n| HandlerMapping                             | 将请求伴随在拦截器的预处理和后处理映射请求到处理器<br />两个主要的实现是 `RequestMappingHandlerMapping` （支持 @RequestMapping 注解）和 `SimpleUrlHandlerMapping` （解析 Url 路径）。 |\r\n| HandlerAdapter                             | 帮助 DispatcherServlet 调用映射到请求处理器，主要目的是隐藏 DispatcherSerlvet 细节。 |\r\n| HandlerExceptionResolver                   | 解析异常策略，可能将请求映射到处理器、错误 HTML 页面或者其它目标。 |\r\n| ViewResolver                               | 解析从处理器返回的 String 的视图名称，使 response 渲染真正的视图。 |\r\n| LocaleResolver,<br />LocaleContextResolver | 解析客户端地区和时区，以提供国际化视图。                     |\r\n| ThemeResolver                              | 解析 web 应用可以使用的主题。                                |\r\n| MultipartResolver                          | 在一些库的帮助下抽象解析 multi-part                          |\r\n| FlashMapManager                            | 存取 通常在重定向请求属性中用的 FlashMap。                   |\r\n\r\n### Web MVC 配置\r\n\r\n可以声明列在上表的 bean，DispatcherServlet 检查 WebApplicationContext 的所有特殊 bean。如果没有匹配的类型，会使用列在 DispatcherServlet.properties 中的默认类型。\r\n\r\n提示：Spring Boot 依靠 MVC Java 配置来配置 Spring MVC。\r\n\r\n### Servlet 配置\r\n\r\n在 Servlet 3.0 以上，你可以选择用变成的或者结合 web.xml 的方式来配置 Servlet 容器。\r\n\r\n```java\r\nimport org.springframework.web.WebApplicationInitializer;\r\n\r\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\r\n    \r\n    @Override\r\n    public void onStartup(ServletContext container) {\r\n        XmlWebApplicationContext appContext = new XmlWebApplicationContext();\r\n        appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\r\n        ServletRegistration.Dynamic registration = container.addServlet(\r\n            \"dispatcher\", new DispatcherServlet(appContext));\r\n        registration.setLoadOnStartup(1);\r\n        registration.addMapping(\"/\");\r\n    }\r\n}\r\n```\r\n\r\n也可以继承 AbstractDispatcherServletInitializer 抽象类，通过重写特定方法来配置。\r\n\r\n推荐使用基于 Java 的配置：\r\n\r\n```java\r\npublic class MyWebAppInitializer extends\r\n    AbstractAnnotationConfigDispatcherServletInitializer {\r\n    \r\n    @Override\r\n    protected Class<?>[] getRootConfigClasses() {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    protected Class<?>[] getServletConfigClasses() {\r\n        return new Class<?>[] { MyWebConfig.class };\r\n    }\r\n    \r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return new String[] { \"/\" };\r\n    }\r\n}\r\n```\r\n\r\n如果用基于 XML 的配置方式，应该直接继承抽象类：\r\n\r\n```java\r\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\r\n    \r\n    @Override\r\n    protected WebApplicationContext createRootApplicationContext() {\r\n        return null;\r\n    }\r\n    \r\n    @Override\r\n    protected WebApplicationContext createServletApplicationContext() {\r\n        XmlWebApplicationContext cxt = new XmlWebApplicationContext();\r\n        cxt.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\");\r\n        return cxt;\r\n    }\r\n    \r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return new String[] { \"/\" };\r\n    }\r\n}\r\n```\r\n\r\n这个抽象类也提供方便的方法添加 Filter 实例并且让他们自动映射到 DispatcherServlet：\r\n\r\n```java\r\npublic class MyWebAppInitializer extends AbstractDispatcherServletInitializer {\r\n\r\n    // ...\r\n\r\n    @Override\r\n    protected Filter[] getServletFilters() {\r\n        return new Filter[] {\r\n            new HiddenHttpMethodFilter(), new CharacterEncodingFilter() };\r\n    }\r\n}\r\n```\r\n\r\n每个过滤器都以基于类型的默认名字添加，并且自动映射到 DispatcherServlet 。\r\n\r\nprotected 的方法 isAsyncSupported提供一个是否支持异步的开关，默认为 true。\r\n\r\n如果要进一步自定义 DispatcherServlet ，可以重写 createDispatcherServlet 方法。\r\n\r\n### 处理\r\n\r\nDispatcherServlet 处理请求如下：\r\n\r\n- WebApplicationContext在请求中被搜索和绑定,作为该过程中控制器和其他元素可以使用的属性。它默认在 DispatcherServlet.WEB_APPLICATION_CONTEXT_ATTRIBUTE 键下绑定。\r\n- 地区解析器绑定到请求。如果不需要地区解析，就不需要配置地区解析器。\r\n- 主题解析器绑定到请求，让元素决定决定使用哪个主题。\r\n- 如果指定了 multiparty file 解析器，请求会检查 multiparts，如果找到了，请求会通过处理中的其它元素被包装成 MultipartHttpServletRequest 。\r\n- 找到适当的处理器。和处理器相关的执行器链被按执行以准备数据模型（model）和渲染。对于注解控制器（controllers），相应可以在 HandlerAdapter 中被渲染，而不是返回视图。\r\n- 如果返回了数据模型，会渲染视图（view）。如果没有返回数据模型（可能由于预处理器或后处理器拦截了请求，也可能由于安全原因），不会渲染视图，因为请求已经无法完成了。\r\n\r\nHandlerExceptionResolver 通常用于解析在请求处理过程中抛出的异常。\r\n\r\n可以在 web.xml 通过添加初始化参数（`init-param` 元素）自定义 DispatcherServlet，支持以下参数：\r\n\r\n| 参数                           | 解释                                                         |\r\n| ------------------------------ | ------------------------------------------------------------ |\r\n| contextClass                   | `ConfigurableWebApplicationContext` 的实现类，在这个 Servlet 实例化和局部配置，默认是 `XmlWebApplicationContext` |\r\n| contextConfigLocation          | 通过字符串指示要在哪里找 context 实例，可能包含多个字符串（用逗号分隔）来加载多个 context。如果重复定义，最后的优先级最高。 |\r\n| namespace                      | WebApplicationContext 命名空间，默认为 [servlet-name]-servlet。 |\r\n| throwExceptionIfNoHandlerFound | 没有找到对应的请求处理器时是否抛出 `NoHandlerFoundException` ，这个异常可以被 HandlerExceptionResolver 捕获。<br />默认值为 `false`，这种情况只响应 404 而不抛出异常。<br />注意：如果配置了默认 servlet handling ，未解析的请求将转到默认的 servlet 而不是返回 404。 |\r\n\r\n### 拦截\r\n\r\n所有 HandlerMapping 支持处理程序拦截器，当你想将特定功能应用在某些请求的时候很有用。拦截器必须实现来自 `org.springframework.web.servlet` 包的 `HandlerInterceptor` 接口，这个接口有三个方法：\r\n\r\n- preHandle(..) 在执行实际的处理器之前\r\n- postHandle(..) 在执行实际的处理器之后\r\n- afterCompletion(..) 在完整的请求完成后\r\n\r\npreHandle() 方法返回布尔值，可以用这个方法终止或继续执行处理链。返回 true 的时候继续执行，返回 false 的时候，DispatcherServlet 认为拦截器已经完成了请求的所有工作（例如呈现合适的视图），不会继续执行其它拦截器和其它处理器。\r\n\r\n注意： postHandle 对 @ResponseBody 和 @ ResponseEntiy 方法没那么有用，response 在 HandlerAdapter 和 postHandle 之前就已经完成了写和提交。这意味着如果想要改变任何响应（例如添加额外的响应头）已经太晚 了。对于这种情况，可以实现 `ResponseBodyAdvice` 并且声明它为 Controlelr Advice bean 或直接配置它为 `RequsetMappingHandlerAdapter`。\r\n\r\n### 异常\r\n\r\n如果在请求映射或请求处理过程中引发异常，DispatcherServlet 会委派 HandlerExceptionResolver bean 链解析和提供适当的处理。可用的 HandlerExceptionResolver 实现：\r\n\r\n| HandlerExceptionResolver          | 描述                                                         |\r\n| --------------------------------- | ------------------------------------------------------------ |\r\n| SimpleMappingExceptionResolver    | 错误类名和错误视图之间的映射，用于浏览器显示错误页。         |\r\n| DefaultHandlerExceptionResolver   | 解析 Spring MVC 抛出的异常，并将它们映射到 HTTP 状态码。     |\r\n| ResponseStatusExceptionResolver   | 解析带有 @ResponseStatus 注解的异常并基于注解的值映射到 HTTP 状态码。 |\r\n| ExceptionHandlerExceptionResolver | 解析由于调用 @Controlelr 或 @ControllerAdvice 中带有 @ExceptionHandler 的方法抛出的异常 |\r\n\r\n#### 解析链\r\n\r\n可以通过在 Spring 配置声明多个 HandlerExceptionResolver bean 并按需设置他们的 order 属性来组成一条异常解析链。order 属性越高，在异常解析链的位置就越后。\r\n\r\nHandlerExceptionResolver 可以返回：\r\n\r\n- 一个 ModelAndView 指定错误视图。\r\n- 一个空的 ModelAndView，如果异常在解析器里面处理了。\r\n- null，如果异常仍然未解决，则在随后的解析器再尝试，如果到最后都没有解决，异常可以冒到 Servlet 容器。\r\n\r\nMVC 配置为默认的 Spring MVC 异常自动声明内置的解析器，用于 @ResponseStatus 注解的异常和支持 @ExceptionHandler 方法。可以自定义顺序或替换它。\r\n\r\n#### 容器错误页\r\n\r\n如果异常再所有 HandlerExceptionResolver 都没有得到处理，让它继续传播还是设置为错误状态，Servlet 容器可以渲染一个默认的 HTML 错误页。为了给容器自定义默认的错误页，可以在 web.xml 声明错误页映射：\r\n\r\n```xml\r\n<error-page>\r\n    <location>/error</location>\r\n</error-page>\r\n```\r\n\r\n在前面的例子， 当错误冒到容器或者响应时一个错误状态，Servlet 容器会在容器内委派错误到配置的 URL。然后由 DispatcherServlet 处理，可能会映射到一个 @Controller，该控制器可以实现以模型返回错误视图名称或呈现 JSON 响应。\r\n\r\n```java\r\n@RestController\r\npublic class ErrorController {\r\n    \r\n    @RequestMapping(path = \"/error\")\r\n    public Map<String, Object> handle(HttpServletRequest request) {\r\n        Map<String, Object> map = new HashMap<String, Object>();\r\n        map.put(\"status\", request.getAttribute(\"javax.servlet.error.status_code\"));\r\n        map.put(\"reason\", request.getAttribute(\"javax.servlet.error.message\"));\r\n        return map;\r\n    }\r\n}\r\n```\r\n\r\n### 视图解析\r\n\r\n视图解析器提供视图名称和实际视图之间的映射。视图在将转换的到特定视图技术前做好数据准备。下面这个表展示视图解析器的层次结构：\r\n\r\n| ViewResolver                   | 描述                                                         |\r\n| ------------------------------ | ------------------------------------------------------------ |\r\n| AbstractCachingViewResolver    | 可以通过设置 `cache` 属性为 false 关闭缓存。此外，如果一定要刷新一个确定的视图，可以使用 removeFromCache(String viewName, Locale loc) 方法。 |\r\n| XmlViewResolver                | ViewResolver 的实现，接受和 Spring 的 XML bean 工厂 DTD 一样的 XML 文件。文件默认位置是 /WEB-INF/views.xml。 |\r\n| ResourceBundleViewResolver     | 在 bundle 基名指定的 ResourceBundle 中使用 bean 定义的 ViewResolver 的实现。解析所有视图，用属性 [viewname].class 的值做为视图类，用属性 [viewname].url 的值作为视图 URL。 |\r\n| UrlBasedViewResolver           | 简单的 ViewResolver 接口的实现,它影响到不需要显式映射定义的 url 的逻辑视图名称的直接解析。如果您的逻辑名称以直截了当的方式匹配视图资源的名称,则不需要任意映射,这是适当的。 |\r\n| InternalResourceViewResolver   | UrlBaseViewResolver 的子类，支持 InternalResourceView （实际上是 Servlet 和 JSP）和子类。可以通过使用 setViewClass(. .) 来指定该解析器生成的所有视图的视图类。 |\r\n| FreeMarkerViewResolver         | UrlBasedViewResovler 的子类，支持 FreeMarkerView 和他们自定义子类。 |\r\n| ContentNegotiatingViewResolver | ViewResolver 接口的实现，基于请求文件名或 Accept 头解析视图。 |\r\n\r\n#### 处理\r\n\r\n可以连接多个解析器 bean，按需设置 order 属性定义顺序。记住，order 属性值越高，视图解析器排在越后面。\r\n\r\n视图解析器可以返回 null 来表示无法找到视图。然而，在 JSP 和 InternalResourceViewResolver 的情况下，判定 JSP 是否存在的唯一方法是通过 RequestDispatcher 调度。因此，必须要在视图解析器最后位置配置一个 InternalResourceViewResolver 。\r\n\r\n配置视图解析只是简单添加一个 ViewResolver bean 到 Spring 配置。MVC Config 为视图解析器提供了一个专用的配置 API，并为没有控制器逻辑的 HTML 模板呈现有用的无逻辑视图控制器。\r\n\r\n#### 重定向\r\n\r\n视图名称中特殊的前缀 `redirect:` 让你执行重定向。UrlBasedViewResolver （或它的子类）识别出重定向指令，其余的视图名作为重定向 URL。\r\n\r\n这和 controller 返回一个 RedirectView 的效果一样。逻辑视图名称（如：redirect:/myapp/some/resource  ）重定向到相对当前 Serlvet context，而一个名称（如：redirect:https://myhost.com/some/arbitrary/path  ）重定向到绝对 URL。\r\n\r\n注意，如果一个控制器方法是用 @ResponseStatus 进行的，那么注解值优先于 RedirectView 设置的响应状态。\r\n\r\n#### 转发\r\n\r\n在视图名称中使用特殊前缀 `forward:` 会被 UrlBasedViewResolver 和它子类解析。会创建一个 InternalResourceView，执行 ResuestDisptecher.forward() 。因此，这个前缀在 InternalResourceViewResolver 和 InternalResourceView （对于 JSP）是没有用的，但是如果你使用其它视图技术还想强制转发到 Servlet/JSP 来处理是有用的。\r\n\r\n#### 内容协商\r\n\r\nContextNegotiatingViewResolver 不解析视图本身，而是其它视图解析器的代表，并选择类似于客户机所要求的表现的视图。这个表现可以来自 Accept 头或查询参数（\"/path?format=pdf\"）。\r\n\r\n列表中的第一个兼容客户端要求的内容的视图返回表现。如果找到支持的视图，则则使用 DefaultViews 属性配置的。\r\n\r\n### 地区\r\n\r\n通过用 RequsetContext.getLocate() 方法，可以获取到地区解析器解析到的地区。\r\n\r\n除了自动区域解析，还可以将拦截器附加到处理程序映射，以在特定环境下更改环境(例如,基于请求中的参数)。\r\n\r\n区域解析器和拦截器是在 `org.springframework.web.servlet.i18n` 包下定义的。在 Spring 中包含以下的地区 resolvers 的选择：\r\n\r\n- Time Zone\r\n- Header Resolver\r\n- Cookie Resolver\r\n- Session Resolver\r\n- Locale Interceptor\r\n\r\n*很少用，详细的用到再看。*\r\n\r\n### 主题\r\n\r\n您可以应用 Spring Web MVC 框架主题来设置应用程序的整体外观，从而提高用户体验。一个主题是静态资源的集合，通常是样式和图像。\r\n\r\n#### 定义一个主题\r\n\r\n要在 web 应用使用主题，必须建立一个 `org.springframework.ui.context.ThemeSource` 接口的实现。WebApplicationContext 接口继承了 ThemeSource ，但是它将这个职责委派给专门的实现。默认情况下是委派给 `org.springframework.ui.context.support.ResourceBundleThemeSource` 实现，它从根路径加载属性文件。为了用自定义的 ThemeSource 实现或配置 ResourceBundleThemeSource 的基名，可以在 application context 中用保留名 themeSource 注册一个 bean。\r\n\r\n使用 ResourceBundleThemeSource 时，一个简单的主题在属性文件中定义。\r\n\r\n```properties\r\nstyleSheet=/themes/cool/style.css\r\nbackground=/themes/cool/img/coolBg.jpg\r\n```\r\n\r\n属性的键是你在代码中引用主题元素的名称。对于 JSP ，通常使用 `spring:theme` 标签。\r\n\r\n```html\r\n<%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\"%>\r\n    <html>\r\n        <head>\r\n            <link rel=\"stylesheet\" href=\"<spring:theme code=\'styleSheet\'/>\"\r\n                  type=\"text/css\"/>\r\n        </head>\r\n        <body style=\"background=<spring:theme code=\'background\'/>\">\r\n            ...\r\n        </body>\r\n    </html>\r\n```\r\n\r\nResourceBundleThemeSource 默认使用空的基名前缀。因此属性文件会从根类路径加载。ResourceBundleThemeSource 使用标准的 Java 资源加载机制，所以支持国际化文件名。如 cool_nl.properties  。\r\n\r\n#### 解析主题\r\n\r\nDispatcherServlet 查找一个名为 themeResolver 的 bean 以找出 ThemeResolver 的实现来使用。它检测主题使用特定的请求,也可以更改请求的主题。下表描述了Spring提供的主题resolvers:\r\n\r\n| Class                | 描述                                                 |\r\n| -------------------- | ---------------------------------------------------- |\r\n| FixedThemeResolver   | 选择一个固定的主题，通过 defaultThemeName 属性设置。 |\r\n| SessionThemeResolver | 在 HTTP session 内保持主题，一个 session 只设置一次  |\r\n| CookieThemeResolver  | 选择的主题存储在客户机上的cookie中。                 |\r\n\r\n### Multipart 解析器\r\n\r\nMultipartResolver 来自 `org.springframework.web.multipart` 包，用来解析包括文件上传的 multipart 请求。有一个基于 Commons FileUpload 和另一个基于 Servlet 3.0 multipart 请求解析的实现。\r\n\r\n为了启用 multipart 处理，需要在 DispatcherServlet Spring 配置一个名为 multipartResolver 的 MultipartResolver bean。当收到一个 POST 并且 content-type 是 multipart/form-data 的请求，这个解析器解析内容并且将当前 HttpServletRequest 包装为 MultipartHttpServletRequest 以提供访问去解析 parts。\r\n\r\n#### Apache Commons （FileUpload）\r\n\r\n要使用 Apache Commons 文件上传，您可以配置一个类型的CommonsMultipartResolver 的 bean， 它的名称是 multipartResolver。您还需要将 common-fileupload 作为对类路径的依赖。\r\n\r\n#### Servlet 3.0\r\n\r\nServlet 3.0 multipart 解析需要通过 Servlet 容器配置启用。\r\n\r\n- 在 Java，在 Servlet 注册中设置一个 MultipartConfigElement\r\n- 在 web.xml，在 servlet 声明添加 `<multipart-config>`\r\n\r\n下面演示在 Servlet 注册如何设置：\r\n\r\n```java\r\npublic class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer {\r\n    \r\n    // ...\r\n    \r\n    @Override\r\n    protected void customizeRegistration(ServletRegistration.Dynamic registration)\r\n    {\r\n        // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold\r\n        registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\"));\r\n    }\r\n}\r\n```\r\n\r\n从 Servlet 3.0 开始，可以添加一个名为 multipartResolver 类型为 StandardServletMultipartResolver 的 bean。\r\n\r\n### 日志\r\n\r\n调试和跟踪日志可以记录敏感信息。这就是为什么请求参数和头被默认屏蔽，并且它们的日志记录必须通过在 DispatcherServlet 上通过 enableLoggingRequestDetails 属性显式启用。\r\n\r\n```java\r\npublic class MyInitializer\r\n    extends AbstractAnnotationConfigDispatcherServletInitializer {\r\n    \r\n    @Override\r\n    protected Class<?>[] getRootConfigClasses() {\r\n        return ... ;\r\n    }\r\n    \r\n    @Override\r\n    protected Class<?>[] getServletConfigClasses() {\r\n        return ... ;\r\n    }\r\n    \r\n    @Override\r\n    protected String[] getServletMappings() {\r\n        return ... ;\r\n    }\r\n    \r\n    @Override\r\n    protected void customizeRegistration(Dynamic registration) {\r\n        registration.setInitParameter(\"enableLoggingRequestDetails\", \"true\");\r\n    }\r\n}\r\n```\r\n\r\n## 过滤器\r\n\r\nspring-web 模块提供一些有用的过滤器：\r\n\r\n- Form Data\r\n- Forwarded Headers\r\n- Shallow ETag\r\n- CORS\r\n\r\n### Form Data\r\n\r\n浏览器只能通过 HTTP GET 或 HTTP POST 提交表单数据，但非浏览器客户端也可以使用 HTTP PUT、PATCH 和 DELETE。Servlet API 需要 ServletRequest.getParameter *() 方法只支持 HTTP POST 的表单字段访问。\r\n\r\nspring-web 模块提供 FormContentFilter 去拦截 content type 为 application/x-www-form-urlencoded 的 HTTP PUT, PATCH, 和 DELETE 请求，从请求体读取表单数据，并包装 ServletRequest 让表单数据可以被 ServletRequest.getParameter*() 家族方法可以访问。\r\n\r\n### Forwarded Headers\r\n\r\nRFC 7239 定义代理可以提供关于原始请求信息的转发 HTTP 头。也由其它非标准的头，包括 X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl,  和 X-Forwarded-Prefix。\r\n\r\nForwardedHeaderFilter 基于 Forwarded 头修改主机、端口和 scheme，并移除转发头。\r\n\r\n### Shallow  ETag\r\n\r\nShallowEtagHeaderFilter 过滤器通过缓存写入响应和计算 MD5 散列的内容来创建一个 “shoallow” ETag。下次一样的请求来的时候，比较 If-None-Match 请求头和这个值，如果一样则返回 304（NOT_MODIFIED）。\r\n\r\n### CORS\r\n\r\nSpring MVC 通过对控制器的注释提供了对 CORS 配置的细粒度支持。然而，当使用 Spring Security 时，我们建议依赖内置的 CorsFilter ，必须在 Spring Security 的过滤器链之前排序。参见  CORS 和 CORS FIlter。\r\n\r\n## 注解控制器\r\n\r\nSpring MVC 支持用编程的方式，在有 @Controller 和 @RestController 的组件执行请求映射、请求输入、异常处理。\r\n\r\n```java\r\n@Controller\r\npublic class HelloController {\r\n    \r\n    @GetMapping(\"/hello\")\r\n    public String handle(Model model) {\r\n        model.addAttribute(\"message\", \"Hello World!\");\r\n        return \"index\";\r\n    }\r\n}\r\n```\r\n\r\n这个方法要求一个 Model ，返回一个 String 类型的视图名称。\r\n\r\n### 声明\r\n\r\n可以在 Servlet 的 WebApplicationContext 中用标准的 Spring bean 定义方法定义控制器 bean。@Controller 模式允许自动检测在类路径的 @Component 类并自动注册这些 bean。这个模式也指明它是一个 web 元件。\r\n\r\n为了启用自动检测像 @Controller 这样的 bean，可以在 Java 配置添加组件扫描：\r\n\r\n```java\r\n@Configuration\r\n@ComponentScan(\"org.example.web\")\r\npublic class WebConfig {\r\n    \r\n    // ...\r\n}\r\n```\r\n\r\n也可以在 XML 文件配置：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:p=\"http://www.springframework.org/schema/p\"\r\n       xmlns:context=\"http://www.springframework.org/schema/context\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/context\r\n                           https://www.springframework.org/schema/context/spring-context.xsd\">\r\n    \r\n    <context:component-scan base-package=\"org.example.web\"/>\r\n    \r\n    <!-- ... -->\r\n</beans>\r\n```\r\n\r\n@RestController 是一个组合注解，带有 @Controller 和 @ResponseBody 注解，会在每个方法上内置 @ResponseBody 注解。\r\n\r\n#### AOP 代理\r\n\r\n在某些情况下，您可能需要在运行时用 AOP 代理来装饰控制器。一个例子是，如果您选择直接在控制器上使用 @Transactional 注释。这种情况下，建议使用基于类的代理。这是默认的选择。然而，当控制器必须非 Spring Context 回调的接口时，可能需要显示指定基于类的代理。例如把 `<tx:annotation-driven/>  ` 改成 `<tx:annotation-driven proxy-target-class=\"true\"/>  `。\r\n\r\n### 请求映射\r\n\r\n可以使用 @RequestMapping 注解映射请求到控制器方法。它有很多属性，URL，HTTP 方法，请求参数，请求头，媒体类型。可以在类使用这个注解，表示共享映射。或者在方法注解。\r\n\r\n还有 @RequestMapping 的 HTTP 方法的特定快捷变体：\r\n\r\n- @GetMapping\r\n- @PostMapping\r\n- @PutMapping\r\n- @DeleteMapping\r\n- @PatchMapping  \r\n\r\n大多数控制器方法应该映射到特定的HTTP方法，而不是使用 @RequestMapping，默认情况下 @RequestMapping 匹配所有 HTTP 方法。用这些注解在类上也要有 @RequestMapping。\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/persons\")\r\nclass PersonController {\r\n    \r\n    @GetMapping(\"/{id}\")\r\n    public Person getPerson(@PathVariable Long id) {\r\n        // ...\r\n    }\r\n    \r\n    @PostMapping\r\n    @ResponseStatus(HttpStatus.CREATED)\r\n    public void add(@RequestBody Person person) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n#### URI 模式\r\n\r\n可以使用以下全局模式和通配符：\r\n\r\n- ? 匹配一个字符\r\n- \\* 在一个路径段中匹配 0 或 多个字符\r\n- ** 匹配 0  或多个路径段\r\n\r\n可以用和 @PathVariable 一起使用 URI 变量：\r\n\r\n```java\r\n@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\r\npublic Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\r\n	// ...\r\n}\r\n```\r\n\r\n可以在类或方法上用 URI 变量：\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/owners/{ownerId}\")\r\npublic class OwnerController {\r\n    \r\n    @GetMapping(\"/pets/{petId}\")\r\n    public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\nURI 变量会自动转换成需要的类型或者引发 TypeMismatchException 。默认支持简单类型（int ，long， Date等），可以为其它类型注册支持。\r\n\r\n可以显示给 URI 变量命名（如 @PathVariable(\"customId\")  ），但是当名字一样的时候或使用 debugging 信息编译时可以省略。\r\n\r\n`{varName:regex}  ` 语法表明 URI 变量使用正则表达式，例如给定 URL  “/spring-web-3.0.5 .jar  ”，下面的例子会提取名字、版本和文件后缀：\r\n\r\n```java\r\n@GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\")\r\npublic void handle(@PathVariable String version, @PathVariable String ext) {\r\n    // ...\r\n}\r\n```\r\n\r\n#### 模式比较\r\n\r\n多个模式匹配一个 URL 时，必须找到一个最合适的。这个工作通过 AntPathMatcher.getPatternComparator(String path) 完成。\r\n\r\n一个 URI 变量记 1，一个通配符记 1， 两个通配符记 2。如果它有较低的分数，那么这个个模式就不那么具体了。分数相同的时候会选择比较长的模式，分数和长度一样会选 URI 变量比通配符多的。\r\n\r\n默认的映射模式 (/ \\**) 被排除在得分之外，并且总是排在最后。前缀模式 (如 /public/ ** ) 被认为比其他不具有双通配符的模式更不具体。更多细节看 AntPatternComparator，也可以自定义 PathMatcher 实现。\r\n\r\n#### 后缀匹配\r\n\r\n默认情况下 Spring MVC 执行后缀模式匹配，\"/person\" 可以映射到 \"/person.*\"。文件扩展名用于解释请求的 content type 用于响应（也就是说可以代替 Accept 头）。例如 /person.pdf, /person.xml 等。\r\n\r\n当浏览器用来发送接受难以解释的 Accept 头时，使用这种方式使用文件扩展是必要的。目前，这不再是必要的，使用 Accept 头应该是首选的选择。\r\n\r\n随着时间的推移,使用文件名称扩展已经被证明是有问题的。在使用URI变量、路径参数和URI编码时，它会引起歧义。\r\n\r\n为了完全禁用文件扩展的使用,您必须设置以下两个内容：\r\n\r\n- useSuffixPatternMatching(false)\r\n- favorPathExtension(false)\r\n\r\n如果您必须使用文件扩展，请考虑将其限制为通过 ContentNegotiationConfigurer 的 mediaTypes 属性显式注册扩展的列表。\r\n\r\n#### 后缀匹配和 RFD\r\n\r\nreflected file download （RFD）反射文件下载攻击与 XSS 相似，它依赖于请求输入（例如,查询参数和 URI 变量）反映在响应中。然而，RFD 的攻击并没有将 JavaScript 插入到 HTML 中，而是依赖于浏览器切换来执行下载，并在稍后双击时将响应视为可执行脚本。\r\n\r\n在Spring MVC 中，@ResponseBody 和 ResponseEntity 方法处于危险中，因为它们可以呈现不同的内容类型，客户端可以通过 URL 路径扩展请求。禁用后缀模式匹配和使用路径扩展来进行内容谈判，降低了风险，但不足以防止 RFD 的攻击。\r\n\r\n为了防止 RFD 的攻击，在呈现响应体之前，Spring MVC 添加了一个Content-Disposition:inline;filename=f.xtx 头建议一个固定和安全的下载文件。只有当 URL 路径包含一个文件扩展时才完成，它既不是空白的，也不是在内容谈判中显式注册的。然而，当 URL 直接输入浏览器时，它可能会有副作用。\r\n\r\n在默认情况下，许多常见的路径扩展都是白的。使用自定义 HttpMessageConverter 实现的应用程序可以显式地注册内容协商的文件扩展，以避免为这些扩展添加一个内容配置标题。\r\n\r\n#### Consumable Media Types\r\n\r\n可以用 Content-type 定义更详细的请求类型：\r\n\r\n```java\r\n@PostMapping(path = \"/pets\", consumes = \"application/json\")\r\npublic void addPet(@RequestBody Pet pet) {\r\n    // ...\r\n}\r\n```\r\n\r\n也支持否定表达式，如 `!text/plain` 意思为所有 content-type 除了 `text/plain`。\r\n\r\n可以在类上声明共享 consumes 属性。然而，与大多数其他请求映射属性不同的是，当在类级别使用时，一个方法级别使用属性**覆盖**，而不是扩展类级别的声明。\r\n\r\n提示：MediaType 支持常用的常量，如 APPLICATION_JSON_VALUE 和 APPLICATION_XML_VALUE。\r\n\r\n#### Producible Media Types\r\n\r\n可以用 Accept 请求头并且把 content-type 列在方法的 produces 限制请求映射：\r\n\r\n```java\r\n@GetMapping(path = \"/pets/{petId}\", produces = \"application/json;charset=UTF-8\")\r\n@ResponseBody\r\npublic Pet getPet(@PathVariable String petId) {\r\n    // ...\r\n}\r\n```\r\n\r\n也支持否定表达式。\r\n\r\n类级别声明和 Consumable Media Type 一样。\r\n\r\n#### Parameters, headers\r\n\r\n可以在参数条件限制请求映射。可以用（myParam）表示请求有这个参数，用（!myParam）表示没有这个参数，（myParam=myValue）表示参数 myParam 的值为 myValue。\r\n\r\n```java\r\n@GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\")\r\npublic void findPet(@PathVariable String petId) {\r\n	// ...\r\n}\r\n```\r\n\r\n同样的，可以用请求头来限制：\r\n\r\n```java\r\n@GetMapping(path = \"/pets\", headers = \"myHeader=myValue\")\r\npublic void findPet(@PathVariable String petId) {\r\n	// ...\r\n}\r\n```\r\n\r\n#### HTTP HEAD, OPTIONS\r\n\r\n@GetMapping (和 @RequestMapping(method= HttpMethod.GET)) 支持 HTTP 头部透明地用于请求映射。不需要改变控制器方法。一个响应包装器，应用于 javax.servlet.http.HttpServlet 确保一个内容长度头被设置为写入的字节数（实际上没有写入响应）。\r\n\r\n它也被隐式映射到并支持 HTTP HEAD。HTTP 头请求被处理起来，就好像它是 HTTP GET，除了这样，而不是写入正文，计算字节数，并设置 Content-Length 头。\r\n\r\n默认的，通过设置响应头 Allow 为所有匹配 URL 模式的 @RequestMapping 方法来处理 HTTP OPTIONS。\r\n\r\n对于没有 HTTP 方法声明的 @RequestMapping，允许头的结果是HEAD、POST、PUT、PATCH、DELETE、OPTIONS。控制器方法应该始终声明支持的 HTTP 方法（例如，使用HTTP方法的特定变体：@GetMapping、@PostMapping等）。\r\n\r\n您可以显式地将 @RequestMapping 方法映射到 HTTP 头和 HTTP 选项，但在常见情况下是不必要的。\r\n\r\n#### 自定义注解\r\n\r\nSpring MVC 支持请求映射使用组合注解。这些注解本身带有 @RequestMapping 。\r\n\r\n@GetMapping，@PostMapping,，@PutMapping，@DeleteMapping，和 @PatchMapping 都是组合注解。\r\n\r\nSpring MVC 还支持自定义 request-mapping 属性和自定义 request-matching 逻辑。这是一个更高级的选项，需要子类化RequestMappingHandlerMapping 并重写  getCustomMethodCondition 方法，在那里您可以查看自定义属性并返回您自己的请求条件。\r\n\r\n#### 显式注册\r\n\r\n可以通过编程注册处理器方法，用于动态注册或高级情况，例如同一个处理器的不同实例处理不同 URL。注册示例：\r\n\r\n```java\r\n@Configuration\r\npublic class MyConfig {\r\n    \r\n    @Autowired\r\n    public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) ① \r\n        							throws NoSuchMethodException {\r\n        RequestMappingInfo info = RequestMappingInfo\r\n            .paths(\"/user/{id}\").methods(RequestMethod.GET).build(); ②\r\n            Method method = UserHandler.class.getMethod(\"getUser\", Long.class); ③\r\n                mapping.registerMapping(info, handler, method); ④\r\n    }\r\n}\r\n```\r\n\r\n①  注入目标处理器和处理器程序映射。\r\n\r\n②  准备请求映射元数据\r\n\r\n③  获得处理器方法\r\n\r\n④  注册\r\n\r\n### 处理程序\r\n\r\n@RequestMapping 处理程序有灵活的前面，可以从支持的控制器方法参数和返回值中选择。\r\n\r\n#### 方法参数\r\n\r\n下面这个表描述了支持的控制器方法参数。在带有 required 属性的注解中，方法参数支持 JDK 8 的 `java.util.Optional` ，它和 required=false 等价。\r\n\r\n| Controller method argument                                   | Description                                                  |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| WebRequest，NativeWebRequest                                 | 一般访问请求参数和请求和会话属性，而不直接使用Servlet API。  |\r\n| javax.servlet.ServletRequest, javax.servlet.ServletResponse  | 选择任何特定的请求或响应类型——例如，ServletRequest,HttpServletRequest,或Spring 的 MultipartRequest,MultipartHttpServletRequest。 |\r\n| javax.servlet.http.HttpSession                               | 这样的参数永远不会为空。注意会话访问不是线程安全的。如果允许多个请求同时访问会话,则考虑设置RequestMappingHandlerAdapter 实例的 synchronizeOnSession 的 flag 为 true。 |\r\n| javax.servlet.http.PushBuilder                               | Servlet 4.0 push builder API 用于编程 HTTP/2 资源推送。注意，如果客户机不支持 HTTP/2 特性，那么注入的 PushBuilder 实例就可以为空。 |\r\n| java.security.Principal                                      | 目前已验证的用户——可能是一个特定的主要执行类，如果已知的话。 |\r\n| HttpMethod                                                   | 请求的 HTTP 方法。                                           |\r\n| java.util.Locale                                             | 当前请求的地区，由 LocaleResolver 决定。                     |\r\n| java.util.TimeZone + java.time.ZoneId                        | 当前请求的时区，由 LocaleContextResovler 决定。              |\r\n| java.io.InputStream, java.io.Reader                          | 为了访问由 Servlet API 暴露的原始请求体。                    |\r\n| java.io.OutputStream, java.io.Writer                         | 为了访问由 Servlet API 暴露的原始响应体。                    |\r\n| @PathVariable                                                | 为了访问 URI 模板中变量                                      |\r\n| @MatrixVariable                                              | 为了访问 URI 路径段中的 name-value 对。                      |\r\n| @RequestParam                                                | 为了访问 Servlet 请求参数，包括 multipart 文件。参数值转换为声明的方法参数类型。请参见 @RequestParam 和 Multipart。可选的，用于简单的参数值。 |\r\n| @RequestHeader                                               | 为了访问请求头，请求头的值会转换成声明的参数类型。参见 @RequestHeader。 |\r\n| @CookieValue                                                 | 为了访问 cookie，cookies 的值会转换成声明的参数类型。参见 @CookieValue。 |\r\n| @RequestBody                                                 | 为了访问 HTTP 请求体，请求体内容会用 HttpMessageConverter 的实现转换成声明的参数类型。参见 @RequestBody。 |\r\n| HttpEntity\\<B>                                               | 为了访问请求头和请求体，请求体会用 HttpMessageConverter 转换。参见 HttpEntity。 |\r\n| @RequestPart                                                 | 为了访问请求的 multipart/form-data 一部分，HttpMessageConverter 将该部分的主体转换。 |\r\n| java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap | 为了访问在 HTML 控制器中使用的模型，并将其暴露于模板作为视图呈现的一部分。 |\r\n| RedirectAttributes                                           | 在重定向指定属性（即被附加到查询字符串）和 flash 暂时保存 flash 属性，直到重定向请求后。参见 Redirec tAttributes 和 Flash Attributes。 |\r\n| @ModelAttribute                                              | 为了访问模型（model）中存在的属性（如果不存在就实例化），可以使用数据绑定和验证。请参见@ModelAttribute 以及 Model 和 DataBinder。 |\r\n| Errors, BindingResult                                        | 访问由于验证和数据绑定到命令对象（@ModelAttribute 参数）的错误 和 由于验证 @RequestBody 或 @RequestPart 参数的错误。您必须在经过验证的方法参数后立即声明一个 Errors 或者BindingResult 参数。 |\r\n| SessionStatus + class-level @SessionAttributes               | 为标记表单处理完成，它触发通过类级 @SessionAttribute 注解声明的会话属性的清理。参见 @SessionAttributes。 |\r\n| UriComponentsBuilder                                         | 准备一个相对于当前请求的主机、端口、scheme、context path 和 servlet 映射的文字部分的 URL。参见 URI Links。 |\r\n| @SessionAttribute                                            | 为了访问任何会话属性，与在类级 @SessionAttribute 声明的结果中存储的 model 属性相反。 |\r\n| @RequestAttribute                                            | 访问请求属性，参见 @RequestAttribute。                       |\r\n| Any other argument                                           | 如果方法参数与表中的任何前面的值不匹配，并且是一个简单类型（由 BeanUtil#isSimpleProperty 决定），会作为 @RequestParam 解析。其它情况会作为 @ModelAttribute 解析。 |\r\n\r\n#### 返回值\r\n\r\n下面的表描述控制器方法支持的的返回类型。\r\n\r\n| Controller method return value                               | Description                                                  |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| @ResponseBody                                                | 返回值被 HttpMessageConverter 的实现转换并写到 response。    |\r\n| HttpEntity\\<B>, ResponseEntity\\<B>                           | 指定完整响应（包括HTTP header 和 body）的返回值将通过HttpMessageConverter 的实现转换，并写入响应。参见 ResponseEntity。 |\r\n| HttpHeaders                                                  | 只返回响应头，不返回响应体。                                 |\r\n| String                                                       | 一个会被 ViewResolver 实现解析的视图名称，隐含由命令对象和 @ModelAttribute 方法决定的 model。处理程序方法还可以通过声明模型参数（见 Explicit Registrations）来编程地丰富模型。 |\r\n| View                                                         | 一个用于呈现的视图实例，隐含 model（和上面的一样）。         |\r\n| java.util.Map, org.springframework.ui.Model                  | 属性被添加到隐式 model，视图名称由 RequestViewNameTranslator 隐式决定。 |\r\n| @ModelAttribute                                              | 属性被添加到 model，视图名称由 RequestViewNameTranslator 隐式决定。可选的。 |\r\n| ModelAndView object                                          | 视图和名称属性，可选的响应状态。                             |\r\n| void                                                         | 方法返回值为 void （或返回 null）认为该方法已经完全处理了请求，如果还有 ServletResponse、OutputStream 参数或 @ResponseStatus 注解。这和做一个 positive ETag 或检查 lastModified 时间戳一样。如果前面的都不对，那表明没有响应体或者返回默认的视图名称。 |\r\n| DeferredResult\\<V>                                           | 从任何线程中产生任何前面的返回值——例如，由于一些事件或回调的结果。 |\r\n| Callable\\<V>                                                 | 在 Spring MVC管理的线程中，生成上述返回值。                  |\r\n| ListenableFuture\\<V>, java.util.concurrent.CompletionStage\\<V>, java.util.concurrent.CompletableFuture\\<V> | 为了方便，代替 DeferredResult。                              |\r\n| ResponseBodyEmitter, SseEmitter                              | 使用 HttpMessageConverter 的实现转换，用对象流异步的写入响应。也支持 ResponseEntity 的 body。参见 Asynchronous Requests 和 HTTP Streaming。 |\r\n| StreamingResponseBody                                        | 异步的写到响应 OutputStream。也支持 ResponseEntity 的 body。参见 Asynchronous Requests 和 HTTP Streaming。 |\r\n| Reactive types—Reactor, RxJava, or others through ReactiveAdapterRegistry | 用 multi-value 流代替 DeferredResult，收集到一个列表。对于流场景（例如，text/envet-stream、application/json+stream），会使用  SeeEmitter 和 ResponseBodyEmitter 代替，在一个 Spring MVC 管理的线程和后压力上执行 ServletOutputStream 阻塞 I/O ，以防止每个写入的完成。 |\r\n| Any other return value                                       | 所有不在上面的返回值，String 或 void 被视为视图名称。简单类型（由 BeanUtil#isSimpleProperty 决定）还未解决。 |\r\n\r\n#### 类型转换\r\n\r\n在控制器方法参数输入为基于 String 的参数（如：@RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, 和 @CookieValue）时，可以要求参数转换成其它类型。\r\n\r\n在这种情况，类型转换是基于配置的转换器自动应用的。默认情况，支持简单类型（int，long，Date 或其它）。可以通过 WebDataBinder 或用 FormattingConversionService 注册 Formatters 自定义转换器。参见 Spring Field Formatting。\r\n\r\n#### Matrix Variables\r\n\r\nRFC 3986 讨论路径段中的名称-值对。在 Spring MVC 中，我们将这些变量称为“矩阵变量”，它基于Tim Berners-Lee 的 “old post”，但也可以称为URI路径参数。\r\n\r\nMatrix 变量可以出现在任意路径段，每个变量用分号隔开，多个值用逗号隔开（例如，/cars;color=red,green;year=2012 ）。多个值也可以用多个变量名（例如，color=red;color=green;color=blue  ）。\r\n\r\n　如果希望 URL 包含变量，控制器方法的请求映射必须使用 URI 变量来屏蔽变量内容，并确保请求可以成功地独立于矩阵变量顺序和存在。例如：\r\n\r\n```java\r\n// GET /pets/42;q=11;r=22\r\n\r\n@GetMapping(\"/pets/{petId}\")\r\npublic void findPet(@PathVariable String petId, @MatrixVariable int q) {\r\n    \r\n    // petId == 42\r\n    // q == 11\r\n}\r\n```\r\n\r\n考虑到所有路径段都可能包含矩阵变量，有时需要消除歧义。\r\n\r\n```java\r\n// GET /owners/42;q=11/pets/21;q=22\r\n\r\n@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\r\npublic void findPet(\r\n    @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1,\r\n    @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) {\r\n    // q1 == 11\r\n    // q2 == 22\r\n}\r\n```\r\n\r\n矩阵变量可以定义为可选的和指定的默认值：\r\n\r\n```java\r\n// GET /pets/42\r\n\r\n@GetMapping(\"/pets/{petId}\")\r\npublic void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) {\r\n    // q == 1\r\n}\r\n```\r\n\r\n为了获取所有矩阵变量，可以使用 MultiValueMap：\r\n\r\n```java\r\n// GET /owners/42;q=11;r=12/pets/21;q=22;s=23\r\n\r\n@GetMapping(\"/owners/{ownerId}/pets/{petId}\")\r\npublic void findPet(\r\n    @MatrixVariable MultiValueMap<String, String> matrixVars,\r\n    @MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String>\r\n    petMatrixVars) {\r\n    // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23]\r\n    // petMatrixVars: [\"q\" : 22, \"s\" : 23]\r\n}\r\n```\r\n\r\n注意，**想要用矩阵变量需要启用**。在 MVC Java 配置中，需要通过 Path Matching 设置 UrlPathHelper 的 removeSemicolonContent=false。在 MVC XML 命名空间设置 <mvc:annotation-driven enable-matrix-variables=\"true\"/> 。\r\n\r\n#### @RequestParam\r\n\r\n可以用 @RequestParam 注解绑定 Servlet 请求参数（也就是查询参数或表单数据）到处理器的方法参数：\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/pets\")\r\npublic class EditPetForm {\r\n\r\n    // ...\r\n\r\n    @GetMapping\r\n    public String setupForm(@RequestParam(\"petId\") int petId, Model model) {\r\n        Pet pet = this.clinic.loadPet(petId);\r\n        model.addAttribute(\"pet\", pet);\r\n        return \"petForm\";\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n默认方法参数是必须有的，但是可以通过指定 @RequestParam 的 required 为 false 或者使用 `java.util.Optional` 来让它可选。\r\n\r\n如果目标方法参数不是 String，会自动应用类型转换。\r\n\r\n声明参数类型为数组或 list 可以解析参数名一样的多个参数值。\r\n\r\n当 @RequestParam 和 Map\\<String, String> 或 MultiValueMap<String, String> 一起声明又没有在注解指定参数名的时候，map 会填充所有请求参数。\r\n\r\n#### @RequestHeader\r\n\r\n可以使用 @RequestHeader 注解来绑定请求头和方法参数。\r\n\r\n如果有这个请求：\r\n\r\n```\r\nHost 				localhost:8080\r\nAccept 				text/html,application/xhtml+xml,application/xml;q=0.9\r\nAccept-Language 	fr,en-gb;q=0.7,en;q=0.3\r\nAccept-Encoding 	gzip,deflate\r\nAccept-Charset 		ISO-8859-1,utf-8;q=0.7,*;q=0.7\r\nKeep-Alive 			300\r\n```\r\n\r\n下面的例子获取 Accept-Encoding 和 Keep-Alive：\r\n\r\n```java\r\n@GetMapping(\"/demo\")\r\npublic void handle(\r\n    @RequestHeader(\"Accept-Encoding\") String encoding,\r\n    @RequestHeader(\"Keep-Alive\") long keepAlive) {\r\n    //...\r\n                                                 }\r\n```\r\n\r\n如果目标方法类型不是 String，会自动应用类型转换。\r\n\r\n如果 @RequestHeader 用在 Map<String, String>, MultiValueMap<String, String>, 或 HttpHeaders 参数，会填充请求头的所有值。 \r\n\r\n提示：内置支持转换逗号分隔符到 String 数组、集合或其他已知类型转换。例如 @RequestHeader(\"Accept\") 参数类型可以是 String 也可以是 String[] 或 List\\<String>。\r\n\r\n#### @CookieValue\r\n\r\n可以使用 @CookieValue 注解绑定 HTTP cookie 到方法参数。\r\n\r\n例如有 cookie：\r\n\r\n```\r\nJSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84\r\n```\r\n\r\n可以这样获取 cookie 值：\r\n\r\n```java\r\n@GetMapping(\"/demo\")\r\npublic void handle(@CookieValue(\"JSESSIONID\") String cookie) {\r\n    //...\r\n}\r\n```\r\n\r\n如果目标方法参数不是 String，会自定应用类型转换。\r\n\r\n#### @ModelAttribute\r\n\r\n可以用 @ModelAttribute 注解访问 model 中的熟悉，如果不存在会实例化。熟悉名和 HTTP 请求参数名相同时会叠加值。这称为数据绑定。\r\n\r\n```java\r\n@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\r\npublic String processSubmit(@ModelAttribute Pet pet) { }\r\n```\r\n\r\n上面的 Pet 会被按照下面解析：\r\n\r\n- 来自 model。\r\n- 来自 HTTP session 通过 @SessionAttributes。\r\n- 来自 URI 路径变量，通过转换器转换。\r\n- 来自调用默认构造方法。\r\n- 来自调用参数和 Servlet 请求参数匹配的“主要”构造方法。参数名由 JavaBeans 的 @ConstructorProperties 或 运行时保留的字节码决定。\r\n\r\n虽然使用 Model 来填充模型的属性是很常见的，但另一种选择是与 URI 路径变量结合在 Converter< String, T > 上。在下面这个例子，模型属性名匹配 URI 路径变量，这个 Account 通过已经注册的 Converter<String, Account> 转换加载。\r\n\r\n```java\r\n@PutMapping(\"/accounts/{account}\")\r\npublic String save(@ModelAttribute(\"account\") Account account) {\r\n	// ...\r\n}\r\n```\r\n\r\n获得模型属性实例后，会开始数据绑定。WebDataBinder 类匹配 Servlet 请求属性名和目标对象字段名。\r\n\r\n数据绑定可能会发生错误，默认情况下抛出 BindException。然而，可以紧贴 @ModelAttribute 添加 BindingResult 参数。\r\n\r\n```java\r\n@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\r\npublic String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result)\r\n{\r\n    if (result.hasErrors()) {\r\n        return \"petForm\";\r\n    }\r\n // ...\r\n}\r\n```\r\n\r\n有些情况不需要数据绑定，你可以注入 Model 到控制器并且直接访问，或者设置 @ModelAttribute(binding=false)。\r\n\r\n```java\r\n@ModelAttribute\r\npublic AccountForm setUpForm() {\r\n    return new AccountForm();\r\n}\r\n\r\n@ModelAttribute\r\npublic Account findAccount(@PathVariable String accountId) {\r\n    return accountRepository.findOne(accountId);\r\n}\r\n\r\n@PostMapping(\"update\")\r\npublic String update(@Valid AccountForm form, BindingResult result,\r\n                     @ModelAttribute(binding=false) Account account) {\r\n    // ...\r\n}\r\n```\r\n\r\n可以通过添加 `javax.validation.Valid` 注解或 Spring 的 @Validated 注解以在数据绑定后自动验证。\r\n\r\n```java\r\n@PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\")\r\npublic String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult\r\n                            result) {\r\n    if (result.hasErrors()) {\r\n        return \"petForm\";\r\n    }\r\n     // ...\r\n}\r\n```\r\n\r\n注意，使用 @ModelAttribute 是可选的。默认情况，所有不是简单类型（由 BeanUtils#isSimpleProperty 决定）或被其它解析器解析的参数会被视为 @ModelAttribute。\r\n\r\n#### @SessionAttributes\r\n\r\n@SessionAttributes 用于在请求之间的 HTTP Servlet 会话中存储模型属性。它是一个类型级别的注释，它声明特定控制器使用的会话属性。这通常会列出模型属性的名称或模型属性的类型，这些属性应该在会话中透明地存储在随后的请求中。\r\n\r\n```java\r\n@Controller\r\n@SessionAttributes(\"pet\")\r\npublic class EditPetForm {\r\n	// ...\r\n}\r\n```\r\n\r\n第一次请求的时候，名为 pet 的 model 属性被添加到 model 中。他会自定保存到 HTTP Servlet session 中。一直到其它处理方法用 SessionStatus 方法参数清除储存。\r\n\r\n```java\r\n@Controller\r\n@SessionAttributes(\"pet\")\r\n    public class EditPetForm {\r\n        // ...\r\n        @PostMapping(\"/pets/{id}\")\r\n        public String handle(Pet pet, BindingResult errors, SessionStatus status) {\r\n            if (errors.hasErrors) {\r\n                // ...\r\n            }\r\n            status.setComplete();\r\n                // ...\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n#### @SeessionAttribute\r\n\r\n如果要访问预先存在的被全局管理的 session 属性（也就是其它 controller），可以在方法参数使用  @SessionAttribute 注解：\r\n\r\n```java\r\n@RequestMapping(\"/\")\r\npublic String handle(@SessionAttribute User user) {\r\n    // ...\r\n}\r\n```\r\n\r\n对于需要添加或删除 session 属性的用例，请考虑注入`org.springframework.web.context.request.WebRequest` 或 `javax.servlet.http.HttpSession` 到控制器方法。\r\n\r\n对于在 session 中临时储存模型属性，可以考虑用 @SessionAttributes 。\r\n\r\n#### @RequestAttribute\r\n\r\n和 @SessionAttribute 相似，你可以用 @RequestAttribute 注解来访问预先存在请求的属性（例如，通过 Filter 或 HandlerInterceptor 创建的）：\r\n\r\n```java\r\n@GetMapping(\"/\")\r\npublic String handle(@RequestAttribute Client client) {\r\n	// ...\r\n}\r\n```\r\n\r\n#### Redirect Attributes\r\n\r\n默认情况下，所有模型属性都被认为是在重定向 URL 中作为 URI 模板变量公开的。在其余的属性中，原始类型或集合或原始类型的数组被自动地附加为查询参数。\r\n\r\n如果为重定向准备了一个模型实例，将原始类型属性附加为查询参数可以是预期的结果。然而，在模型控制器中，模型可以包含为渲染目的添加的额外属性(例如，值字段值)。为了避免在 URL 中出现这样的属性的可能性，@RequestMapping 方法可以声明一个类型RedirectAttributebs 的参数，并使用它指定要向 RedirectView 提供的精确属性。如果该方法执行重定向，则使用 RedirectAttributes 的内容。否则，使用模型的内容。\r\n\r\nRequestMappingHandlerAdapter 提供名为 ignoreDefaultModelOnRedirect 的标签，你可以用它指明如果方法执行重定向，就不应该用默认的 Model 内容。取而代之的是，处理器方法应该声明一个 RedirectAttributes 类型的属性或者不给属性 RedirectView。MVC 名称空间和 MVC Java 配置都将此标志设置为 false，以保持向后兼容性。然而，对于新的应用程序，我们建议将其设置为 true。\r\n\r\n请注意，在扩展重定向 URL 时，可以自动使用当前请求的 URI 模板变量，而且您不需要通过模型或 RedirectAttributes 显式地添加它们。\r\n\r\n```java\r\n@PostMapping(\"/files/{path}\")\r\npublic String upload(...) {\r\n	// ...\r\n	return \"redirect:files/{path}\";\r\n}\r\n```\r\n\r\n其它传递数据给重定向目标的方式是通过 flash 属性。不像其它重定向属性，flash 属性被保存到 HTTP session（因此，不会出现在 URL）。参见 Flash Attributes。\r\n\r\n#### Flash Attributes\r\n\r\nFlash 属性提供一种从一个请求保存属性在其它地方使用的方式。重定向的时候很常见。Flash 属性在重定向前被暂时保存（通常保存在 session），在重定向后被提供给请求然后立即被删除。\r\n\r\nSpring MVC 有两种主要的 flash 属性抽象支持。FlashMap 用来保存 flash 属性，FlashMapManager 保存、取出和管理 FlashMap 实例。\r\n\r\nFlash 属性默认是开启的，不需要显示启用。然而，如果不使用，它将不会导致 HTTP 会话的创建。在每个请求中，都有一个来自之前的请求（如果有）的“输入” FlashMap，同时又一个为随后请求保存的“输出” FlashMap。在 Spring MVC，可以在任何地方通过 RequestContextUtils 的静态方法访问 FlashMap 实例。\r\n\r\n一般来说，控制器不需要直接使用 FlashMap。相反，@RequestMapping 方法可以接受类型 RedirectAttributes 的参数，并使用它为重定向场景添加 flash 属性。通过 RedirectAttributes 添加的 Flash 属性自动传播到“输出” FlashMap。类似地，在重定向之后，从“输入” FlashMap 中属性的属性自动添加到服务于目标 URL 的控制器的模型中。\r\n\r\n#### Multipart\r\n\r\n在 MultipartResolver 被启用后，multipart/form-data 的 POST 请求被解析并且可以作为常规参数访问。下面的例子是访问一个常规表单数据和一个文件上传：\r\n\r\n```java\r\n@Controller\r\npublic class FileUploadController {\r\n    \r\n    @PostMapping(\"/form\")\r\n    public String handleFormUpload(@RequestParam(\"name\") String name,\r\n                                   @RequestParam(\"file\") MultipartFile file) {\r\n        if (!file.isEmpty()) {\r\n            byte[] bytes = file.getBytes();\r\n            // store the bytes somewhere\r\n            return \"redirect:uploadSuccess\";\r\n        }\r\n        return \"redirect:uploadFailure\";\r\n    }\r\n}\r\n```\r\n\r\n声明参数类型为 List\\<MultipartFile> 允许解析同参数名的 multipart files。\r\n\r\n当 @RequestParam 注解和 Map<String, MutipartFile> 或 MultiValueMap<String, MutipartFile> 的时候，如果没有在注解中指定参数名，那么 map 会填充所有参数名的 multipart files。\r\n\r\n提示：在 Servlet 3.0 解析 multipart，也可以用 `javax.serlvet.http.Part` 代替 Spring 的 MultipartFile 作为方法参数。\r\n\r\n也可以用 multipart 的内容作为数据的一部分绑定到 command object。例如前面例子的表单域和文件可以是表单对象的域。\r\n\r\n```java\r\nclass MyForm {\r\n    \r\n    private String name;\r\n    private MultipartFile file;\r\n    // ...\r\n}\r\n\r\n@Controller\r\npublic class FileUploadController {\r\n    @PostMapping(\"/form\")\r\n    public String handleFormUpload(MyForm form, BindingResult errors) {\r\n        if (!form.getFile().isEmpty()) {\r\n            byte[] bytes = form.getFile().getBytes();\r\n            // store the bytes somewhere\r\n            return \"redirect:uploadSuccess\";\r\n        }\r\n        return \"redirect:uploadFailure\";\r\n    }\r\n}\r\n```\r\n\r\nMultipart 请求也可以在 RESTful 服务场景中从非浏览器客户端提交。下面的例子用 JSON 提交文件：\r\n\r\n```\r\nPOST /someUrl\r\nContent-Type: multipart/mixed\r\n\r\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\r\nContent-Disposition: form-data; name=\"meta-data\"\r\nContent-Type: application/json; charset=UTF-8\r\nContent-Transfer-Encoding: 8bit\r\n\r\n{\r\n\"name\": \"value\"\r\n}\r\n--edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp\r\nContent-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\"\r\nContent-Type: text/xml\r\nContent-Transfer-Encoding: 8bit\r\n... File Data ...\r\n```\r\n\r\n可以用 @RequsetParam 访问 “meta-data”部分作为 String，但是你可能想要从 JSON 反序列化（像 @RequestBody）。用 @RequestPart 注解访问用 HttpMessageConverter 转换后的 multipart：\r\n\r\n```java\r\n@PostMapping(\"/\")\r\npublic String handle(@RequestPart(\"meta-data\") MetaData metadata,\r\n                     @RequestPart(\"file-data\") MultipartFile file) {\r\n    // ...\r\n}\r\n```\r\n\r\n你可以用 @RequestPart 组合 `java.validation.Valid` 或者 Spring 的 `@Validated` 注解，它们都导致标准 Bean 验证被应用。默认的，验证错误会引起 MethodArgumentNotValidException，并且返回 400（BAD_REQUEST）响应。或者，可以通过 Errors 或 BindingResult 参数在处理器内处理验证异常：\r\n\r\n```java\r\n@PostMapping(\"/\")\r\npublic String handle(@Valid @RequestPart(\"meta-data\") MetaData metadata,\r\n                     BindingResult result) {\r\n    // ...\r\n}\r\n```\r\n\r\n#### @RequestBody\r\n\r\n可以使用 @RequestBody 注解去读取请求体或通过 HttpMessageConverter 反序列到对象。下面是使用 @RequestBody 的例子：\r\n\r\n```java\r\n@PostMapping(\"/accounts\")\r\npublic void handle(@RequestBody Account account) {\r\n    // ...\r\n}\r\n```\r\n\r\n可以用 MVC Config 的 Message Converters 选项配置或自定义消息转换。\r\n\r\n消息验证和前面的 Multipart 消息验证一样。如：\r\n\r\n```java\r\n@PostMapping(\"/accounts\")\r\npublic void handle(@Valid @RequestBody Account account, BindingResult result) {\r\n	// ...\r\n}\r\n```\r\n\r\n#### HttpEntity\r\n\r\nHttpEntity 或多或少与使用 @RequestBody 相同，但基于一个容器对象，它公开请求头和主体。\r\n\r\n```java\r\n@PostMapping(\"/accounts\")\r\npublic void handle(HttpEntity<Account> entity) {\r\n	// ...\r\n}\r\n```\r\n\r\n#### @ResponseBody\r\n\r\n您可以在方法上使用 @ResponseBody 注释，以通过HttpMessageConverter 将返回序列化到响应体。\r\n\r\n```java\r\n@GetMapping(\"/accounts/{id}\")\r\n@ResponseBody\r\npublic Account handle() {\r\n	// ...\r\n}\r\n```\r\n\r\n@ResponseBody 也支持类级注解，在这种情况下，它是由所有控制器方法继承的。这是 @RestController 的作用，它只是一个与 @Controller 和 @ResponseBody 标记的元注解。\r\n\r\n您可以使用反应型使用 @ResponseBody。参见 Asynchronous 和Reactive Types。\r\n\r\n可以用 MVC Config 的 Message Converters 选项配置或自定义消息转换。\r\n\r\n您可以将 @ResponseBody 方法与 JSON 序列化视图相结合。参见 Jackson JSON。\r\n\r\n#### ResponseEntity\r\n\r\n和 @ResponseBody 相似，但是 ResponseEntity 包含状态和头。\r\n\r\n```java\r\n@GetMapping(\"/something\")\r\npublic ResponseEntity<String> handle() {\r\n    String body = ... ;\r\n    String etag = ... ;\r\n    return ResponseEntity.ok().eTag(etag).build(body);\r\n}\r\n```\r\n\r\nSpring MVC 支持使用单值反应类型来异步的生成 ResponseEntity，以及/或单个和多值的反应型生成响应体。\r\n\r\n#### Jackson JSON\r\n\r\nSpring MVC 提供内建的 Jackson\'s Serialization Views，允许程序对象所有字段的子集。为了和 @ResponseBody 或 ResponseEntity 控制器方法一起使用，你可以用 Jackson 的 @JsonView 注解来激活序列化视图类。\r\n\r\n```java\r\n@RestController\r\npublic class UserController {\r\n    \r\n    @GetMapping(\"/user\")\r\n    @JsonView(User.WithoutPasswordView.class)\r\n    public User getUser() {\r\n        return new User(\"eric\", \"7!jd#h23\");\r\n    }\r\n}\r\n\r\npublic class User {\r\n    \r\n    public interface WithoutPasswordView {};\r\n    public interface WithPasswordView extends WithoutPasswordView {};\r\n    private String username;\r\n    private String password;\r\n    \r\n    public User() {\r\n    }\r\n    public User(String username, String password) {\r\n        this.username = username;\r\n        this.password = password;\r\n    }\r\n    @JsonView(WithoutPasswordView.class)\r\n    public String getUsername() {\r\n        return this.username;\r\n    }\r\n    @JsonView(WithPasswordView.class)\r\n    public String getPassword() {\r\n        return this.password;\r\n    }\r\n}\r\n```\r\n\r\n*提示：＠JsonView 允许数组视图类，但是在一个控制器方法只能指定一个。如果需要激活多个视图，可以使用合成接口。*\r\n\r\n如果你想以编程方式完成上述操作，用 MappingJacsonValue 包装返回值代替 @JsonView 注解。\r\n\r\n```java\r\n@RestController\r\npublic class UserController {\r\n    \r\n    @GetMapping(\"/user\")\r\n    public MappingJacksonValue getUser() {\r\n        User user = new User(\"eric\", \"7!jd#h23\");\r\n        MappingJacksonValue value = new MappingJacksonValue(user);\r\n        value.setSerializationView(User.WithoutPasswordView.class);\r\n        return value;\r\n    }\r\n}\r\n```\r\n\r\n对于依赖视图解析的控制器,您可以将序列化视图类添加到模型中：\r\n\r\n```java\r\n@Controller\r\npublic class UserController extends AbstractController {\r\n    \r\n    @GetMapping(\"/user\")\r\n    public String getUser(Model model) {\r\n        model.addAttribute(\"user\", new User(\"eric\", \"7!jd#h23\"));\r\n        model.addAttribute(JsonView.class.getName(), User.WithoutPasswordView.class);\r\n        return \"userView\";\r\n    }\r\n}\r\n```\r\n\r\n### Model\r\n\r\n可以使用 @ModelAttribute 注解：\r\n\r\n- 在 @RequestMapping 方法的参数，用来创建或访问来自 model 的对象并且通过 WebDataBinder 绑定到请求。\r\n- 在 @Controller 或 @ControllerAdvice 类作为方法注解，帮助在所有 @RequestMapping 方法被调用前初始化 model 。\r\n- 在 @RequestMapping 方法标记它的返回值作为 model 属性。\r\n\r\n一个 controller 可以有任意数量个 @ModelAttribute 方法。所有这些方法在同一个控制器的 @RequestMapping 方法之前调用的。@ModelAttribute 方法也可以通过 @ControllerAdvice 跨控制器共享。\r\n\r\n@ModelAttribute 有灵活的方法签名。它们支持很多一样参数的 @RequestMapping 方法，除了 @ModelAttribute 本身或其它和请求体相关的。\r\n\r\n```java\r\n@ModelAttribute\r\npublic void populateModel(@RequestParam String number, Model model) {\r\n    model.addAttribute(accountRepository.findAccount(number));\r\n    // add more ...\r\n}\r\n```\r\n\r\n下面的只添加一个属性：\r\n\r\n```java\r\n@ModelAttribute\r\npublic Account addAccount(@RequestParam String number) {\r\n	return accountRepository.findAccount(number);\r\n}\r\n```\r\n\r\n提示：当 name 没有明确指出时，默认或选择基于对象类型的名字，在 Conventions 的 javadoc 中解释。可以用重载的 addAttribute 方法或在 @ModelAttribute 的属性中（给返回值）指定名字。\r\n\r\n也可以用在 @RequestMapping 方法，在这种情况下， @RequestMapping 方法的返回值会被解释为 model 属性。这通常是不需要的，因为它是 HTML 控制器中的默认行为，除非返回值是一个字符串，会被解释为一个视图名。@ModelAttribute 还可以自定义模型属性名。\r\n\r\n```java\r\n@GetMapping(\"/accounts/{id}\")\r\n@ModelAttribute(\"myAccount\")\r\npublic Account handle() {\r\n	// ...\r\n	return account;\r\n}\r\n```\r\n\r\n### DataBinder\r\n\r\n@Controller 或 @ControllerAdvice 类可以有 @InitBinder 方法初始化 WebDataBinder 实例，这可以，依次：\r\n\r\n- 绑定请求参数（也就是表单或查询数据）到 model 对象。\r\n- 转换基于 String 的请求值（例如 请求参数，路径变量，请求头，cookies或其他）为控制器方法参数的目标类型。\r\n- 在呈现 HTML 表单时，将对象值格式化为字符串值。\r\n\r\n@InitBinder 方法可以注册控制器特定的 `java.bean.PropertyEditor` 或 Spring Converter 和 Formatter 组件。此外，可以用 MVC config 在全局共享 FormattingConversionService 注册 Converter 和 Formatter。\r\n\r\n在@RequestMapping 方法（除了 @ModelAttribute 参数），@InitBinder 方法支持多个同名参数。通常，它们用 WebDataBinder 声明参数并且返回值为 void。\r\n\r\n```java\r\n@Controller\r\npublic class FormController {\r\n    \r\n    @InitBinder\r\n    public void initBinder(WebDataBinder binder) {\r\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\");\r\n        dateFormat.setLenient(false);\r\n        binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false));\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n或者，当你通过共享 FormattingConversionService 使用基于 Formatter 设置时，你可以再使用接近的和注册控制器特定的 Formatter 实现：\r\n\r\n```java\r\n@Controller\r\npublic class FormController {\r\n    \r\n    @InitBinder\r\n    protected void initBinder(WebDataBinder binder) {\r\n        binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\"));\r\n    }\r\n    // ...\r\n}\r\n```\r\n\r\n### Exceptions\r\n\r\n@Controller 或 @ControllerAdvice 类可以有 @ExceptionHandler 方法去处理来自控制器方法的异常：\r\n\r\n```java\r\n@Controller\r\npublic class SimpleController {\r\n    \r\n// ...\r\n    \r\n    @ExceptionHandler\r\n    public ResponseEntity<String> handle(IOException ex) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n这个异常可能与被传播的顶级异常（即被抛出的直接 IOException）相匹配，或者与在顶级包装异常中立即被抛出的异常匹配（例如，包装在 IllegalStateException 的 IOException）。\r\n\r\n对于匹配异常类型，最好将目标异常声明为方法参数，如前面的示例所示。当多个异常方法匹配时，一个根异常匹配通常倾向于一个导致异常匹配。更具体地说，除了抛出的异常类型，还使用了 ExceptionDepthComparator 来排序异常。\r\n\r\n或者，这个注解声明可以缩小异常类型声明：\r\n\r\n```java\r\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\r\npublic ResponseEntity<String> handle(IOException ex) {\r\n	// ...\r\n}\r\n```\r\n\r\n甚至可以列出特定异常类型，然后用非常通用的异常作为参数类型：\r\n\r\n```java\r\n@ExceptionHandler({FileSystemException.class, RemoteException.class})\r\npublic ResponseEntity<String> handle(Exception ex) {\r\n	// ...\r\n}\r\n```\r\n\r\n建议在方法参数种尽可能具体，减少根异常或引起异常类型错误的可能。考虑把匹配多个异常类型的方法分解成多个匹配单一异常的方法。\r\n\r\n一个 @ExceptionHandler 方法可以选择重新抛出异常到原始表单，这对你只匹配根异常或在特定上下文中感兴趣的场景很有用。一个重新抛出的异常是通过其余的解析链传播的。\r\n\r\nSpring MVC 支持 @ExceptionHandler 方法是基于 DispatcherServlet 等级和 HandlerExceptionResolver 机制的。\r\n\r\n#### 方法参数\r\n\r\n@ExceptionHandler 支持下列参数：\r\n\r\n| 方法参数                                                     | 描述                                                         |\r\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\r\n| Exception type                                               | 为了访问抛出的异常                                           |\r\n| HandlerMethod                                                | 为了访问触发异常的控制器方法                                 |\r\n| WebRequest, NativeWebRequest                                 | 在不直接使用 Servlet API 的情况下，对请求参数和请求和会话属性进行通用访问。 |\r\n| javax.servlet.ServletRequest, javax.servlet.ServletResponse  | 选择任何特定的请求或响应类型（例如，ServletRequest 或HttpServletRequest 或 Spring的 MultipartRequest 或MultipartHttpServletRequest）。 |\r\n| javax.servlet.http.HttpSession                               | 强制 session 存在。因此参数永远不会为 null。注意 session 访问不是线程安全的。如果允许多个请求同时访问会话,则考虑设置RequestMappingHandlerAdapter 实例的同步会话标志。 |\r\n| java.security.Principal                                      | 当前认证的用户，可能是一个具体的主要执行类。                 |\r\n| HttpMethod                                                   | 请求的 HTTP 方法。                                           |\r\n| java.util.Locale                                             | 当前请求的地区，由 LocaleResolver 决定。                     |\r\n| java.util.TimeZone, java.time.ZoneId                         | 当前请求的时区，由 LocaleContextResolver 决定。              |\r\n| java.io.OutputStream, java.io.Writer                         | 为了访问原始请求体，像 Servlet API 暴露的一样。              |\r\n| java.util.Map, org.springframework.ui.Model, org.springframework.ui.ModelMap | 为了获取错误响应的模型。总是为空。                           |\r\n| RedirectAttributes                                           | 指定在重定向的情况下使用的属性——（即被附加到查询字符串）和 flash 属性，以便在重定向后暂时存储到请求。 |\r\n| @SessionAttribute                                            | 为了访问任何会话属性，与在类级 @SessionAttribute 声明的结果中存储的模型属性相反。 |\r\n| @RequestAttribute                                            | 为了访问请求属性。参见 @RequestAttribute。                   |\r\n\r\n#### 返回值\r\n\r\n@ExceptionHandler 方法支持以下返回值：\r\n\r\n| 返回值                                      | 描述                                                         |\r\n| ------------------------------------------- | ------------------------------------------------------------ |\r\n| @ResponseBody                               | 返回值通过 HttpMessageConverter 实例转换并写到响应。参见 @ResponseBody |\r\n| HttpEntity\\<B>, ResponseEntity\\<B>          | 返回值指定完整的响应（包括 HTTP 头和 body）通过 HttpMessageConverter 实例转换并写入响应。参见ResponseEntity。 |\r\n| String                                      | 被 ViewResolver 实现解析的视图名称，和隐式 model 一起使用。  |\r\n| View                                        | 一个用于渲染的视图实例，和隐式 model 一起使用。              |\r\n| java.util.Map, org.springframework.ui.Model | 将属性添加到隐式模型，并通过RequestToViewNameTranslator 隐式地确定视图名称。 |\r\n| @ModelAttribute                             | 属性被添加到 model。视图名称通过 RequestToViewNameTranslator 隐式决定。 |\r\n| ModelAndView object                         | 视图和 model 属性，还有可选的响应状态。                      |\r\n| void                                        | 方法返回 void 可以认为方法已经完成处理了响应。               |\r\n| Any other return value                      | 如果不是列表上面中的一个并且不是简单类型，默认情况，被视为要添加到 model 的 model 属性。如果是简单类型，它仍然没有解析。 |\r\n\r\n#### REST API 异常\r\n\r\nREST 服务的一个常见需求是在响应主体中包含错误细节。Spring 框架不会自动地这样做，因为响应体中错误细节的表示是特定于应用程序的。然而，@RestController 可以使用 @ExceptionHandler 方法使用 ResponseEntity 返回值来设置响应的状态和主体。这种方法也可以在 @ControllerAdvice 类中声明，将它们应用于全局。\r\n\r\n在响应体中实现全局异常处理的应用程序应该考虑扩展 ResponseEntityExceptionHandler，它提供了对 Spring MVC 提出的异常的处理，并提供了自定义响应体的钩子。要使用此，创建一个 ResponseEntityExceptionHandler 的子类，用 @ControllerAdvice 注解它，覆盖必要的方法，并将其声明为 Spring bean。\r\n\r\n### Controller Advice\r\n\r\n通常 @ExceptionHandler、@InitBinder 和 @ModelAttribute 方法应用在声明它们的 @Controller 类。如果想要这些方法应用到全局（跨 controller），你可以声明它们在一个 @ControllerAdvice 或 @RestControllerAdvice 类中。\r\n\r\n@ControllerAdvice 是 一个 @Component 注解，这意味着这些类会被通过组件扫描注册到 Spring bean 中。@RestControllerAdvice 是 @ControllerAdvice 和 @ResponseBody 结合的注解，这本质上意味着 @ ExceptionHandler 方法通过消息转换（与视图解析或模板渲染）呈现给响应体。\r\n\r\n在启动时，@RequestMapping 和 @ExceptionHandler 方法的基础类可以检测带有 @ControllerAdvice 注解的 Spring bean，然后在运行时应用到它们的方法。全局 @ExceptionHandler 方法（来自 @ControllerAdvice）被应用到本地之后（@Controller）。相比之下，全局 @ModelAttribute 和 @InitBinder 方法被应用到本地之前。\r\n\r\n默认情况，@ControllerAdvice 方法应用到所有请求（也就是说，所有控制器），但是你可以通过使用注释中的属性来缩小到控制器的子集，如下面的显示：\r\n\r\n```java\r\n// Target all Controllers annotated with @RestController\r\n@ControllerAdvice(annotations = RestController.class)\r\npublic class ExampleAdvice1 {}\r\n\r\n// Target all Controllers within specific packages\r\n@ControllerAdvice(\"org.example.controllers\")\r\npublic class ExampleAdvice2 {}\r\n\r\n// Target all Controllers assignable to specific classes\r\n@ControllerAdvice(assignableTypes = {ControllerInterface.class,\r\n                                     AbstractController.class})\r\npublic class ExampleAdvice3 {}\r\n```\r\n\r\n前面示例中的选择器在运行时进行评估，如果广泛使用，可能会对性能产生负面影响。有关更多细节，请参见 @ControllerAdvice javadoc。\r\n\r\n## URI Links\r\n\r\n这章描述 Spring 框架中与 URI 工作可用的各种选项,。\r\n\r\n#### UriComponents\r\n\r\nUriComponentBuilder 帮助从 URI 模板和变量构建 URI\r\n\r\n```java\r\nUriComponents uriComponents = UriComponentsBuilder\r\n    .fromUriString(\"https://example.com/hotels/{hotel}\") ①\r\n    .queryParam(\"q\", \"{q}\") ②\r\n    .encode() ③\r\n    .build(); ④\r\nURI uri = uriComponents.expand(\"Westin\", \"123\").toUri(); ⑤\r\n```\r\n\r\n①  URI 模板的静态工厂方法。\r\n\r\n② 添加或替换 URI 组件。\r\n\r\n③ 请求 URI 模板和 URI 变量编码。\r\n\r\n④ 构建 UriComponents。\r\n\r\n⑤ 扩展变量并获取 URI。\r\n\r\n前面的例子可以写在一条链并且用 buildAndExpand 缩短：\r\n\r\n```java\r\nURI uri = UriComponentsBuilder\r\n    .fromUriString(\"https://example.com/hotels/{hotel}\")\r\n    .queryParam(\"q\", \"{q}\")\r\n    .encode()\r\n    .buildAndExpand(\"Westin\", \"123\")\r\n    .toUri();\r\n```\r\n\r\n可以直接将它缩短为 URI （隐含编码）：\r\n\r\n```java\r\nURI uri = UriComponentsBuilder\r\n    .fromUriString(\"https://example.com/hotels/{hotel}\")\r\n    .queryParam(\"q\", \"{q}\")\r\n    .build(\"Westin\", \"123\");\r\n```\r\n\r\n还可以用完整的URI模板将其进一步缩短：\r\n\r\n```java\r\nURI uri = UriComponentsBuilder\r\n    .fromUriString(\"https://example.com/hotels/{hotel}?q={q}\")\r\n    .build(\"Westin\", \"123\");\r\n```\r\n\r\n#### UriBuilder\r\n\r\nUriComponentsBuilder 实现了 UriBuilder。你可以创建一个 UriBuilder，反过来，还有一个 UriBuilderFactory。同时，UriBuilderFactory 和 URiBuilder 提供可插入机制来从 URI 模板构建 URI，基于共享配置，例如基本 URI、首选编码和其它。\r\n\r\n可以用 UriBuilderFactory 配置 RestTemplate 和 WebClient 来自定义 URI 的预备。DefaultUriBuilderFactory 是 UriBuilderFactory 的默认实现，它在内部使用 UriComponentsBuilder，并公开共享配置选项。\r\n\r\n下面的例子演示如何配置 RestTemplate：\r\n\r\n```java\r\n// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\r\n\r\nString baseUrl = \"https://example.org\";\r\nDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\r\nfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);\r\n\r\nRestTemplate restTemplate = new RestTemplate();\r\nrestTemplate.setUriTemplateHandler(factory);\r\n```\r\n\r\n配置 WebClient 的示例：\r\n\r\n```java\r\n// import org.springframework.web.util.DefaultUriBuilderFactory.EncodingMode;\r\n\r\nString baseUrl = \"https://example.org\";\r\nDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl);\r\nfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VARIABLES);\r\n\r\nWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\r\n```\r\n\r\n此外，还可以直接用 DefaultUriBuilderFactory。它和用 UriComponentsBuilder 很相似，但是代替了静态工厂方法。它是一个拥有配置和首选项的实例：\r\n\r\n```java\r\nString baseUrl = \"https://example.com\";\r\nDefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl);\r\nURI uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\")\r\n    .queryParam(\"q\", \"{q}\")\r\n    .build(\"Westin\", \"123\");\r\n```\r\n\r\n#### URI Encoding\r\n\r\nUriComponentsBuilder 在两个级别公开了编码选项：\r\n\r\n- UriComponentsBuilder#encode()：第一次预编码 URI 模板然后在扩展时严格编码 URI 变量。\r\n- UriComponents#encode()：在扩展 URI 变量后编码 URI 组件。\r\n\r\n这两种选项都替换了非 ASCII和非法字符。然而，第一个选项还替换了 URI 变量中出现的保留意义的字符。\r\n\r\n*提示：“;” 这是合法的路径，但有保留的意义。在URI变量中，第一个选项中 URI 变量的 “;” 会被 “%3B” 取代，而在 URI 模板中不会。相比之下，第二种选择永远不会取代 “;”，因为它是路径上合法的字符。*\r\n\r\n在很多情况，第一个选项可能会给出预期的结果，因为它将 URI 变量视为完全编码的不透明数据，而选项2只有在 URI 变量有意包含保留字符的情况下才有用。\r\n\r\n```java\r\nURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\r\n    .queryParam(\"q\", \"{q}\")\r\n    .encode()\r\n    .buildAndExpand(\"New York\", \"foo+bar\")\r\n    .toUri();\r\n\r\n// Result is \"/hotel%20list/New%20York?q=foo%2Bbar\"\r\n```\r\n\r\n可以通过直接访问 URI （隐含编码）来缩短前面的示例：\r\n\r\n```java\r\nURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\")\r\n    .queryParam(\"q\", \"{q}\")\r\n    .build(\"New York\", \"foo+bar\")\r\n```\r\n\r\n可以用完整的 URI 模板来进一步缩短：\r\n\r\n```java\r\nURI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}?q={q}\")\r\n    .build(\"New York\", \"foo+bar\")\r\n```\r\n\r\nWebClient 和 RestTemplate 通过 UriBuilderFactory 策略在内部扩展和编码 URI 模板。两者都可以配置自定义策略。\r\n\r\n ```java\r\nString baseUrl = \"https://example.com\";\r\nDefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl)\r\nfactory.setEncodingMode(EncodingMode.TEMPLATE_AND_VALUES);\r\n\r\n// Customize the RestTemplate..\r\nRestTemplate restTemplate = new RestTemplate();\r\nrestTemplate.setUriTemplateHandler(factory);\r\n\r\n// Customize the WebClient..\r\nWebClient client = WebClient.builder().uriBuilderFactory(factory).build();\r\n ```\r\n\r\nDefaultUriBuilderFactory 实现使用 UriComponentsBuilder 在内部扩展和编码 URI 模板。作为一个工厂，它提供了一个配置方法来编码的方法，基于以下一种编码模式：\r\n\r\n- TEMPLATE_AND_VALUES：使用 UriComponentsBuilder#encode()，与前面列表中的第一个选项相对应，用于预先编码URI模板，并在扩展时严格编码URI变量。\r\n- VALUES_ONLY：不编码 URI 模板，而是在将它们扩展到模板之前，通过 UriUtils#encodeUriUriVariables 对URI变量进行严格的编码。\r\n- URI_COMPONENTS：使用 UriComponents#encode() ，与前面列表中的第二个选项相对应，在 URI 变量扩展后对 URI 组件值进行编码。\r\n- NONE：不编码。\r\n\r\n出于历史原因和向后兼容性 RestTemplate 设置为 EncodingMode.URI_COMPONENTS。WebClient 依赖于DefaultUriBuilderFactory 的默认值，由 5.0.x 的 EncodingMode.URI_COMPONENTS 在 5.1 改成了EncodingMode.TEMPLATE_AND_VALUES.\r\n\r\n#### Relative Servlet Requests\r\n\r\n可以使用 ServletUriComponentsBuilder 来创建 URI：\r\n\r\n```java\r\nHttpServletRequest request = ...\r\n    \r\n    // Re-uses host, scheme, port, path and query string...\r\n    \r\nServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromRequest(request)\r\n    .replaceQueryParam(\"accountId\", \"{id}\").build()\r\n    .expand(\"123\")\r\n    .encode();\r\n```\r\n\r\n您可以创建 URI 相对于上下文路径：\r\n\r\n```java\r\n// Re-uses host, port and context path...\r\nServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromContextPath(request)\r\n    .path(\"/accounts\").build()\r\n```\r\n\r\n还可以创建相对 Servlet （例如 /main/*）的 URI：\r\n\r\n```java\r\n// Re-uses host, port, context path, and Servlet prefix...\r\n\r\nServletUriComponentsBuilder ucb = ServletUriComponentsBuilder.fromServletMapping(request)\r\n	.path(\"/accounts\").build()\r\n```\r\n\r\n提示：在 5.1，ServletUriComponentsBuilder 忽略了 Forwarded 和 X-Forwarded-* 头的信息。考虑使用前面的 ForwardedHeaderFilter 来提取和使用或丢弃这些标题。\r\n\r\n#### Links to Controllers\r\n\r\nSpring MVC 提供了一个机制来为控制器方法准备链接。假如有这样一个 Controller：\r\n\r\n```java\r\n@Controller\r\n@RequestMapping(\"/hotels/{hotel}\")\r\npublic class BookingController {\r\n    \r\n    @GetMapping(\"/bookings/{booking}\")\r\n    public ModelAndView getBooking(@PathVariable Long booking) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n可以通过引用方法名称来准备一个链接：\r\n\r\n```java\r\nUriComponents uriComponents = MvcUriComponentsBuilder\r\n    .fromMethodName(BookingController.class, \"getBooking\", 21).buildAndExpand(42);\r\n\r\n    URI uri = uriComponents.encode().toUri();\r\n```\r\n\r\n在前面的例子，我们通过插入到 URI 提供实参（long 值为：21）给路径变量。此外，还提供了值 42 来填充剩余的 URI 变量，比如从类级别的请求映射继承的酒店变量。如果方法还有更多参数，可以为不需要的参数提供 null。一般来说，只有 @PathVariable 和 @RequestParam 参数与构造 URL 有关。\r\n\r\n还有其它传统的 MvcUriComponentsBuilder 用法。例如，可以用同样的技术通过代理去模拟测试，避免通过名称引用控制器方法。像下面的例子一样（假定静态导入了 MvcUriComponentsBuilder.on）：\r\n\r\n```java\r\nUriComponents uriComponents = MvcUriComponentsBuilder\r\n	.fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\r\n\r\nURI uri = uriComponents.encode().toUri();\r\n```\r\n\r\n*提示：控制器方法签名在设计中是有限制的，除了需要适当的参数签名之外，返回类型还存在一个技术限制，因此返回类型必须不是最终的。特别是视图名的公共字符串返回类型在这里不生效。你应该使用 ModelAndView 甚至是普通 Object (带有字符串返回值)。*\r\n\r\n前面的例子用 MvcUriComponentsBuilder 的静态方法。在内部，他们依赖于 ServletUriComponentsBuilder 来从 scheme、主机、端口、上下文路径和当前请求的 servlet 路径中准备一个基本URL。这在很多情况下都很好正常，但是有时候不行。例如在 request 的 context 外（比如准备链接的批处理过程）或需要插入路径前缀的时候。\r\n\r\n对于这种情况，可以用静态的重载方法 fromXxx ，它接受一个 UriComponentsBuilder 来使用基 URL。或者，你可以用基 URL 创建一个 MvcUriComponentsBuilder 实例，并且用这个实例的 withXxx 方法。例如下面的用 withMethodCall：\r\n\r\n```java\r\nUriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath()\r\n    .path(\"/en\");\r\nMvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base);\r\nbuilder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42);\r\n\r\nURI uri = uriComponents.encode().toUri();\r\n```\r\n\r\n#### Links in Views\r\n\r\n在像 Thymeleaf、FreeMarker 或 JSP 这样的视图，你可以通过引用隐式或显式的分配的名称给每个请求映射链接到注解控制器。\r\n\r\n加入有这样的例子：\r\n\r\n```java\r\n@RequestMapping(\"/people/{id}/addresses\")\r\npublic class PersonAddressController {\r\n    \r\n    @RequestMapping(\"/{country}\")\r\n    public HttpEntity getAddress(@PathVariable String country) { ... }\r\n}\r\n```\r\n\r\n可以从 JSP 准备链接：\r\n\r\n```java\r\n<%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"s\" %>\r\n...\r\n<a href=\"${s:mvcUrl(\'PAC#getAddress\').arg(0,\'US\').buildAndExpand(\'123\')}\">Get Address</a>\r\n```\r\n\r\n前面的示例依赖于 Spring tag 库（即 META/INF/spring.tld）中声明的 mvcUrl 函数，但很容易定义自己的功能，或者为其他模板技术准备类似的功能。\r\n\r\n这就是它的工作原理。在启动时，每个 @RequestMapping 都通过 HandlerMethodMappingNamingStrategy 来分配一个默认名称，其默认实现使用类的大写字母和方法名称（例如，ThingController 中的 getThing 方法成为 “TC#getThing”）。如果有一个名称冲突，您可以使用 @RequestMapping(name =“..”) 来指定一个显式名称或实现您自己的 HandlerMethodMappingNamingStrategy。\r\n\r\n## 异步请求\r\n\r\nSpring MVC 与 Servlet 3.0 异步请求处理有一个广泛的集成：\r\n\r\n- DeferredResult 和 Callable 在控制器方法返回值并且为单个异步返回值提供基本支持。\r\n- 控制器可以连续输出 multiple 值，包括 SEE 和 raw data。\r\n- 控制器可以使用响应式客户端和返回反应类型的响应处理。\r\n\r\n### DeferredResult\r\n\r\n在 Servlet 容器中启用异步请求处理特性时，控制器方法可以将任何支持的控制器方法返回 DeferredResult ：\r\n\r\n```java\r\n@GetMapping(\"/quotes\")\r\n@ResponseBody\r\npublic DeferredResult<String> quotes() {\r\n    DeferredResult<String> deferredResult = new DeferredResult<String>();\r\n    // Save the deferredResult somewhere..\r\n    return deferredResult;\r\n}\r\n\r\n// From some other thread...\r\ndeferredResult.setResult(data);\r\n```\r\n\r\n控制器可以从不同的线程异步产生返回值——例如，在响应外部事件（JMS 消息）、计划任务或其他事件时。\r\n\r\n### Callable\r\n\r\n控制器可以使用 `java.util.concurrent.Callable` 来包装任何支持的返回值：\r\n\r\n```java\r\n@PostMapping\r\npublic Callable<String> processUpload(final MultipartFile file) {\r\n    \r\n    return new Callable<String>() {\r\n        public String call() throws Exception {\r\n            // ...\r\n            return \"someView\";\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n然后，通过配置的任务执行者运行给定的任务，可以获得返回值。\r\n\r\n### Processing\r\n\r\n以下是对 Servlet 异步请求处理的一个非常简洁的概述：\r\n\r\n- ServletRequest 可以通过调用 request.startAsync() 进入输入异步模式。这样做的主要作用是 Servlet（以及任何过滤器）可以退出，但响应仍然是开放的，以便稍后完成处理。\r\n- 调用 request.startAsync() 返回 AsynContext，可以用它来进一步控制异步处理。例如，它提供一个 dispatch 方法，这个方法和 Serlvet API 的转发很像，只是它让应用程序在 Servlet 容器线程重新处理这个请求。\r\n- ServletRequest 提供访问当前的 DispatcherType，可以用它来区分处理初始请求、异步调度、转发和其他 dispatcher 类型。\r\n\r\nDeferredResult 处理如下：\r\n\r\n- 控制器返回 DeferredResult 并将其保存在一些内存队列或可以访问的列表中。\r\n- Spring MVC 调用 request.startAsync()。\r\n- 与此同时，DispatcherServlet 和所有配置的过滤器都退出请求处理线程，但响应仍然是开放的。\r\n- 应用程序在一些线程设置 DeferredResult，Spring MVC 委派请求返回到 Servlet 容器。\r\n- DispatcherServlet 再次被调用，并使用异步生成的返回值处理恢复文件。\r\n\r\nCallable 处理如下：\r\n\r\n- 控制器返回 Callable。\r\n- Spring MVC 调用 request.startAsync() 并将Callable提交到一个单独的线程中进行处理。\r\n- 与此同时，DispatcherServlet 和所有配置的过滤器都退出请求处理线程，但响应仍然是开放的。\r\n- 最终，Callable 会产生一个结果，而 Spring MVC 将请求返回到 Servlet 容器，以完成处理。\r\n- DispatcherServlet 再次被调用，并恢复处理从 Callable 异步生成的返回值。\r\n\r\n#### 异常处理\r\n\r\n当你使用 DeferredResult 的时候，你可以选择是否调用 setResult 或 setErrorResult 来处理异常。在这两种情况下，Spring MVC 将请求返回到 Servlet 容器，以完成处理。如果有配出异常，将通过常规异常处理机制(例如，调用 @ExceptionHandler 处理方法）。\r\n\r\n当你用 Callable 的时候，类似的处理逻辑时，主要的区别是结果从 Callable 或异常返回。\r\n\r\n#### 拦截\r\n\r\nHandlerInterceptor 实例可以是 AsyncHandlerInterceptor，接收原始请求异步处理的 afterConcurrentHanlingStarted 回调（而不是 postHandle 和 afterCompletion）。\r\n\r\nHandlerInterceptor 实现也可以注册 CallableProcessingInterceptor 或  DeferredResultProcessingInterceptor 更深入的整合异步请求的生命周期（例如处理超时事件）。\r\n\r\nDeferredResult 提供 onTimeout(Runnable) 和 onCompletion(Runnable) 回调。Callable 可以被替换为 WebAsyncTask，它公开额外的超时和完成回调的方法。\r\n\r\n\r\n\r\n#### Compared to WebFlux\r\n\r\n暂时跳过。\r\n\r\n### HTTP Streaming\r\n\r\n可以用 DeferredResult 和 Callable 生成单个返回值。但是如果要生成多个异步值并且写到响应要怎么办呢？这节就来描述如何做。\r\n\r\n#### Objects\r\n\r\n可以用 ResponseBodyEmitter 返回值来生成对象流，每个对象都用 HttpMessageConverter 序列化并且写到响应。\r\n\r\n```java\r\n@GetMapping(\"/events\")\r\npublic ResponseBodyEmitter handle() {\r\n    ResponseBodyEmitter emitter = new ResponseBodyEmitter();\r\n    // Save the emitter somewhere..\r\n    return emitter;\r\n}\r\n\r\n// In some other thread\r\nemitter.send(\"Hello once\");\r\n\r\n// and again later on\r\nemitter.send(\"Hello again\");\r\n\r\n// and done at some point\r\nemitter.complete();\r\n```\r\n\r\n也可以在 ResponseEntity 中用 ResponseBodyEmitter 作为 body，来自定义响应状态和响应头。\r\n\r\n当 emitter 抛出异常时，应用程序不负责清理连接并且不应该调用 emitter.complete 或 emitter.completeWithError。作为代替，Servlet 容器自动启用一个 AsyncListener 错误通知，Spring MVC 调用 completeWithError。这个调用反过来对应用程序执行最后的 ASYNC 委派，在此期间，Spring MVC 调用配置的异常解析器，并完成请求。\r\n\r\n#### SSE\r\n\r\nSeeEmitter（ResponseBodyEmitter 的子类）提供 Server-Sent Events 支持，从服务器发送的事件根据 W3C SSE 规范。返回 SeeEmitter 就可以在控制器里产生 SEE 流了。\r\n\r\n```java\r\n@GetMapping(path=\"/events\", produces=MediaType.TEXT_EVENT_STREAM_VALUE)\r\npublic SseEmitter handle() {\r\n    SseEmitter emitter = new SseEmitter();\r\n    // Save the emitter somewhere..\r\n    return emitter;\r\n}\r\n\r\n// In some other thread\r\nemitter.send(\"Hello once\");\r\n\r\n// and again later on\r\nemitter.send(\"Hello again\");\r\n\r\n// and done at some point\r\nemitter.complete();\r\n```\r\n\r\n虽然 SSE 是连通浏览器流的主要选项，但注意到 Internet Explorer 不支持服务器发送事件。考虑使用 Spring 的 WebSocket messaging 与 SockJS fallabck 传输(包括SSE)，它目标是广泛的浏览器。\r\n\r\n#### Raw Data\r\n\r\n有时，绕过消息转换和直接流到响应 OutputStream （例如，用于文件下载）是很有用的。您可以使用 StreamingResponseBody 返回值类型来这样做。\r\n\r\n```java\r\n@GetMapping(\"/download\")\r\npublic StreamingResponseBody handle() {\r\n    return new StreamingResponseBody() {\r\n        @Override\r\n        public void writeTo(OutputStream outputStream) throws IOException {\r\n            // write...\r\n        }\r\n    };\r\n}\r\n```\r\n\r\n你可以在 ResponseEntity 中使用 StreamingResponseBody 来自定义响应的状态和标题。\r\n\r\n### Reactive Types\r\n\r\nSpring MVC 支持在控制器中使用响应式客户客户端库。包括 spring-webflux 的 WebClient 和其它，像 Spring Data 响应式数据属性。在这种情况下，能够从控制器方法中返回反应型是很方便的。\r\n\r\n反应返回值处理如下：\r\n\r\n- 适配一个单值承诺，像用 DeferredResult 一样。\r\n- 适配流媒体类型的多值（像 application/stream+json 或 text/event-stream），像用 ResponseBodyEmitter 或 SeeEmitter 一样。应用程序也可以返回 Flux\\<ServerSentEvent> 或 Observable\\<ServerSentEvent>。\r\n- 适配任何其它流媒体类型的多值，像用 DeferredResult<List<?>> 一样。\r\n\r\n### Disconnects\r\n\r\n当远程客户端离开时，Servlet API 没有提供任何通知。因此，使用流到响应时，不管是否通过 SseEmitter 或 reactive types，通常周期性地发送数据是很重要的，因为当客户机断开时，写入失败。发送可以空 SSE 事件或任何其他数据的形式，另一方必须解释为心跳和忽略。\r\n\r\n或者，考虑使用 web 消息传递解决方案（比如 STOMP over WebSocket 或 SockJS 的 WebSocket）,它有一个内置的心跳机制。\r\n\r\n### 配置\r\n\r\n必须在 Servlet 容器级别启用异步请求处理特性。MVC 配置还为异步请求公开了几个选项。\r\n\r\n#### Servlet 容器\r\n\r\n过滤器和 Servlet 声明有一个 asyncSupported 标志，需要设置为 true 以启用异步请求处理。此外，应该声明过滤映射来处理 ASYNC javax.servlet.DispatchType。\r\n\r\n在 Java 配置中，当您使用 AbstractAnnotationConfigDispatcherServletInitializer 来初始化 Servlet 容器时，这是自动完成的。\r\n\r\n在 web.xml 配置中，可以添加 `<async-supported>true</async-supported>` 到 DispatcherServlet 和 Filter 声明并且添加  `<dispatcher>ASYNC</dispatcher>` 到过滤器映射。\r\n\r\n#### Spring MVC\r\n\r\nMVC 配置暴露了与异步请求处理相关的以下选项：\r\n\r\n- Java 配置：在 WebMvcConfigurer 使用 configureAsyncSupport 回调。\r\n- XML 命名空间：在 `<mvc:annotation-driven>` 下使用 `<async-support>` 元素。\r\n\r\n你可以配置以下内容：\r\n\r\n- 默认异步请求超时值，如果不设置，依赖于基础的Serlvet 容器（例如 ，Tomcat 10 秒）。\r\n- AsyncTaskExecutor 用在 Reactive Types 流时阻塞时和执行从控制器方法返回的 Callable 实例。我们强烈推荐配置此属性，如果您使用 reactive types 或具有返回 Callable 的控制器方法，从默认情况下，它是一个 SimpleAsyncTaskExecutor。\r\n- DeferredResultProcessingInterceptor 实现和 CallableProcessingInterceptor 实现。\r\n\r\n注意，您还可以在 DeferredResult、ResponseBodyEmitter 和 SeeEmitter 上设置默认的超时值。对于 Callable，你可以使用 WebAsyncTask 来提供一个超时值。\r\n\r\n## CORS\r\n\r\nSpring MVC 允许您处理 CORS (跨源资源共享)。本节描述了如何做到这一点。\r\n\r\n### 介绍\r\n\r\n出于安全原因，浏览器禁止 AJAX 调用当前站点外的资源。例如，有银行账户在一个标签，evil.com 在另一个标签。evil.com 的脚本应该不允许 AJAX 请求用你证书的访问银行 API，例如从你的账户取钱。\r\n\r\n跨源资源共享（CORS）是由大多数浏览器实现的 W3C 规范，它允许您指定是否授权了跨域请求，而不是使用基于 IFRAME 或 JSONP 的不安全、不那么强大的工作工具。\r\n\r\n### 处理\r\n\r\nCORS 规范区分了预检请求（preflight requests）、简单和实际请求。要了解 CORS 的工作原理，您可以在许多其他方面阅读本文，或者查看规范以获得更多细节。\r\n\r\nSpring MVC HandlerMapping 实现为 CORS 提供了内置的支持。在成功地将请求映射到处理程序后，HandlerMapping 实现检查给定请求和处理程序的 CORS 配置，并采取进一步的操作。预检请求直接处理，而简单和实际的 CORS 请求被拦截、验证，并需要 CORS 响应头集。\r\n\r\n为了启用跨源请求（也就是说，Origin 头是存在的并且请求不同主机），您需要有一些显式声明的 CORS 配置。如果没有找到匹配的 CORS 配置，则拒绝预检请求。没有添加简单和实际 CORS 请求到响应的 CORS 头，因此，浏览器拒绝它们。\r\n\r\n每个 HandlerMapping 可以单独配置 URL 基于模式的 CorsConfiguration 映射。在大多数情况下，应用程序使用 MVC Java 配置或 XML 名称空间来声明这样的映射，这将导致在一个全局映射中传递到所有 HandlerMappping 实例。\r\n\r\n你可以结合在 HandlerMapping 的全局 CORS 配置和更精确的 handler-level CORS 配置。例如，注解控制器可以用类或方法级别的 @CrossOrigin 注解（其它处理器可以实现 CorsConfiguratioinSource）。\r\n\r\n将全局和本地配置相结合的规则通常是加性的。对于只有一个值可以被接受的属性（如 allowCredentials 和 maxAge），本地覆盖了全局值。更多细节请参见 CorsConfiguration#combine(CorsConfiguration)。\r\n\r\n### @CrossOrigin\r\n\r\n@CrossOrigin 注解在控制器方法上启用 cross-origin 请求：\r\n\r\n```java\r\n@RestController\r\n@RequestMapping(\"/account\")\r\npublic class AccountController {\r\n    \r\n    @CrossOrigin\r\n    @GetMapping(\"/{id}\")\r\n    public Account retrieve(@PathVariable Long id) {\r\n        // ...\r\n    }\r\n    \r\n    @DeleteMapping(\"/{id}\")\r\n    public void remove(@PathVariable Long id) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n默认的，@CrossOrigin 允许：\r\n\r\n- 所有源\r\n- 所有头\r\n- 匹配处理方法的所有 HTTP 方法\r\n\r\nallowedCredentials 默认不启用，既然建立了一个公开了敏感的用户特定信息（如 cookie 和 CSRF 令牌）的信任级别，而且应该只在适当的地方使用。\r\n\r\nmaxAge 被设置为 30 分钟。\r\n\r\n@CorssOrigin 也支持类级别注解，并且嵌入到每个方法。\r\n\r\n```java\r\n@CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600)\r\n@RestController\r\n@RequestMapping(\"/account\")\r\npublic class AccountController {\r\n    \r\n    @GetMapping(\"/{id}\")\r\n    public Account retrieve(@PathVariable Long id) {\r\n        // ...\r\n    }\r\n    \r\n    @DeleteMapping(\"/{id}\")\r\n    public void remove(@PathVariable Long id) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n可以同时在类级别和方法级别用 @CrossOrigin\r\n\r\n### 全局配置\r\n\r\n除了细粒度、控制器方法级别配置之外，你可能还想定义一些全局 CORS 配置。你可以在任何 HandlerMapping 上单独设置基于URI 的 CorsConfiguration 映射。然而，大多数应用程序使用 MVC Java 配置或 MVC XNM 名称空间来实现这一点。\r\n\r\n默认的，全局配置可以启用下面这些：\r\n\r\n- 所有源\r\n- 所有头\r\n- GET, HEAD 和 POST 方法\r\n\r\nallowedCredentials 默认不启用。\r\n\r\nmaxAge 被设置为 30 分中。\r\n\r\n#### Java 配置\r\n\r\n为了在 Java 配置启用 CORS，可以用 CorsRegistry 回调。\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addCorsMappings(CorsRegistry registry) {\r\n        registry.addMapping(\"/api/**\")\r\n            .allowedOrigins(\"https://domain2.com\")\r\n            .allowedMethods(\"PUT\", \"DELETE\")\r\n            .allowedHeaders(\"header1\", \"header2\", \"header3\")\r\n            .exposedHeaders(\"header1\", \"header2\")\r\n            .allowCredentials(true).maxAge(3600);\r\n        // Add more mappings...\r\n    }\r\n}\r\n```\r\n\r\n#### XML 配置\r\n\r\n为了在 XML 命名空间启用 CORS，可以hi使用 `<mvc:cors` 元素。\r\n\r\n```XML\r\n<mvc:cors>\r\n    \r\n    <mvc:mapping path=\"/api/**\"\r\n                 allowed-origins=\"https://domain1.com, https://domain2.com\"\r\n                 allowed-methods=\"GET, PUT\"\r\n                 allowed-headers=\"header1, header2, header3\"\r\n                 exposed-headers=\"header1, header2\" allow-credentials=\"true\"\r\n                 max-age=\"123\" />\r\n    <mvc:mapping path=\"/resources/**\"\r\n                 allowed-origins=\"https://domain1.com\" />\r\n</mvc:cors>\r\n```\r\n\r\n### CORS 过滤器\r\n\r\n可以通过内置的 CorsFilter 应用 CORS 支持。\r\n\r\n*注意，如果在 Spring Security 用 CrosFilter，记住 Spring Security 内建支持 CORS。*\r\n\r\n通过 CorsConfigurationSource 的构造器配置 filter：\r\n\r\n```java\r\nCorsConfiguration config = new CorsConfiguration();\r\n\r\n// Possibly...\r\n// config.applyPermitDefaultValues()\r\n\r\nconfig.setAllowCredentials(true);\r\nconfig.addAllowedOrigin(\"https://domain1.com\");\r\nconfig.addAllowedHeader(\"*\");\r\nconfig.addAllowedMethod(\"*\");\r\n\r\nUrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();\r\nsource.registerCorsConfiguration(\"/**\", config);\r\n\r\nCorsFilter filter = new CorsFilter(source);\r\n```\r\n\r\n## Web Security\r\n\r\nSpring Security 项目支持保护 web 应用程序免受恶意攻击。参见 Spring Security 参考文档，包括：\r\n\r\n- Spring MVC Security\r\n- Spring MVC Test Support\r\n- CSRF protection\r\n- Security Response Headers\r\n\r\nHDIV 是与 Spring MVC 集成的另一个 web 安全框架。\r\n\r\n## HTTP Caching\r\n\r\nHTTP 缓存可以显著提高 web 应用程序的性能。HTTP 缓存围绕着Cache-Control 响应头，然后是条件请求头（如 Last-Modified和 ETag）。Cache-control 建议私有（例如，浏览器）和公共（例如，代理）缓存如何缓存和重新使用响应。一个 ETag 头被用来提出一个条件请求，如果内容没有更改，可能会导致一个没有一个没有 body 的 304（NOT_MODIFIED）。ETag  可以被看作是一个更复杂的继任者。\r\n\r\n### CacheControl\r\n\r\nCacheControl 提供了对与 Cache-Control 头相关的设置的支持，并在许多地方作为参数：\r\n\r\n- WebContentInterceptor\r\n- WebContentGenerator\r\n- Controllers\r\n- Static Resources\r\n\r\n虽然 RFC 7234 描述了对 Cache-Control 响应头的所有可能的指令，但是 CacheControl 类型采用了一个以实例为导向的方法，它专注于常见的场景：\r\n\r\n```java\r\n// Cache for an hour - \"Cache-Control: max-age=3600\"\r\nCacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit.HOURS);\r\n\r\n// Prevent caching - \"Cache-Control: no-store\"\r\nCacheControl ccNoStore = CacheControl.noStore();\r\n\r\n// Cache for ten days in public and private caches,\r\n// public caches should not transform the response\r\n// \"Cache-Control: max-age=864000, public, no-transform\"\r\nCacheControl ccCustom = CacheControl.maxAge(10, TimeUnit.DAYS).noTransform()\r\n.cachePublic();\r\n```\r\n\r\nWebContentGenerator 还接收一个更简单的属性 cachePeriod：\r\n\r\n- 一个 -1 值不生成 Cache-Control 响应头。\r\n- 一个 0 通过使用  “Cache-Control:no-store” 指令来防止缓存。\r\n- 一个 n>0 的值通过使用 “Cache-Control:max-age=n” 指令来缓存给定响应的给定响应。\r\n\r\n### Controllers\r\n\r\n控制器可以为 HTTP 缓存添加显式支持。我们建议这样做，因为对资源的 lastModified 或 ETag 值需要在它与条件请求头的比较之前计算。控制器可以添加一个 ETag 头和 Cache-Control 设置到 ResponseEntity，如下面的显示：\r\n\r\n```java\r\n@GetMapping(\"/book/{id}\")\r\npublic ResponseEntity<Book> showBook(@PathVariable Long id) {\r\n    Book book = findBook(id);\r\n    String version = book.getVersion();\r\n    \r\n    return ResponseEntity\r\n        .ok()\r\n        .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS))\r\n        .eTag(version) // lastModified is also available\r\n        .body(book);\r\n}\r\n```\r\n\r\n如果对条件请求头的比较显示内容没有更改，前面的示例将使用空 body 发送304（NOT_MODIFIED）响应。其它情况添加 ETag 和 Cache-Control 到响应。\r\n\r\n也可以在控制器中对条件请求头进行检查：\r\n\r\n```java\r\n@RequestMapping\r\npublic String myHandleMethod(WebRequest request, Model model) {\r\n    long eTag = ...\r\n    if (request.checkNotModified(eTag)) {\r\n        return null; ①\r\n    }\r\n    model.addAttribute(...);\r\n    return \"myViewName\";\r\n}\r\n```\r\n\r\n① 响应被设置成 304（NOT_MODIFIED）——没有进一步处理。\r\n\r\n有三种变体来检查对 eTag 值、lastModified 值或两者的条件请求。对于有条件的 GET 和 HEAD 请求，你可以将响应设置为304（NOT_MODIFIED）。对于有条件的 POST、PUT 和 DELETE，你可以将响应设置为409（PRECONDITION_FAILED），以防止并发修改。\r\n\r\n### Static Resources\r\n\r\n你应该为静态资源提供一个 Cache-Control 和条件响应头，以获得最佳性能。参见配置 Static Resources的部分。\r\n\r\n### ETag Filter\r\n\r\n可以使用 ShallowEtagHeaderFilter 添加 “shallow” 的 eTag 值，这些值是由响应内容计算的，因此，节省带宽，而不是CPU时间。参见 Shallow ETag。\r\n\r\n## 视图技术\r\n\r\nSpring MVC 中的视图技术的使用是可插入的，不管您是否决定使用Thymeleaf、Groovy Groovy Templates、JSPs 还是其它技术，主要是一个配置变化的问题。\r\n\r\n### Thymeleaf\r\n\r\n*Thymeleaf 是一个现代的服务器端 Java 模板引擎，它强调自然的 HTML 模板，可以通过双击来预览浏览器，而不需要运行服务器，这对 UI 模板（例如，设计师）的独立工作非常有帮助,。如果你想要代替 JSP，Thymeleaf 提供了最广泛的功能之一，使这种转换更容易。Thymeleaf 积极开发和维护。*\r\n\r\nSpring MVC 的 Thymeleaf 集成由 Thymeleaf 项目管理。配置包括一些 bean 声明，如 ServletContextTemplateResolver、SpringTemplateEngine 和 ThymeleafViewResolver。更多细节请参见 Thymeleaf 项目主页。\r\n\r\n### FreeMarker\r\n\r\nApache FreeMarker 是一个模板引擎，用于从 HTML 生成任何类型的文本输出到电子邮件和其他。Spring 框架有一个内置的集成，用于使用 FreeMarker 模板的 Spring MVC。\r\n\r\n#### View Configuration\r\n\r\n下面的例子演示如何配置 FreeMarker 作为视图技术：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.freemarker();\r\n    }\r\n    \r\n    // Configure FreeMarker...\r\n    @Bean\r\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\r\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\r\n        configurer.setTemplateLoaderPath(\"/WEB-INF/freemarker\");\r\n        return configurer;\r\n    }\r\n}\r\n```\r\n\r\n下面演示如何在 XML 进行一样的配置：\r\n\r\n```xml\r\n<mvc:annotation-driven/>\r\n    \r\n<mvc:view-resolvers>\r\n	<mvc:freemarker/>\r\n</mvc:view-resolvers>\r\n    \r\n<!-- Configure FreeMarker... -->\r\n<mvc:freemarker-configurer>\r\n	<mvc:template-loader-path location=\"/WEB-INF/freemarker\"/>\r\n</mvc:freemarker-configurer>\r\n```\r\n\r\n或者，你也可以定义 FreeMarkerConfigure bean 以完全控制所有属性：\r\n\r\n```xml\r\n<bean id=\"freemarkerConfig\" class=\r\n      \"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\r\n    <property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/>\r\n</bean\r\n```\r\n\r\n你的模板需要存储在前面示例中所示的 FreeMarkerConfigure 所指定的目录中。在前面的例子，如果你的控制器返回视图名称为 welcome，解析器会查找 /WEB-INF/freemarker/welcome.ftl 模板。\r\n\r\n#### FreeMarker Configuration\r\n\r\n可以直接传递 FreeMarker 的 \'Setting\' 和 ‘SharedVariables’ 给 FreeMarker Configuration 对象（由 Spring 管理），通过在 FreeMarkerConfigurer bean 设置适当的 bean 属性。freemarkerSettings 属性需要一个 `java.util.Properties` 对象，freemakerVariables 属性需要一个 `java.util.Map` 。\r\n\r\n```xml\r\n<bean id=\"freemarkerConfig\" class=\r\n      \"org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer\">\r\n    <property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/>\r\n    <property name=\"freemarkerVariables\">\r\n        <map>\r\n            <entry key=\"xml_escape\" value-ref=\"fmXmlEscape\"/>\r\n        </map>\r\n    </property>\r\n</bean>\r\n\r\n<bean id=\"fmXmlEscape\" class=\"freemarker.template.utility.XmlEscape\"/>\r\n```\r\n\r\n更多细节参见 FreeMarker 文档。\r\n\r\n#### Form Handling\r\n\r\nSpring 提供了一个标记库在 JSP中，包括 `<spring:bind />`元素。这个元素主要让表单从 form-backing 对象中显示值，并显示从 web 或业务层 Validator 验证失败的结果。Spring 也支持在 FreeMarker 中相同的功能，使用额外的方便宏来生成表单输入元素本身。\r\n\r\n##### The Bind Macros\r\n\r\n在 spring-webmvc.jar 文件中为两种语言维护了一组标准的宏，因此它们总是可以使用适当配置的应用程序。在 Spring 库中定义的一些宏被认为是内部的(私有的)，但在宏定义中没有这样的范围，使所有的宏都可以访问调用代码和用户模板。下面的部分只专注于您需要直接从模板中调用的宏。如果您希望直接查看宏代码，则该文件称为 spring.ftl，在 `org.springframework.web.servlet.view.freemarker` 包。\r\n\r\n##### Simple Binding\r\n\r\n在你的 HTML 表单（vm 或 ftl 模板），它作为 Spring MVC 控制器的表单视图，您可以使用类似于下一个示例的代码来绑定字段值，并在类似的方式中为每个输入字段显示错误消息，从而和 JSP 等效。\r\n\r\n```html\r\n<!-- freemarker macros have to be imported into a namespace. We strongly\r\nrecommend sticking to \'spring\' -->\r\n<#import \"/spring.ftl\" as spring/>\r\n<html>\r\n    ...\r\n    <form action=\"\" method=\"POST\">\r\n        Name:\r\n        <@spring.bind \"myModelObject.name\"/>\r\n        <input type=\"text\"\r\n               name=\"${spring.status.expression}\"\r\n               value=\"${spring.status.value?html}\"/><br>\r\n        <#list spring.status.errorMessages as error> <b>${error}</b> <br> </#list>\r\n        <br>\r\n        ...\r\n        <input type=\"submit\" value=\"submit\"/>\r\n    </form>\r\n    ...\r\n</html>\r\n```\r\n\r\n...\r\n\r\n剩余部分暂时跳过。\r\n\r\n### Groovy Markup\r\n\r\nGroovy Markup 模板引擎主要目的是生成 XML-like 标记（XML、XHTML、HTML5等），但是您可以使用它来生成任何基于文本的内容。Spring 框架有一个内置的集成，用于使用 Groovy Markup 的 Spring MVC。\r\n\r\n#### 配置\r\n\r\n下面的例子演示如何配置 Groovy Markup 模板引擎：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.groovy();\r\n    }\r\n    \r\n    // Configure the Groovy Markup Template Engine...\r\n    @Bean\r\n    public GroovyMarkupConfigurer groovyMarkupConfigurer() {\r\n        GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer();\r\n        configurer.setResourceLoaderPath(\"/WEB-INF/\");\r\n        return configurer;\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<mvc:annotation-driven/>\r\n\r\n<mvc:view-resolvers>\r\n    <mvc:groovy/>\r\n</mvc:view-resolvers>\r\n\r\n<!-- Configure the Groovy Markup Template Engine... -->\r\n<mvc:groovy-configurer resource-loader-path=\"/WEB-INF/\"/>\r\n```\r\n\r\n#### 例子\r\n\r\n与传统的模板引擎不同，Groovy Markup 依赖于使用构建器语法的 DSL。下面的示例显示了一个 HTML 页面的示例模板：\r\n\r\n```groovy\r\nyieldUnescaped \'<!DOCTYPE html>\'\r\nhtml(lang:\'en\') {\r\n    head {\r\n        meta(\'http-equiv\':\'\"Content-Type\" content=\"text/html; charset=utf-8\"\')\r\n        title(\'My page\')\r\n    }\r\n    body {\r\n        p(\'This is an example of HTML contents\')\r\n    }\r\n}\r\n```\r\n\r\n### Script Views\r\n\r\nSpring 框架有一个内置的集成，用于使用 Spring MVC 和任何可以在 JSR-223 Java 脚本引擎上运行的模板库。我们已经测试了不同脚本引擎上的模板库：\r\n\r\n| Scripting Library       | Scripting Engine |\r\n| ----------------------- | ---------------- |\r\n| Handlebars              | Nashorn          |\r\n| Mustache                | Nashorn          |\r\n| React                   | Nashorn          |\r\n| EJS                     | Nashorn          |\r\n| ERB                     | JRuby            |\r\n| String templetes        | Jython           |\r\n| Kolin Script templating | Kolin            |\r\n\r\n#### Requirements\r\n\r\n需要由 Script 引擎在类路径，细节取决于不同的脚本引擎：\r\n\r\n- Nashorn JavaScript 引擎由 Java 8+. 提供。推荐使用最新版本。\r\n- JRuby 应该作为 Ruby 支持的依赖。\r\n- Jython 应该作为 Python 支持依赖被添加。\r\n- `org.jetbrains.kotlin:kotlin-script-util` 依赖和 META-INF/services/javax.script/ScriptEngineFactory 文件包含 `org.jetbrains.kotlin.script.jsr223.KotlinJsr223JvmLocalScriptEngineFactory` 线应该被添加作为 Kolin 脚本支持。\r\n\r\n你需要有脚本模板库。一种方法是通过 WebJars。\r\n\r\n#### Script Templates\r\n\r\n可以声明 ScriptTemplateConfigure bean 来指定脚本引擎，这个脚本引擎被加载，调用函数来渲染模板等。下面的例子是使用 Mustanche 模板和 Nashorn JavaScript 引擎：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.scriptTemplate();\r\n    }\r\n    \r\n    @Bean\r\n    public ScriptTemplateConfigurer configurer() {\r\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\r\n        configurer.setEngineName(\"nashorn\");\r\n        configurer.setScripts(\"mustache.js\");\r\n        configurer.setRenderObject(\"Mustache\");\r\n        configurer.setRenderFunction(\"render\");\r\n        return configurer;\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<mvc:annotation-driven/>\r\n\r\n<mvc:view-resolvers>\r\n    <mvc:script-template/>\r\n</mvc:view-resolvers>\r\n\r\n<mvc:script-template-configurer engine-name=\"nashorn\" render-object=\"Mustache\"\r\n                                render-function=\"render\">\r\n    <mvc:script location=\"mustache.js\"/>\r\n</mvc:script-template-configurer>\r\n```\r\n\r\n控制器对 Java 配置和 XML 配置都一样：\r\n\r\n```java\r\n@Controller\r\npublic class SampleController {\r\n    @GetMapping(\"/sample\")\r\n    public String test(Model model) {\r\n        model.addObject(\"title\", \"Sample title\");\r\n        model.addObject(\"body\", \"Sample body\");\r\n        return \"template\";\r\n    }\r\n}\r\n```\r\n\r\nMustache 模板：\r\n\r\n```html\r\n<html>\r\n    <head>\r\n        <title>{{title}}</title>\r\n    </head>\r\n    <body>\r\n        <p>{{body}}</p>\r\n    </body>\r\n</html>\r\n```\r\n\r\n渲染函数被调用以下参数：\r\n\r\n- String template：模板内容\r\n- Map model：视图模型\r\n- RenderingContext renderingContext：允许访问应用程序上下文、地区、模板加载程序和 URL 的 RenderingContext (自5.0)\r\n\r\nMustache.render() 与这个签名是一致的，所以您可以直接调用它。\r\n\r\n如果你需要自定义你的模板技术，你可以提供实现自定义渲染函数的脚本。例如，Handlerbars 需要在使用它们前编译模板并且需要多填充来模仿在服务器端脚本引擎中没有可用的浏览器设施。\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.scriptTemplate();\r\n    }\r\n    \r\n    @Bean\r\n    public ScriptTemplateConfigurer configurer() {\r\n        ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer();\r\n        configurer.setEngineName(\"nashorn\");\r\n        configurer.setScripts(\"polyfill.js\", \"handlebars.js\", \"render.js\");\r\n        configurer.setRenderFunction(\"render\");\r\n        configurer.setSharedEngine(false);\r\n        return configurer;\r\n    }\r\n}\r\n```\r\n\r\npolyfill.js 只定义 Handlebars 需要的 window 对象：\r\n\r\n```js\r\nvar window = {};\r\n```\r\n\r\n这个基本的 render.js 实现在使用之前编译模板。\r\n\r\n```js\r\nfunction render(template, model) {\r\n    var compiledTemplate = Handlebars.compile(template);\r\n    return compiledTemplate(model);\r\n}\r\n```\r\n\r\n### JSP and JSTL\r\n\r\nSpring 框架为 Spring MVC 内建集成 JSP 和 JSTL。\r\n\r\n#### 视图解析\r\n\r\n使用 JSP 开发时，你可以声明 InternalResourceViewResolver 或者 ResourceBundleViewResolver bean。\r\n\r\nResourceBundleViewResolver 依赖属性文件来定义视图名称映射到类和 URL。在 ResourceBundleViewResolver ，你可以只使用一个解析器混杂不同的视图类型：\r\n\r\n```xml\r\n<!-- the ResourceBundleViewResolver -->\r\n<bean id=\"viewResolver\" class=\r\n      \"org.springframework.web.servlet.view.ResourceBundleViewResolver\">\r\n    <property name=\"basename\" value=\"views\"/>\r\n</bean>\r\n\r\n# And a sample properties file is used (views.properties in WEB-INF/classes):\r\nwelcome.(class)=org.springframework.web.servlet.view.JstlView\r\n\r\nwelcome.url=/WEB-INF/jsp/welcome.jsp\r\nproductList.(class)=org.springframework.web.servlet.view.JstlView\r\nproductList.url=/WEB-INF/jsp/productlist.jsp\r\n```\r\n\r\nInternalResourceViewResovler 也可以给 JSP 使用。强烈建议把 JSP 文件放在 \'WEB-INF\' 目录下的目录，这样客户端不能直接访问。\r\n\r\n```xml\r\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\r\n    <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"/>\r\n    <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/>\r\n    <property name=\"suffix\" value=\".jsp\"/>\r\n</bean>\r\n```\r\n\r\n#### JSP vs JSTL\r\n\r\n当使用 JSP 标准标签库（JSTL）时，你必须使用特定的视图类，JstlView，正如 JSTL 需要在诸如 I18N 功能这样的事情之前准备好工作。\r\n\r\n#### Spring 的 JSP 标签库\r\n\r\nSpring 提供请求参数和命令对象的数据绑定。为了促进 JSP 页面的开发，与这些数据绑定特性相结合，Spring 提供了一些标签，使事情变得更容易。所有 Spring 标记都有 HTML escape 特性，以启用或禁用字符的逃离。\r\n\r\nspring.tld 标签库描述符（TLD）被包含在 spring-webmvc.jar。为了理解应用单个标签，浏览 API reference 或参见标签库秒速。\r\n\r\n#### Spring 的表单标签库\r\n\r\n在版本 2.0 中，Spring 提供了一组完整的数据绑定标签，用于在使用 JSP 和 Spring Web MVC 时处理表单元素。每个标记为其对应的 HTML 标记对应的属性集提供支持，使标签熟悉和直观使用。标记生成的 HTML 是 HTML 4.01/XHTML 1.0。\r\n\r\n不像其它 form/input 标签库，Spring 的表单标签库集成在 Spring Web MVC，提供标记访问您的控制器处理的命令对象和引用数据。\r\n\r\n##### 配置\r\n\r\n表单标签库捆绑在 spring-webmvc.jar。这个库描述符被称为 form.tld。\r\n\r\n为了使用这个库，添加下面的指令在 JSP 页面的顶部：\r\n\r\n```jsp\r\n<%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %>\r\n```\r\n\r\n##### form 标签\r\n\r\n这个标记呈现了一个 HTML 的表单元素，并向内部标记公开了绑定路径。它将命令对象放在 PageContext 中，以便通过内部标记访问命令对象。这个库中的所有其他标记都是表单标记的嵌套标记。\r\n\r\n假设我们有一个名为 User 的域对象。它是一个具有 firstName 和 lastName 等属性的 JavaBean。我们可以使用它作为表单控制器的表单支持对象，它返回 form.jsp。下面的示例显示 form.jsp：\r\n\r\n```jsp\r\n<form:form>\r\n    <table>\r\n        <tr>\r\n            <td>First Name:</td>\r\n            <td><form:input path=\"firstName\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Last Name:</td>\r\n            <td><form:input path=\"lastName\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\">\r\n                <input type=\"submit\" value=\"Save Changes\"/>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n\r\nfirstName 和 lastName 值是从页面控制器中放置在 PageContext 中的命令对象中检索的。继续阅读，查看更复杂的例子，说明内部标记是如何使用表单标记的。\r\n\r\n下面的列表显示生成的 HTML，它看起来像一个标准表单：\r\n\r\n```html\r\n<form method=\"POST\">\r\n    <table>\r\n        <tr>\r\n            <td>First Name:</td>\r\n            <td><input name=\"firstName\" type=\"text\" value=\"Harry\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Last Name:</td>\r\n            <td><input name=\"lastName\" type=\"text\" value=\"Potter\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\">\r\n                <input type=\"submit\" value=\"Save Changes\"/>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</form>\r\n```\r\n\r\n前面的 JSP 假定表单支持对象的变量名是命令。如果您将表单支持对象放入另一个名称，您可以将表单绑定到命名变量：\r\n\r\n```jsp\r\n<form:form modelAttribute=\"user\">\r\n    <table>\r\n        <tr>\r\n            <td>First Name:</td>\r\n            <td><form:input path=\"firstName\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td>Last Name:</td>\r\n            <td><form:input path=\"lastName\"/></td>\r\n        </tr>\r\n        <tr>\r\n            <td colspan=\"2\">\r\n                <input type=\"submit\" value=\"Save Changes\"/>\r\n            </td>\r\n        </tr>\r\n    </table>\r\n</form:form>\r\n```\r\n\r\n##### input 标签\r\n\r\n##### checkbox 标签\r\n\r\n##### checkboxes 标签\r\n\r\n##### rediobutton 标签\r\n\r\n##### rediobuttons 标签\r\n\r\n##### password 标签\r\n\r\n##### select 标签\r\n\r\n##### option 标签\r\n\r\n##### options 标签\r\n\r\n##### texterea 标签\r\n\r\n##### hidden 标签\r\n\r\n##### errors 标签\r\n\r\n##### HTTP Method Conversion\r\n\r\n##### HTML5 标签\r\n\r\n暂时跳过。。。\r\n\r\n### Tiles\r\n\r\n您可以将 Tile 集成到其他视图技术——在使用 Spring 的 web 应用程序中。这一节以一种广泛的方式描述了如何做到这一点。\r\n\r\n#### 依赖\r\n\r\n为了启用 Tile，你必须添加 Tiles 3.0.1或更高版本依赖以及它项目的传递依赖。\r\n\r\n#### 配置\r\n\r\n此外还必须通过使用包含定义信息和其它概念的文件配置它。在 Spring 是通过使用 TileConfigurer 来完成的：\r\n\r\n```xml\r\n<bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3.TilesConfigurer\">\r\n    <property name=\"definitions\">\r\n        <list>\r\n            <value>/WEB-INF/defs/general.xml</value>\r\n            <value>/WEB-INF/defs/widgets.xml</value>\r\n            <value>/WEB-INF/defs/administrator.xml</value>\r\n            <value>/WEB-INF/defs/customer.xml</value>\r\n            <value>/WEB-INF/defs/templates.xml</value>\r\n        </list>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n前面的例子定义了5个包含定义的文件。这些文件都在 WEB-INF/defs 文件夹下。在 WebApplicationContext 的初始化过程中，加载了文件，并初始化了定义工厂。在完成之后，包含在定义文件中的 Tiles 可以作为 Spring web 应用程序中的视图。为了能够使用视图，您必须有一个 ViewResolver，就像与 Spring 使用的任何其他视图技术一样。您可以使用两个实现 UrlBasedViewResolver 和 ResourceBundleViewResolver。\r\n\r\n你可以通过添加下划线来指定本地特定的 Tiles 定义：\r\n\r\n```xml\r\n<bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3.TilesConfigurer\">\r\n    <property name=\"definitions\">\r\n        <list>\r\n            <value>/WEB-INF/defs/tiles.xml</value>\r\n            <value>/WEB-INF/defs/tiles_fr_FR.xml</value>\r\n        </list>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n使用前面的配置，tiles_fr_FR.xml 用于 fr_FR 地区的请求，默认情况下使用 tiles.xml。\r\n\r\nUrlBasedViewResolver 为每个必须解析的视图初始化给定的 viewClass：\r\n\r\n```xml\r\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\">\r\n    <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.tiles3.TilesView\"/>\r\n</bean>\r\n```\r\n\r\nResourceBundleViewResolver 必须提供一个属性文件,它包含解析器可以使用的视图名称和视图类。下面的示例显示了一个ResourceBundleViewResolver 的 bean 定义,以及对应的视图名称和视图类：\r\n\r\n```xml\r\n<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view.ResourceBundleViewResolver\">\r\n    <property name=\"basename\" value=\"views\"/>\r\n</bean>\r\n```\r\n\r\n```properties\r\n...\r\nwelcomeView.(class)=org.springframework.web.servlet.view.tiles3.TilesView\r\nwelcomeView.url=welcome (this is the name of a Tiles definition)\r\n\r\nvetsView.(class)=org.springframework.web.servlet.view.tiles3.TilesView\r\nvetsView.url=vetsView (again, this is the name of a Tiles definition)\r\n\r\nfindOwnersForm.(class)=org.springframework.web.servlet.view.JstlView\r\nfindOwnersForm.url=/WEB-INF/jsp/findOwners.jsp\r\n...\r\n```\r\n\r\n当您使用 ResourceBundleViewResolver 时，您可以轻松地混合不同的视图技术。\r\n\r\n注意，TilesView 类支持 JSTL (JSP标准标记库)。\r\n\r\n##### SimpleSpringPreparerFactory and SpringBeanPreparerFactory  \r\n\r\n作为一个高级特性，Spring 也支持两个特殊的 Tiles PerparerFactory 实现。有关如何在您的 Tile 定义文件中使用 ViewPreparer 引用的细节，请参阅Tiles 文档。\r\n\r\n您可以指定 SimpleSpringPreparerFactory 为基于指定的 preparer 类自动注入 ViewPreparer 实例，应用 Spring 的容器回调和应用配置的 SpringBeanPostprocessors。如果 Spring 的上下文广泛的注释配置被激活，ViewPreparer 类中的注解会自动被检测和应用。请注意，这个期望在 Tiles 定义文件中准备了 preparer 类，就像默认的 PreparerFactory 所做的那样。\r\n\r\n您可以指定 SpringBeanPreparerFactory 来操作指定的 preparer names(而不是类)，从 DispatcherServlet 的应用程序上下文中获取相应的Spring bean。在本例中，完整的 bean 创建过程是在对 Spring 应用程序上下文的控制中，允许使用显式依赖注入配置、域 bean 等。请注意，您需要为每个 preparer 名定义一个 Spring bean 定义(就像在您的 Tiles 定义中使用一样)。下面的示例展示了如何在 TilesConfigurer bean 上定义SpringBeanPreparerFactory 属性：\r\n\r\n```xml\r\n<bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3.TilesConfigurer\">\r\n    <property name=\"definitions\">\r\n        <list>\r\n            <value>/WEB-INF/defs/general.xml</value>\r\n            <value>/WEB-INF/defs/widgets.xml</value>\r\n            <value>/WEB-INF/defs/administrator.xml</value>\r\n            <value>/WEB-INF/defs/customer.xml</value>\r\n            <value>/WEB-INF/defs/templates.xml</value>\r\n        </list>\r\n    </property>\r\n    \r\n    <!-- resolving preparer names as Spring bean definition names -->\r\n    <property name=\"preparerFactoryClass\"\r\n              value=\"org.springframework.web.servlet.view.tiles3.SpringBeanPreparerFactory\"/>\r\n    \r\n</bean>\r\n```\r\n\r\n### RSS and Atom\r\n\r\nAbstractAtomFeedView 和 AbstractRssFeedView 都继承自 AbstractFeedView，分别用来提供 Atom 和 RSS Feed 视图。它们是基于 java.net\'s ROME 项目并且位于 `org.springframeword.wewb.servlet.view.feed` 包。\r\n\r\nAbstractAtomFeedView 要求你实现 buildFeedEntries() 方法，可选的覆盖 buildFreedMetadata() 方法（默认实现为空）。\r\n\r\n```java\r\npublic class SampleContentAtomView extends AbstractAtomFeedView {\r\n    \r\n    @Override\r\n    protected void buildFeedMetadata(Map<String, Object> model,\r\n                                     Feed feed, HttpServletRequest request) {\r\n        // implementation omitted\r\n    }\r\n    \r\n    @Override\r\n    protected List<Entry> buildFeedEntries(Map<String, Object> model,\r\n                                           HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n        // implementation omitted\r\n    }\r\n}\r\n```\r\n\r\nAbstractRssFeedView 也相似：\r\n\r\n```java\r\npublic class SampleContentRssView extends AbstractRssFeedView {\r\n    \r\n    @Override\r\n    protected void buildFeedMetadata(Map<String, Object> model,\r\n                                     Channel feed, HttpServletRequest request) {\r\n        // implementation omitted\r\n    }\r\n    \r\n    @Override\r\n    protected List<Item> buildFeedItems(Map<String, Object> model,\r\n                                        HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n        // implementation omitted\r\n    }\r\n}\r\n```\r\n\r\nbuildFeedItems() 和 buildFeedEntries() 方法在 HTTP 请求中传递，如果您需要访问 Locale。HTTP 响应只在 cookie 或其他 HTTP 头的设置中传递。在方法返回后，提要将自动写入响应对象。\r\n\r\n### PDF and Excel\r\n\r\nSpring 提供了返回输出的方法，除了 HTML，包括 PDF 和 Excel 电子表格。本节描述如何使用这些特性。\r\n\r\n#### 文档视图介绍\r\n\r\nHTML 页面并不总是最好的方法来查看模型输出，Spring 使得通过模型数据动态生成 PDF 文档或 Excel 电子表格很简单。文档是视图，并从服务器流到正确的内容类型，以使客户端 PC 运行他们的电子表格或 PDF 查看程序的响应。\r\n\r\n为了使用 Excel 视图，你需要添加 Apache POI 库到类路径。对于 PDF，需要添加（最好）OpenPDF 库。\r\n\r\n#### PDF 视图\r\n\r\n一个对于 word list 的简单 PDF 视图可以继承自 `org.springframework.web.serlvet.view.document.AbstractPdfView` 并且实现 buildPdfDocument() 方法。\r\n\r\n```java\r\npublic class PdfWordList extends AbstractPdfView {\r\n    \r\n    protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer,\r\n                                    HttpServletRequest request, HttpServletResponse response) throws Exception {\r\n        List<String> words = (List<String>) model.get(\"wordList\");\r\n        for (String word : words) {\r\n            doc.add(new Paragraph(word));\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n控制器可以从外部视图定义（引用它的名称）或从处理程序方法中返回这样的视图。\r\n\r\n#### Excel 视图\r\n\r\n从 Spring 框架 4.2 起，`org.springframwork.web.serlvet.view.document.AbstractXlsView` 作为 Excel 视图的基类被提供。它基于 Apache POI，有专门的子类（AbstactXlsxView 和 AbstractXlsxStreamingView）代替过时的 `AbstractExcelView ` 类。\r\n\r\n编程方式和 AbstractPdfView 相似。使用 buildExcelDocument() 作为中央模板方法和控制器能够从外部定义或从处理程序方法中返回这样的视图。\r\n\r\n### Jackson\r\n\r\nSpring 提供 Jackson JSON 库支持。\r\n\r\n#### Jackson-based JSON MVC Views\r\n\r\n`MappingJackson2JsonView` 用 Jackson 库的 ObjectMapper 来渲染响应内容为 JSON。默认的，模型映射（除了框架指定的类）的整个内容都以 JSON 编码。对于需要筛选映射的内容的情况，您可以使用 modelKeys 属性指定特定的模型属性集。您还可以使用 extractValueFromSingleKeyModel 属性在提取和序列化的单键模型中具有值，而不是模型属性映射。\r\n\r\n您可以根据需要使用 Jackson 提供的注解自定义 JSON 映射。当您需要进一步控制时，您可以通过 ObjectMapper 属性注入一个自定义 ObjectMapper 到你需要提供自定义 JSON 序列化和反序列化器的地方。\r\n\r\n#### Jackson-based XML Views\r\n\r\n`MappingJackson2XmlView` 使用 Jackson XML extension‘s XmlMapper 去渲染响应内容为 XML。如果模型包含多个条目，你应该通过 modelKey bean 属性明确设置对象被序列化。如果包含单个条目，它会自动被序列化。\r\n\r\n可以自定义 XML 映射，需要使用 JAXB 或 Jackson 提供的注解。要进一步控制时，你可以通过 ObjectMapper 属性注入自定义的 XmlMapper 。\r\n\r\n### XML Marshalling\r\n\r\nMarshallingView 使用 XML Marshaller（定义在 `org.springframework.oxm` 包）来渲染响应内容为 XML。你可以通过 MarshallingView 实例的 modelKey bean 属性显式设置对象被编组。或者，视图遍历所有模型属性，并对由 Marshaller 支持的第一个类型进行排序。\r\n\r\n### XSLT Views\r\n\r\nXSLT 是 XML 的转换语言，在 web 应用程序中作为视图技术很受欢迎。如果您的应用程序自然地处理 XML，或者您的模型很容易转换为 XML，XSLT可以成为一种良好的视图技术。下面的部分展示了如何生成 XML 文档作为模型数据，并在 Spring Web MVC 应用程序中与 XSLT 转换。\r\n\r\n这个示例是一个简单的 Spring 应用程序，它在控制器中创建了一个单词列表，并将它们添加到模型映射中。映射返回，以及我们的 XSLT 视图的视图名称。XSLT 控制器将单词列表转换成一个用于转换的简单 XML 文档。\r\n\r\n#### Beans\r\n\r\n配置是简单 Spring web 应用程序的标准：MVC 配置必须定义 XsltViewResolver bean和正则 MVC 注解配置。\r\n\r\n```java\r\n@EnableWebMvc\r\n@ComponentScan\r\n@Configuration\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Bean\r\n    public XsltViewResolver xsltViewResolver() {\r\n        XsltViewResolver viewResolver = new XsltViewResolver();\r\n        viewResolver.setPrefix(\"/WEB-INF/xsl/\");\r\n        viewResolver.setSuffix(\".xslt\");\r\n        return viewResolver;\r\n    }\r\n}\r\n```\r\n\r\n#### Controllers\r\n\r\n我们还需要一个控制器来封装我们的单词生成逻辑。\r\n\r\n```java\r\n@Controller\r\npublic class XsltController {\r\n    \r\n    @RequestMapping(\"/\")\r\n    public String home(Model model) throws Exception {\r\n        Document document = DocumentBuilderFactory.newInstance()\r\n            .newDocumentBuilder().newDocument();\r\n        Element root = document.createElement(\"wordList\");\r\n        \r\n        List<String> words = Arrays.asList(\"Hello\", \"Spring\", \"Framework\");\r\n        for (String word : words) {\r\n            Element wordNode = document.createElement(\"word\");\r\n            Text textNode = document.createTextNode(word);\r\n            wordNode.appendChild(textNode);\r\n            root.appendChild(wordNode);\r\n        }\r\n        \r\n        model.addAttribute(\"wordList\", root);\r\n        return \"home\";\r\n    }\r\n}\r\n```\r\n\r\n到目前为止，我们只创建了 DOM 文档并将其添加到模型映射中。请注意，您还可以将 XML 文件加载为资源并使用它而不是定制 DOM 文档。\r\n\r\n有一些软件包可以自动 “domify” 的对象图，但是，在 Spring，中，您可以通过您选择的任何方式从您的模型中创建 DOM，您将具有完全的灵活性。这可以防止 XML 在模型数据的结构中扮演得太大的角色，在使用工具来管理DOMification 过程时，这是一种危险。\r\n\r\n#### Transformation\r\n\r\n最后，XsltViewResolver 解析了 “home” XSLT 模板文件，并将 DOM 文档合并到它中生成我们的视图。正如在 XsltViewResolver 配置中所示，XSLT 模板放在 WEB-INF/xsl 目录中的 war 文件中，并以 xslt 文件扩展结束。\r\n\r\n下面的示例展示了一个 XSLT 转换：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\r\n<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\">\r\n    \r\n    <xsl:output method=\"html\" omit-xml-declaration=\"yes\"/>\r\n    \r\n    <xsl:template match=\"/\">\r\n        <html>\r\n            <head><title>Hello!</title></head>\r\n            <body>\r\n                <h1>My First Words</h1>\r\n                <ul>\r\n                    <xsl:apply-templates/>\r\n                </ul>\r\n            </body>\r\n        </html>\r\n    </xsl:template>\r\n    \r\n    <xsl:template match=\"word\">\r\n        <li><xsl:value-of select=\".\"/></li>\r\n    </xsl:template>\r\n    \r\n</xsl:stylesheet>\r\n```\r\n\r\n前面的转换呈现为以下HTML：\r\n\r\n```html\r\n<html>\r\n    <head>\r\n        <META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\r\n            <title>Hello!</title>\r\n            </head>\r\n        <body>\r\n            <h1>My First Words</h1>\r\n            <ul>\r\n                <li>Hello</li>\r\n                <li>Spring</li>\r\n                <li>Framework</li>\r\n            </ul>\r\n        </body>\r\n        </html>\r\n```\r\n\r\n## MVC 配置\r\n\r\nMVC Java 配置和 MVC XML 命名空间提供适合大多数应用程序的默认配置和提供配置 API 去自定义它们。其它在配置 API 无法访问的更高级的自定义可以参见 Advanced Java Config 和 Advanced XML Config。\r\n\r\n你不需要理解由 MVC Java 配置和XML命名空间创建的基础 beans。如果想要学习更多，可以参见 Special Bean Types 和 Web MVC Config。\r\n\r\n### 启用 MVC 配置\r\n\r\n在 Java 配置，你可以用 @EnableWebMvc 注解来启用 MVC 配置。\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig {\r\n}\r\n```\r\n\r\n在 XML 命名空间，可以用 `<mvc:annotation-driven>` 元素启用 MVC 配置：\r\n\r\n```xml \r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/mvc\r\n                           https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\r\n    \r\n    <mvc:annotation-driven/>\r\n    \r\n</beans>\r\n```\r\n\r\n前面的示例注册了一些 Spring MVC 基础设施 bean，并适应了类路径(例如,JSON、XML和其他的有效负载转换器)的依赖关系。\r\n\r\n### MVC Config API\r\n\r\n在 Java 配置，你可以实现 WebMvcConfigurer 接口：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n\r\n    // Implement configuration methods...\r\n}\r\n```\r\n\r\n在 XML，你可以检查 `<mvc:annotation-driven />`属性和子元素。你可以参见 Spring MVC XML schema 或使用 IDE 代码补全查看可用的属性和子元素。\r\n\r\n### Type Conversion\r\n\r\n在默认的格式化器， 安装了 Number 和 Date 类型，包括 @NumberFormat 和 @DateTimeFormat 注解支持。如果 Joda-Time 在类路径上，那么对 Joda-Time 格式库的完全支持也会安装。\r\n\r\n在 Java 配置，你可以注册自定义格式化器和转换器：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addFormatters(FormatterRegistry registry) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n在 XML ：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/mvc\r\n                           https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\r\n    \r\n    <mvc:annotation-driven conversion-service=\"conversionService\"/>\r\n    \r\n    <bean id=\"conversionService\"\r\n          class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\">\r\n        <property name=\"converters\">\r\n            <set>\r\n                <bean class=\"org.example.MyConverter\"/>\r\n            </set>\r\n        </property>\r\n        <property name=\"formatters\">\r\n            <set>\r\n                <bean class=\"org.example.MyFormatter\"/>\r\n                <bean class=\"org.example.MyAnnotationFormatterFactory\"/>\r\n            </set>\r\n        </property>\r\n        <property name=\"formatterRegistrars\">\r\n            <set>\r\n                <bean class=\"org.example.MyFormatterRegistrar\"/>\r\n            </set>\r\n        </property>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### Validation\r\n\r\n默认情况，如果 Bean Validation 在当前类路径（如，Hibernate Validator），LocalValidatorFactoryBean 被作为全局 Validator 注册给在 @Controller 方法参数的 @Valid 和 @Validated 使用。\r\n\r\n在 Java 配置，你可以自定义全局 Validator 实例：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public Validator getValidator(); {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n在 XML：\r\n\r\n```xml\r\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/mvc\r\n                           https://www.springframework.org/schema/mvc/spring-mvc.xsd\">\r\n    \r\n    <mvc:annotation-driven validator=\"globalValidator\"/>\r\n    \r\n</beans>\r\n```\r\n\r\n注意，你也可以注册本地 Validator 实现：\r\n\r\n```java\r\n@Controller\r\npublic class MyController {\r\n    \r\n    @InitBinder\r\n    protected void initBinder(WebDataBinder binder) {\r\n        binder.addValidators(new FooValidator());\r\n    }\r\n}\r\n```\r\n\r\n提示：如果需要在某些地方注入 LocalValidatorFactoryBean，创建并用 @Primary 标记它，以避免和 MVC 配置的 bean 冲突。\r\n\r\n### Interceptors\r\n\r\n在 Java 配置，你可以注册拦截器以应用于传入的请求：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addInterceptors(InterceptorRegistry registry) {\r\n        registry.addInterceptor(new LocaleChangeInterceptor());\r\n        registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/admin/**\");\r\n        registry.addInterceptor(new SecurityInterceptor()).addPathPatterns(\"/secure/*\");\r\n    }\r\n}\r\n```\r\n\r\n一样 XML ：\r\n\r\n```xml\r\n<mvc:interceptors>\r\n    <bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\"/>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/**\"/>\r\n        <mvc:exclude-mapping path=\"/admin/**\"/>\r\n        <bean class=\"org.springframework.web.servlet.theme.ThemeChangeInterceptor\"/>\r\n    </mvc:interceptor>\r\n    <mvc:interceptor>\r\n        <mvc:mapping path=\"/secure/*\"/>\r\n        <bean class=\"org.example.SecurityInterceptor\"/>\r\n    </mvc:interceptor>\r\n</mvc:interceptors>\r\n```\r\n\r\n### Content Types\r\n\r\n你可以配置 Spring MVC 如何从请求中确定所请求的媒体类型（例如，Accept 头，URL 路径扩展，查询参数等）。\r\n\r\n默认情况，首先检查 URL 路径扩展——json、xml、rss 和 atom 注册的已知扩展（取决于类路径的依赖）。Accept 第二检查。\r\n\r\n只考虑更改默认的 Accept 头，如果必须使用基于 URL 内容类型，考虑使用查询参数策略而不是路径扩展。\r\n\r\n在 Java 配置，你可以自定义请求内容类型解决：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {\r\n        configurer.mediaType(\"json\", MediaType.APPLICATION_JSON);\r\n        configurer.mediaType(\"xml\", MediaType.APPLICATION_XML);\r\n    }\r\n}\r\n```\r\n\r\n在 XML：\r\n\r\n```xml\r\n<mvc:annotation-driven content-negotiation-manager=\"contentNegotiationManager\"/>\r\n<bean id=\"contentNegotiationManager\" class=\"org.springframework.web.accept.ContentNegotiationManagerFactoryBean\">\r\n    <property name=\"mediaTypes\">\r\n        <value>\r\n            json=application/json\r\n            xml=application/xml\r\n        </value>\r\n    </property>\r\n</bean>\r\n```\r\n\r\n### Message Converters\r\n\r\n可以自定义 HttpMessageConverter，用 Java 配置通过重写 configureMessageConverters()（代替由 Spring MVC 创建的默认转化器） 或者 extendMessageConverters()（自定义默认的转换器或添加额外的转换器）。\r\n\r\n下面的通过自定义 ObjectMapper 实例例子添加 XML 和 Jackson JSON 转换器：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfiguration implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {\r\n        Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder()\r\n            .indentOutput(true)\r\n            .dateFormat(new SimpleDateFormat(\"yyyy-MM-dd\"))\r\n            .modulesToInstall(new ParameterNamesModule());\r\n        converters.add(new MappingJackson2HttpMessageConverter(builder.build()));\r\n        converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build()));\r\n    }\r\n}\r\n```\r\n\r\n在前面的例子，Jackson2ObjectMapperBuilder 用来给 MappingJackson2HttpMessageConverter 和 MappingJackson2XmlHttpMessageConverter 创建通用的配置，启用缩进、自定义 date 格式和注册 jackson-module-parameter-names，这增加了对参数名称的支持（在Java 8中添加的一个特性）。\r\n\r\n这个 builder 自定义的默认属性如下：\r\n\r\n- 禁用 DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES。\r\n- 禁用 MapperFeature.DEFAULT_VIEW_INCLUSION。\r\n\r\n如果它们在类路径上被检测到，它也会自动地注册以下已知的模块：\r\n\r\n- jackson-datatype-jdk7：支持 Java 7类型，如 java.nio.file.Path。\r\n- jackson-datatype-jods：支持 Joda-Time 类型。\r\n- jackson-datatype-jsr310：支持 Java 8 Date 和 Time API 类型。\r\n- jackson-datatype-jdk8：支持其它 Java 8 类型，例如 Optional。\r\n\r\n注意：启用 Jackson XML 缩进需要 woodstox-core-asl 依赖，除了 jackson-dataformat-xml。\r\n\r\n其它可用的集成 Jackson 模块：\r\n\r\n- jackson-datatype-money：支持 `javax.money` 类型（非官方模块）。\r\n- jackson-datatype-hibernate：支持 Hibernate 特殊类型和属性（包括懒加载切面）。\r\n\r\n下面的例子展示一样的 XML配置：\r\n\r\n```xml\r\n<mvc:annotation-driven>\r\n    <mvc:message-converters>\r\n        <bean class=\"org.springframework.http.converter.json.MappingJackson2HttpMessageConverter\">\r\n            <property name=\"objectMapper\" ref=\"objectMapper\"/>\r\n        </bean>\r\n        <bean class=\"org.springframework.http.converter.xml.MappingJackson2XmlHttpMessageConverter\">\r\n            <property name=\"objectMapper\" ref=\"xmlMapper\"/>\r\n        </bean>\r\n    </mvc:message-converters>\r\n</mvc:annotation-driven>\r\n\r\n<bean id=\"objectMapper\" class=\"org.springframework.http.converter.json.Jackson2ObjectMapperFactoryBean\"\r\n      p:indentOutput=\"true\"\r\n      p:simpleDateFormat=\"yyyy-MM-dd\"\r\n      p:modulesToInstall=\"com.fasterxml.jackson.module.paramnames.ParameterNamesModule\"/>\r\n\r\n<bean id=\"xmlMapper\" parent=\"objectMapper\" p:createXmlMapper=\"true\"/>\r\n```\r\n\r\n### View Controllers\r\n\r\n这是定义一个 ParameterizableViewController 的快捷方式,它在调用时立即转发到视图。你可以在静态情况下使用它，当在视图生成响应之前没有 Java 控制器逻辑来执行。\r\n\r\n下面的 Java 配置演示了转发 \'/\' 请求到名为 \'home\' 的视图：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addViewControllers(ViewControllerRegistry registry) {\r\n        registry.addViewController(\"/\").setViewName(\"home\");\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<mvc:view-controller path=\"/\" view-name=\"home\"/>\r\n```\r\n\r\n### View Resolvers\r\n\r\n下面的例子演示 Java 配置使用 JSP 和 Jackson 配置内容协商视图解析，作为 JSON 呈现的默认视图：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n\r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.enableContentNegotiation(new MappingJackson2JsonView());\r\n        registry.jsp();\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<mvc:view-resolvers>\r\n    <mvc:content-negotiation>\r\n        <mvc:default-views>\r\n            <bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\"/>\r\n        </mvc:default-views>\r\n    </mvc:content-negotiation>\r\n    <mvc:jsp/>\r\n</mvc:view-resolvers>\r\n```\r\n\r\n然而，请注意，FreeMarker、Tiles、Groovy Markup 和脚本模板还需要对底层视图技术进行配置。\r\n\r\nMVC 名称空间提供了专用元素。下面的例子配置 FreeMarker：\r\n\r\n```xml\r\n<mvc:view-resolvers>\r\n    <mvc:content-negotiation>\r\n        <mvc:default-views>\r\n            <bean class=\"org.springframework.web.servlet.view.json.MappingJackson2JsonView\"/>\r\n        </mvc:default-views>\r\n    </mvc:content-negotiation>\r\n    <mvc:freemarker cache=\"false\"/>\r\n</mvc:view-resolvers>\r\n\r\n<mvc:freemarker-configurer>\r\n    <mvc:template-loader-path location=\"/freemarker\"/>\r\n</mvc:freemarker-configurer>\r\n```\r\n\r\n在 Java 配置中，您可以添加相应的 Configurer bean，如下面的示例：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n\r\n    @Override\r\n    public void configureViewResolvers(ViewResolverRegistry registry) {\r\n        registry.enableContentNegotiation(new MappingJackson2JsonView());\r\n        registry.freeMarker().cache(false);\r\n    }\r\n\r\n    @Bean\r\n    public FreeMarkerConfigurer freeMarkerConfigurer() {\r\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\r\n        configurer.setTemplateLoaderPath(\"/freemarker\");\r\n        return configurer;\r\n    }\r\n}\r\n```\r\n\r\n### Static Resources\r\n\r\n这个选项提供了一种方便的方法，可以从基于 Resource 的位置的列表中服务静态资源。\r\n\r\n在下一个例子，给定一个以 \'/resources\' 开头的请求，这个相对路径用于查找和服务相对于应用程序根目录下 \'/public\' 或类路径下 \'/static\' 的静态资源。资源将在未来一年到期，以确保浏览器缓存的最大使用，以及浏览器发出的 HTTP 请求的减少。Last-Modified 头也被评估，如果存在，则返回 304 状态码。\r\n\r\nJava 配置：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n        registry.addResourceHandler(\"/resources/**\")\r\n            .addResourceLocations(\"/public\", \"classpath:/static/\")\r\n            .setCachePeriod(31556926);\r\n    }\r\n}\r\n```\r\n\r\nXML ：\r\n\r\n```xml\r\n<mvc:resources mapping=\"/resources/**\"\r\n               location=\"/public, classpath:/static/\"\r\n               cache-period=\"31556926\" />\r\n```\r\n\r\n资源处理器也支持 ResourceResolver 实现和 ResourceTransformer 实现链，你可以用它创建工具链用来处理优化的资源。\r\n\r\n你可以用 VersionResourceResovler 版本化资源 URL，基于内容计算 MD5 哈希、确定的应用版本或其他。\r\n\r\n下面的例子演示如何在 Java 配置使用 VersionResourceResolver：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\r\n        registry.addResourceHandler(\"/resources/**\")\r\n            .addResourceLocations(\"/public/\")\r\n            .resourceChain(true)\r\n            .addResolver(new VersionResourceResolver().addContentVersionStrategy(\"/**\"));\r\n    }\r\n}\r\n```\r\n\r\n在 XML：\r\n\r\n```xml\r\n<mvc:resources mapping=\"/resources/**\" location=\"/public/\">\r\n    <mvc:resource-chain resource-cache=\"true\">\r\n        <mvc:resolvers>\r\n            <mvc:version-resolver>\r\n                <mvc:content-version-strategy patterns=\"/**\"/>\r\n            </mvc:version-resolver>\r\n        </mvc:resolvers>\r\n    </mvc:resource-chain>\r\n</mvc:resources>\r\n```\r\n\r\n然后，你可以使用 ResourceUrlProvider 重写 URL，并应用完整的 resolvers 和 transformer ——例如，插入版本。MVC 配置提供了一个 ResourceUrlProvider bean，这样它就可以被注入其他的 bean 中。你还可以用 ResourceUrlEncodingFilter 对 Thymeleaf、JSP、FreeMarker 和其他使用 HttpServletResponse#encodeURL() 的URL 标记进行重写。\r\n\r\n注意，当使用 EncodedResourceResolver （例如，用于服务 gzipped或 brotli-encoded 资源）和 VersionResourceResolver 时，你必须以这个顺序注册它们。这确保基于内容的版本总是可靠地计算，基于未编码的文件。\r\n\r\nWebJars 也通过 WebJarsResourceResolver 来支持，它在`org.webjars:webjars-locator-core` 库在类路劲上时自动注册。这个解析器可以重写 URL，包括 jar 的版本，也可以与没有版本的 URL 相匹配——例如，从 \'/jquery/jquery.min.js\' 到 \'/jquery/1.2.0/jquery.min.js\'。\r\n\r\n### Default Servlet\r\n\r\nSpring MVC 允许映射 DispatcherServlet 到 \'/\' （因此覆盖容器默认 Serlvet 的映射），也允许通过容器默认的 Servlet 处理静态资源请求。它用 ‘/**\' URL 映射配置一个 DefaultServletHttpRequestHandler ，它相对于其它 URL 映射优先级最低。\r\n\r\n这个处理器转发所有请求到默认 Servlet。因此，它必须保持在所有其他URL handler 映射的顺序的最后。如果你配置了 \\<mvc:annotation-driven> ，情况是这样的。或者，如果您建立了自定义的 HandlerMapping 实例，一定要将其 order 属性设置为低于 DefaultServletHttpRequestHandler 的值，它是 Integer.MAX_VALUE。\r\n\r\n下面的示例展示了如何使用默认设置启用该特性：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r\n        configurer.enable();\r\n    }\r\n}\r\n```\r\n\r\n一样的 XML：\r\n\r\n```xml\r\n<mvc:default-servlet-handler/>\r\n```\r\n\r\n重写 \'/\' Servlet 映射的警告是，默认 Servlet 中的 RequestDispatcher 必须以名称而不是路径检索。DefaultServletHttpRequestHandler 试图在启动时自动检测容器的默认 Servlet，使用主要 Servlet 容器（包括Tomcat、Jetty、GlassFish、JBoss、Resin、WebLogic 和 WebSphere）的已知名称列表。如果默认的 Servlet 被用不同的名字自定义了或者如果使用默认 Servlet 名字未知的 Servlet 容器，那么你必须显式提供默认的 Servlet 名字，如下面的例子：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\r\n        configurer.enable(\"myCustomDefaultServlet\");\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<mvc:default-servlet-handler default-servlet-name=\"myCustomDefaultServlet\"/>\r\n```\r\n\r\n### Path Matching\r\n\r\n你可以定制与路径匹配和处理 URL 相关的选项。具体请参考 PathMatchConfigurer javadoc。\r\n\r\n下面的例子是在 Java 配置自定义路径匹配的：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebMvc\r\npublic class WebConfig implements WebMvcConfigurer {\r\n    \r\n    @Override\r\n    public void configurePathMatch(PathMatchConfigurer configurer) {\r\n        configurer\r\n            .setUseSuffixPatternMatch(true)\r\n            .setUseTrailingSlashMatch(false)\r\n            .setUseRegisteredSuffixPatternMatch(true)\r\n            .setPathMatcher(antPathMatcher())\r\n            .setUrlPathHelper(urlPathHelper())\r\n            .addPathPrefix(\"/api\",\r\n                           HandlerTypePredicate.forAnnotation(RestController.class));\r\n    }\r\n    \r\n    @Bean\r\n    public UrlPathHelper urlPathHelper() {\r\n        //...\r\n    }\r\n    \r\n    @Bean\r\n    public PathMatcher antPathMatcher() {\r\n        //...\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML ：\r\n\r\n```xml\r\n<mvc:annotation-driven>\r\n    <mvc:path-matching\r\n                       suffix-pattern=\"true\"\r\n                       trailing-slash=\"false\"\r\n                       registered-suffixes-only=\"true\"\r\n                       path-helper=\"pathHelper\"\r\n                       path-matcher=\"pathMatcher\"/>\r\n</mvc:annotation-driven>\r\n\r\n<bean id=\"pathHelper\" class=\"org.example.app.MyPathHelper\"/>\r\n<bean id=\"pathMatcher\" class=\"org.example.app.MyPathMatcher\"/>\r\n```\r\n\r\n### Advanced Java Config\r\n\r\n@EnableWebMvc 导入 DelegationWebMvcConfiguration：\r\n\r\n- 为Spring MVC 应用提供默认 Spring 配置\r\n- 检测和委派 WebMvcConfigurer 实现来自定义配置\r\n\r\n对于高级模式，你可以移除 @EnableWebMvc 并且直接扩展 DelegationWebMvcConfiguration 而不是实现 WebMvcConfigurer：\r\n\r\n```java\r\n@Configuration\r\npublic class WebConfig extends DelegatingWebMvcConfiguration {\r\n\r\n    // ...\r\n}\r\n```\r\n\r\n你可以在 WebConfig 中保留现有的方法，但是你现在也可以覆盖来自基类的 bean 声明，你还可以有任意数量的 WebMvcConfigurer 实现在类路径上。\r\n\r\n### Advanced XML Config\r\n\r\nMVC 名称空间没有高级模式。如果你需要在一个你无法在其它地方更改的 bean 上自定义一个属性，你可以使用 Spring ApplicationContext 的 BeanPostProcessor 生命周期钩子，如下面的示例：\r\n\r\n```java\r\n@Component\r\npublic class MyPostProcessor implements BeanPostProcessor {\r\n\r\n    public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n注意你需要声明 MyPostProcessor 为 bean，要么在 XML 显式声明，要么让他通过 \'\\<component-scan>\' 被检测。\r\n\r\n## HTTP/2\r\n\r\nServlet 4 容器被要求支持 HTTP/2，Spring Framework 5 和 Servlet API 4 相容的。从编程模型的角度来看，应用程序不需要做什么。然而，还有与服务器配置相关的考虑。更多细节参见 HTTP/2 wiki 页。\r\n\r\nServlet API 公开了与 HTTP/2 相关的一个构造。你可以使用 `javax.servlet.http.PushBuilder` 主动将资源推送给客户端，并将其作为 @RequestMapping 方法的方法参数支持。\r\n\r\n# REST 客户端\r\n\r\n## RestTemplate\r\n\r\nRestTemplate 是完成 HTTP 请求的同步客户机。它是原始的 Spring REST 客户端，并在底层的 HTTP 客户端库中公开了一个简单的模板方法 API。\r\n\r\n参见 integration.pdf 1.8.1。\r\n\r\n## WebClient\r\n\r\nWebClient 是一个非阻塞的、反应性的客户端来执行 HTTP 请求。它是在 5.0 中引入的，提供了一个现代的 RestTemplate 选项，有效地支持同步和异步，以及流媒体场景。\r\n\r\n与 RestTemplate 相比，WebClient 支持以下内容：\r\n\r\n- 非阻塞 IO。\r\n- 响应式流。\r\n- 高并发性，硬件资源较少。\r\n- 函数风格，由 Java 8 lambdas 带来的流畅的 API。\r\n- 同步和异步交互。\r\n- 从服务器流入或流出。\r\n\r\n\r\n\r\n# 测试\r\n\r\n本节总结 Spring MVC 应用程序的 Spring 测试中可用的选项。\r\n\r\n- Servlet API 模拟：用于单元测试控制器、过滤器和其他 web 组件的 Servlet API 合同的模拟实现。有关更多细节，请参见 Servlet API 模拟对象。\r\n- TestContext 框架：支持在 JUnit 和 TestNG 测试中加载 Spring 配置，包括在测试方法和支持使用模型上下文加载 WebApplicationContext 的测试方法和支持的有效缓存。有关更多细节，请参见 TestContext 框架。\r\n- Spring MVC 测试：一个框架，也被称为 MockMvc，通过 DispatcherServlet 测试带注释的控制器(即支持注释)，使用 Spring MVC 基础结构，但没有 HTTP 服务器。参见 Spring MVC 测试，了解更多细节。\r\n- 客户端 REST：spring-test 提供了一个 MockRestServiceServer，您可以作为模拟服务器来测试内部使用 RestTemplate 的客户端代码。请参阅客户端 REST 测试，以了解更多细节。\r\n- WebTestClient：为测试 WebFlow 应用程序而建立，但是它也可以用于端到端集成测试，到任何服务器，超过 HTTP 连接。它是一个非阻塞、反应性的客户机，非常适合测试异步和流媒体场景。\r\n\r\n# WebSockets\r\n\r\n文档这部分涵盖 Servlet stack、WebSocket信息，包括 raw WebSocket、通过 SckJS 仿真 WebSocket 和通过 WebSocket 子协议 STOMP 发布-订阅信息。\r\n\r\n## WebSocket 介绍\r\n\r\nWebSocket 协议 RFC 6455 提供标准的方式，在单个 TCP 连接上建立一个全双的、双向的通信通道。它是来自 HTTP 的一个不同的 TCP 协议，而是设计用于处理 HTTP，使用端口 80 和 443，允许重用现有的防火墙规则。\r\n\r\nWebSocket 交互从使用 HTTP  Upgrade 头升级的 HTTP 请求开始，或者在这种情况下切换到 WebSocket 协议。下面的示例显示了这样的交互：\r\n\r\n```http\r\nGET /spring-websocket-portfolio/portfolio HTTP/1.1\r\nHost: localhost:8080\r\nUpgrade: websocket ①\r\nConnection: Upgrade ②\r\nSec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg==\r\nSec-WebSocket-Protocol: v10.stomp, v11.stomp\r\nSec-WebSocket-Version: 13\r\nOrigin: http://localhost:8080\r\n```\r\n\r\n① Upgrade 头。\r\n\r\n② 使用 Upgrade 连接。\r\n\r\n代替常用的 200 状态码，支持 WebSocket 的服务器返回类似下面的输出：\r\n\r\n```http\r\nHTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0=\r\nSec-WebSocket-Protocol: v10.stomp\r\n```\r\n\r\n在成功的握手之后，HTTP 升级请求的 TCP 套接字仍然为客户端和服务器打开，以继续发送和接收消息。\r\n\r\n注意，如果 WebSocket 服务器运行在 web 服务器上（如 nginx），你可能需要配置它来传递 WebSocket 升级请求到 WebSocket 服务器。同样，如果应用程序在云环境中运行，请检查与 WebSocket 支持有关的云提供者的说明。\r\n\r\n\r\n\r\n### HTTP vs WebSocket\r\n\r\n尽管 WebSocket 被设计成具有 HTTP 兼容的，并从 HTTP 请求开始，但重要的是要理解这两个协议导致了非常不同的架构和应用程序编程模型。\r\n\r\n在 HTTP 和 REST，应用程序被建模为很多 URL。要与应用程序交互，客户端访问这些 URL，请求-响应风格。服务器路由请求基于 HTTP URL、方法和头的适当的处理程序。\r\n\r\n相比之下，在 WebSocket 中，最初的连接通常只有一个 URL。随后，所有应用程序消息传输都在相同的 TCP 连接。这指向一个完全不同的异步、事件驱动的消息传递体系结构。\r\n\r\nWebSocket 也低等级传输协议，不像 HTTP，不给消息的内容提供任何语义。这意味着除非客户端和服务器在消息语义上达成一致，否则就没有办法路由或处理消息。\r\n\r\nWebSocket 客户端和服务器可以通过 HTTP 握手请求通过 Sec-WebSocket-Protocol 协议头来协商使用更高级别的消息传递协议(例如，STOMP)。在没有这样的情况下，他们需要想出自己的约定。\r\n\r\n### 何时使用 WebSocket\r\n\r\nWebSocket 可以动态或插入生成一个 web 页面。然而，在很多情况，结合 Ajax 和 HTTP 流或长轮询可以提供简单高效的解决方法。\r\n\r\n例如，新闻、邮件和社会信息需要动态更新，每个几分钟这样做可能完全可以。合作、游戏和财政 app，需要更接近实时。\r\n\r\n延迟并不是决定因素。如果消息的数量相对较低（例如，监视网络故障），HTTP 流或轮询可以提供一个有效的解决方案。低延迟、高频和高l流量的组合，为使用 WebSocket 提供最好的理由。\r\n\r\n同时要记住，在互联网上，在你的控制之外的限制性代理可能会阻止 WebSocket 的交互，要么是因为它们没有被配置为通过 Upgrade 头，要么是因为他们关闭了看起来空闲的长期存在的连接。这意味着，在防火墙内部使用 WebSocket 对内部应用程序来说是一个比公共应用程序更直接的决定。\r\n\r\n## WebSocket API\r\n\r\nSpring 框架提供一个 WebSocket API，你可以用它来写处理 WebSocket 信息的客户端和服务端应用。\r\n\r\n### WebSocketHandler\r\n\r\n创建 WebSocket 服务器很简单，实现 WebSocketHandler ，或与此相似的继承 TextWebSocketHandler 或 BinaryWebSocketHandler 中的一个：\r\n\r\n```java\r\nimport org.springframework.web.socket.WebSocketHandler;\r\nimport org.springframework.web.socket.WebSocketSession;\r\nimport org.springframework.web.socket.TextMessage;\r\n\r\npublic class MyHandler extends TextWebSocketHandler {\r\n\r\n    @Override\r\n    public void handleTextMessage(WebSocketSession session, TextMessage message) {\r\n        // ...\r\n    }\r\n}\r\n```\r\n\r\n有专门的 WebSocket Java 配置和 XML 名称空间支持将前面的 WebSocket 处理程序映射到一个特定的 URL，如下面的显示：\r\n\r\n```java\r\nimport org.springframework.web.socket.config.annotation.EnableWebSocket;\r\nimport org.springframework.web.socket.config.annotation.WebSocketConfigurer;\r\nimport org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;\r\n\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n    \r\n    @Override\r\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\r\n        registry.addHandler(myHandler(), \"/myHandler\");\r\n    }\r\n    \r\n    @Bean\r\n    public WebSocketHandler myHandler() {\r\n        return new MyHandler();\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <websocket:handlers>\r\n        <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/>\r\n    </websocket:handlers>\r\n    \r\n    <bean id=\"myHandler\" class=\"org.springframework.samples.MyHandler\"/>\r\n</beans>\r\n```\r\n\r\n前面的例子用于 Spring MVC 应用，并且应该被包含到 DispatcherServlet 配置。然而，Spring\'s WebSocket 支持独立于 Spring MVC。在 WebSocketHandler 的帮助下，将一个 WebSocketHandler 集成到其他 HTTP 服务环境中是相对简单的。\r\n\r\n当使用 WebSocketHandler API 直接 vs 间接时，例如通过 STOMP 信息，应用程序必须同步发送消息，因为潜在的标准 WebSocket 会话(JSR-356)不允许并发发送。一种选择是使用 ConcurrentWebSocketSessionDecorator 包装 WebSocketSession。\r\n\r\n### WebSocket Handshake\r\n\r\n自定义初始 HTTP WebSocket 握手请求最简单的方法是通过 HandshakeInterceptor，它公开方法“before”和“after” 握手。你可以用这样的拦截器去z阻止握手或生成任意在 WebSocketSession 可以访问的属性。下面的示例使用内置的拦截器将 HTTP 会话属性传递给 WebSocket 会话：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n    \r\n    @Override\r\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\r\n        registry.addHandler(new MyHandler(), \"/myHandler\")\r\n            .addInterceptors(new HttpSessionHandshakeInterceptor());\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <websocket:handlers>\r\n        <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/>\r\n        <websocket:handshake-interceptors>\r\n            <bean class=\"org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor\"/>\r\n        </websocket:handshake-interceptors>\r\n    </websocket:handlers>\r\n    \r\n    <bean id=\"myHandler\" class=\"org.springframework.samples.MyHandler\"/>\r\n</beans>\r\n```\r\n\r\n更高级的选项是扩展 DefaultHandshakeHandler 执行 WebSocket 握手的步骤，包括验证客户端来源、谈判子协议和其他细节。如果需要配置自定义请求者策略，则需要使用这个选项，以适应 WebSocket 服务器引擎和尚未支持的版本(参见 部署 )。Java 配置和 XML 名称空间使得配置自定义握手器成为可能。\r\n\r\n*提示：Spring 提供了一个 WebSocketHandlerDecorator 基类，您可以使用它来装饰一个带有额外行为的 WebSocketHandler。在使用 WebSocket Java 配置或 XML 名称空间时，默认情况下提供和添加异常处理实现。ExceptionWebSocketHandlerDecorator 捕获从任何 WebSocketHandler 方法中出现的所有未捕获的异常，以 1011 状态关闭 WebSocket 会话，意味着服务器错误。*\r\n\r\n### 部署\r\n\r\nSpring WebSocket API 很容易集成到 Spring MVC 应用程序中，在此应用程序中，DispatcherServlet 同时服务于 HTTP WebSocket handshake 和其他 HTTP 请求。通过调用 WebSocketHttpRequestHandler ，也很容易集成到其他 HTTP 处理场景中。这很方便，也很容易理解。然而，特别考虑到 JSR-356 运行时。\r\n\r\nJava WebSocket API （JSR-356）提供了两种部署机制。第一种是在启动时调用 Servlet 容器类路径扫描。另外一种是在 Servlet 容器初始化时使用的注册 API。这些机制使单个 “front controller” 处理所有 HTTP 请求成为可能，包括 WebSocket handshake 和所有其它像 Spring MVC 的 DispathcerServlet 的 HTTP 请求。\r\n\r\nJSR-356 一个重要的限制是，当在JSR-356运行时运行时，Spring\'s WebSocket 支持地址具有服务器特定的请求者策略实现。目前对于Tomcat、Jetty、GlassFish、WebLogic、WebSphere 和 Undertow(和WildFly)都有这样的策略。\r\n\r\n次要的考虑是，使用 JSR-356 支持的 Servlet 容器将执行一个 ServletContainerInitializer（SCI）扫描，可以在某些情况下，极大地减缓应用程序启动。如果在一个基于 JSR-356 支持的 Servlet 容器版本升级后观察到一个重要的影响，那么就应该有可能通过在 web.xml 中使用 `<absolute-ordering />` 元素来有选择地启用或禁用 web 片段（和SCI扫描）：\r\n\r\n```xml\r\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"\r\n                             http://java.sun.com/xml/ns/javaee\r\n                             https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\r\n         version=\"3.0\">\r\n    \r\n    <absolute-ordering/>\r\n    \r\n</web-app>\r\n```\r\n\r\n然后，您可以有选择地启用名称的 web 片段，比如 Spring 自己的SpringServletContainerInitializer ，它为 Servlet 3 Java 初始化 API 提供支持。\r\n\r\n```xml\r\n<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\r\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n         xsi:schemaLocation=\"\r\n                             http://java.sun.com/xml/ns/javaee\r\n                             https://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\r\n         version=\"3.0\">\r\n\r\n    <absolute-ordering>\r\n        <name>spring_web</name>\r\n    </absolute-ordering>\r\n\r\n</web-app>\r\n```\r\n\r\n### 服务器配置\r\n\r\n每个底层的 WebSocket 引擎都暴露了控制运行时特性的配置属性，比如消息缓冲区大小、空闲超时和其他的配置。\r\n\r\n对于 Tomcat、WildFly 和 GlassFish，你可以添加 ServletServerContainerFactoryBean 到你的 WebSocket Java 配置：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n    \r\n    @Bean\r\n    public ServletServerContainerFactoryBean createWebSocketContainer() {\r\n        ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean();\r\n        container.setMaxTextMessageBufferSize(8192);\r\n        container.setMaxBinaryMessageBufferSize(8192);\r\n        return container;\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <bean class=\"org.springframework...ServletServerContainerFactoryBean\">\r\n        <property name=\"maxTextMessageBufferSize\" value=\"8192\"/>\r\n        <property name=\"maxBinaryMessageBufferSize\" value=\"8192\"/>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n注意：对于客户端的配置，你应该使用 WebSocketContainerFactoryBean （XML） 或 ContainerProver.getWebSocketContainer() （Java 配置）。\r\n\r\n对于Jettty，你需要支持预配置 Jetty WebSocketServerFactory 和通过你的 WebSocket Java 配置 把它插入到 Spring 的 DefaultHandshakeHandler。\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n    \r\n    @Override\r\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\r\n        registry.addHandler(echoWebSocketHandler(),\r\n                            \"/echo\").setHandshakeHandler(handshakeHandler());\r\n    }\r\n    \r\n    @Bean\r\n    public DefaultHandshakeHandler handshakeHandler() {\r\n        WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior.SERVER);\r\n        policy.setInputBufferSize(8192);\r\n        policy.setIdleTimeout(600000);\r\n        return new DefaultHandshakeHandler(\r\n            new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy)));\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <websocket:handlers>\r\n        <websocket:mapping path=\"/echo\" handler=\"echoHandler\"/>\r\n        <websocket:handshake-handler ref=\"handshakeHandler\"/>\r\n    </websocket:handlers>\r\n    \r\n    <bean id=\"handshakeHandler\" class=\"org.springframework...DefaultHandshakeHandler\">\r\n        <constructor-arg ref=\"upgradeStrategy\"/>\r\n    </bean>\r\n    \r\n    <bean id=\"upgradeStrategy\" class=\"org.springframework...JettyRequestUpgradeStrategy\">\r\n        <constructor-arg ref=\"serverFactory\"/>\r\n    </bean>\r\n    \r\n    <bean id=\"serverFactory\" class=\"org.eclipse.jetty...WebSocketServerFactory\">\r\n        <constructor-arg>\r\n            <bean class=\"org.eclipse.jetty...WebSocketPolicy\">\r\n                <constructor-arg value=\"SERVER\"/>\r\n                <property name=\"inputBufferSize\" value=\"8092\"/>\r\n                <property name=\"idleTimeout\" value=\"600000\"/>\r\n            </bean>\r\n        </constructor-arg>\r\n    </bean>\r\n</beans>\r\n```\r\n\r\n### 允许跨域\r\n\r\n作为 Spring Framework 4.1.5，接受同源请求为 WebSocket 和 SockJS 的默认行为。也可以允许所有或指定的起源列表。这个检查主要是为浏览器客户设计的。没有任何东西可以防止其他类型的客户机修改原点头的值。\r\n\r\n三个可能的行为是：\r\n\r\n- 只允许同源请求（默认）：在这个模式，当 SockJS 被启用，Iframe HTTP 请求头 X-Frame-Options 被设置成 SAMEORIGIN，同时 JSONP 转换被禁用，因为它不允许检查请求的来源。因此，当启用此模式时，IE6 和 IE7 不支持。\r\n- 允许指定列表中的源：对于每个源必须以 \'http://\' 或 \'https://\' 开头。在这个模式，当 SockJS 启用，Iframe 转换被禁用。因此，这个模式不支持 IE 6 到 IE 9。\r\n- 允许所有源：为了启用这个模式，你应该提供 * 作为允许源的值。在这个模式，所有转换都可以访问。\r\n\r\n你可以配置 WebSocket 和 SockJS 允许源：\r\n\r\n```java\r\nimport org.springframework.web.socket.config.annotation.EnableWebSocket;\r\nimport org.springframework.web.socket.config.annotation.WebSocketConfigurer;\r\nimport org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n    \r\n    @Override\r\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\r\n        registry.addHandler(myHandler(), \"/myHandler\").setAllowedOrigins(\"https://mydomain.com\");\r\n    }\r\n    \r\n    @Bean\r\n    public WebSocketHandler myHandler() {\r\n        return new MyHandler();\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <websocket:handlers allowed-origins=\"https://mydomain.com\">\r\n        <websocket:mapping path=\"/myHandler\" handler=\"myHandler\" />\r\n    </websocket:handlers>\r\n    \r\n    <bean id=\"myHandler\" class=\"org.springframework.samples.MyHandler\"/>\r\n</beans>\r\n```\r\n\r\n## SockJS Fallabck\r\n\r\n在公共互联网上，在您的控制之外的限制性代理可能会阻止 WebSocket 交互，要么是因为它们没有被配置为通过 Upgrade 头，要么是因为它们关闭了看似空闲的长期连接。\r\n\r\n这个问题的解决办法是 WebSocket 仿真——也就是，试图首先使用 WebSocket，然后在基于 HTTP 的技术上后退，这些技术模仿 WebSocket 交互，并公开相同的应用程序级别的 API。\r\n\r\n在 Servlet 堆，Spring 框架提供了 SockJS 协议的服务器(以及客户机)支持。\r\n\r\n### Overview\r\n\r\nSockJS 的目标是让应用程序使用 WebSocket API，但在运行时，如果不需要更改应用程序代码，就可以返回非 WebSocket 选项。\r\n\r\nSOckJS 的组成：\r\n\r\n- 来自 narrated tests 的 SockJS 协议定义。\r\n- SockJS JavaScript 客户端——在浏览器使用的客户端库。\r\n- SockJS 服务实现，包括一个在 Spring 框架的 spring-websocket。\r\n\r\nSockJS 被设计用于浏览器。它使用不同的技术支持广泛的浏览器版本。传输在三个一般类别中下降：WebSocket、HTTP 流和 HTTP 长轮询。\r\n\r\nSockJS 客户端通过发送 GET /info 开始从服务器获取基本信息。然后，必须决定使用哪个传输。如果可能，WebSocket 被使用。如果不行，大多数浏览器至少有一个 HTTP 流选项。如果不行，使用 HTTP 长轮询。\r\n\r\n所有传输请求都有以下 URL 结构：\r\n\r\n```\r\nhttp://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport}\r\n```\r\n\r\n- {server - id} 对于集群中的路由请求很有用，但其它情况不使用。\r\n- {session - id} 关联 HTTP 请求属于 SockJS 会话。\r\n- {transport} 表示传输类型（例如，websocket、xhr-streaming等）。\r\n\r\nWebSocket 传输只需要一个 HTTP 请求来进行 WebSocket 握手。此后，所有消息都在该插座上交换。\r\n\r\nHTTP 传输需要更多的请求。Ajax/XHR 流，例如依赖于长运行的请求和额外的 HTTP POST 请求对 client-to-server 信息。长轮询也是类似，除了在每个 server-to-client 发送后结束当前的请求。\r\n\r\nSockJS 添加极小的信息框架。例如，服务器最初发送字母 ‘o\'（打开帧），信息被作为 a[\"message1\", \"message2\"] 发送，字母 \'h\' （头帧）如果 25 秒没有信息流（默认），字母 ’c‘ （关闭帧）来关闭会话。\r\n\r\n### 启用 SockJS\r\n\r\n你可以通过 Java 配置启用 SockJS：\r\n\r\n```java\r\n@Configuration\r\n@EnableWebSocket\r\npublic class WebSocketConfig implements WebSocketConfigurer {\r\n\r\n    @Override\r\n    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {\r\n        registry.addHandler(myHandler(), \"/myHandler\").withSockJS();\r\n    }\r\n\r\n    @Bean\r\n    public WebSocketHandler myHandler() {\r\n        return new MyHandler();\r\n    }\r\n}\r\n```\r\n\r\n等价的 XML：\r\n\r\n```xml\r\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\r\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n       xmlns:websocket=\"http://www.springframework.org/schema/websocket\"\r\n       xsi:schemaLocation=\"\r\n                           http://www.springframework.org/schema/beans\r\n                           https://www.springframework.org/schema/beans/spring-beans.xsd\r\n                           http://www.springframework.org/schema/websocket\r\n                           https://www.springframework.org/schema/websocket/spring-websocket.xsd\">\r\n    \r\n    <websocket:handlers>\r\n        <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/>\r\n        <websocket:sockjs/>\r\n    </websocket:handlers>\r\n    \r\n    <bean id=\"myHandler\" class=\"org.springframework.samples.MyHandler\"/>\r\n</beans>\r\n```\r\n\r\n前面的示例用于 Spring MVC 应用程序，并应该包含在 DispatcherServlet 的配置中。然而，Spring 的 WebSocket 和 SockJS 支持并不依赖于 Spring MVC。在S ockJsHttpRequestHandler 的帮助下，在其他 HTTP 服务环境中集成是相对简单的。\r\n\r\n在浏览器方面,应用程序可以使用 sockjs-client(1.0.x)。它模拟 W3C WebSocket API，并与服务器通信，以选择最好的传输选项，这取决于它运行的浏览器。查看 sockjs-client 页面和浏览器支持的传输类型列表。客户端还提供了几个配置选项——例如，指定要包括哪些传输。\r\n\r\n### IE 8 和 IE 9\r\n\r\nInternet Explorer 8 和 9 仍在使用中。他们是拥有 SockJS 的关键原因。本节涉及在这些浏览器中运行的重要考虑。\r\n\r\nSockJS 客户端支持 Ajax/XHR 在 IE 8 和 9 中使用微软的XDomainRequest。这在跨域工作，但不支持发送 cookie。对于 Java 应用程序来说，cookie通常是必不可少的。然而，由于 SockJS 客户端可以使用许多服务器类型(不只是 Java)，所以需要知道 cookie 是否重要。如果是这样的话，SockJS 客户端更喜欢 Ajax/XHR 的流。否则，它依赖于基于程序的技术。\r\n\r\nSockJS 客户端的第一个 /info 请求是对信息的请求，可以影响客户机选择的传输。其中一个细节是服务器应用程序是否依赖于 cookie(例如，为了身份验证目的或带有粘性会话的集群)。Spring 的 SockJS 支持包括一个名为sessionCookieNeeded 的属性。默认情况下启用它，因为大多数 Java 应用程序都依赖于 JSESSIONID cookie。如果您的应用程序不需要，,您可以关闭这个选项，SockJS 客户端应该在 IE 8 和 9 中选择 xdr-streaming。\r\n\r\n如果您使用了 ifram-based 传输，请记住，浏览器可以被指示通过设置 HTTP 响应头 x-Frame-Option 来阻止在给定页面上使用 iframe，以DENY、SAMEORIGIN 或 ALLOW-FROM\\<origin>。这是用来防止 clickjacking 的。\r\n\r\n剩下的跳过。。。\r\n\r\n### 心跳\r\n\r\nSockJS 协议要求服务器发送心跳消息，以阻止代理得出连接挂起的结论。Spring SockJS 配置有一个名为 “heartbeatTime” 的属性，您可以使用它来定制频率。默认情况下，在25秒后发送一个心跳，假设没有其他消息在连接上发送。这25秒的价值符合 IETF 对公共互联网应用的推荐。\r\n\r\nSpring SockJS 支持还允许您配置任务调度程序来安排心跳任务。任务调度程序由线程池支持，默认设置基于可用处理器的数量。你应该根据你的具体需要考虑定制设置。\r\n\r\n### 客户端断开连接\r\n\r\nHTTP 流和 HTTP 长轮轮询 SockJS 传输需要连接的时间比平时更长。\r\n\r\n在 Servlet 容器中，这是通过 Servlet 3 异步支持完成的，它允许退出 Servlet 容器线程，处理请求，并继续从另一个线程写入响应。\r\n\r\n一个特定的问题是，Servlet API 不为已经消失的客户机提供通知。然而，Servlet 容器在后续尝试写入响应时引发异常。由于 Spring 的 SockJS 服务支持服务器发送的心跳(默认情况下每25秒)，这意味着客户端断开通常在这个时间段内检测到(或较早时,如果消息更频繁地发送)。\r\n\r\n### SockJS 和 CORS\r\n\r\n如果你允许跨源请求，SockJS 协议在 XHR 流和轮询传输中使用 CORS 进行跨域支持。因此，CORS 头自动添加，除非检测到 CORS 头的出现。所以，如果应用程序已经配置提供 CORS 支持，Spring 的 SockJsService 会跳过这部分。\r\n\r\n在 Spring 的 SockJsService 中设置 suppressCors 属性也可以禁用。\r\n\r\nSockJS 期望下面的头和值：\r\n\r\n- Access-Control-Allow-Origin：从 Origin 请求头的值初始化。\r\n- Access-Control-Allow-Credentials：总是设置为 true。\r\n- Access-Control-Request-Headers：从等价的请求头的值初始化。\r\n- Access-Control-Allow-Methods：传输支持的 HTTP 方法。\r\n- Access-Control-Max-Age：设置成 31536000（一年）。\r\n\r\n对于具体的实现，在源代码中看到 addCorsHeaders 在AbstractSockJsService 和 TransportType 枚举类型。\r\n\r\n或者，如果 CORS 配置允许它，请考虑将 URL 与 SockJS 端点前缀排除在一起，从而允许 Spring 的 SockJsService 处理它。\r\n\r\n### SockJsClient\r\n\r\nSpring 提供了一个 SockJS Java 客户端，以连接到不使用浏览器的远程 SockJS 端点。当在公共网络(即网络代理可以排除使用 WebSocket 协议)的情况下，需要在两个服务器之间进行双向通信时，这一点特别有用。SockJS Java 客户端对于测试目的也非常有用(例如，模拟大量并发用户)。\r\n\r\nSockJS Java 客户端支持 websocket、xhr-streaming 和 xhr-polling 传输。\r\n\r\n剩下的只有在浏览器中使用的意义。\r\n\r\n你可以用下面的配置 WebSocketTransport：\r\n\r\n- StandardWebSocketClient 在 JSR-356 运行时。\r\n- JettyWebSocketClient 使用 Jetty 9+ 本地 WebSocket API。\r\n- 所有 Spring WebSocketClient 的实现。\r\n\r\n通过定义，一个 XhrTransport 支持 xhr-streaming 和 xhr-polling，因为从客户机的角度来看，除了连接到服务器的 URL 之外，没有任何区别。目前有两个实现：\r\n\r\n- RestTemplateXhrTransport 使用 Spring 的 RestTemplate 来进行 HTTP 请求。\r\n- JettyXhrTransport 使用 Jetty 的 HttpClient 进行 HTTP 请求。\r\n\r\n下面的例子展示创建 SockJS 客户端和连接到 SockJS 端点：\r\n\r\n```java\r\nList<Transport> transports = new ArrayList<>(2);\r\ntransports.add(new WebSocketTransport(new StandardWebSocketClient()));\r\ntransports.add(new RestTemplateXhrTransport());\r\n\r\nSockJsClient sockJsClient = new SockJsClient(transports);\r\nsockJsClient.doHandshake(new MyWebSocketHandler(), \"ws://example.com:8080/sockjs\");\r\n```\r\n\r\n提示：SockJS 使用 JSON 格式数组信息。默认使用 Jackson 2 ，它要在类路径。此外，你可以配置自定义 SockJsMessageCodec 实现和在 SockJsClient 配置它。\r\n\r\n要使用 SockJsClient 来模拟大量并发用户，您需要配置底层的 HTTP 客户机(XHR 传输)，以允许足够数量的连接和线程。下面的例子展示了如何与 Jetty 一起做：\r\n\r\n```java\r\nHttpClient jettyHttpClient = new HttpClient();\r\njettyHttpClient.setMaxConnectionsPerDestination(1000);\r\njettyHttpClient.setExecutor(new QueuedThreadPool(1000));\r\n```\r\n\r\n下面的示例展示了服务器端 SockJS 相关的属性(请参见javadoc的详细信息)，您还应该考虑定制：\r\n\r\n```java\r\n@Configuration\r\npublic class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport {\r\n    \r\n    @Override\r\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\r\n        registry.addEndpoint(\"/sockjs\").withSockJS()\r\n            .setStreamBytesLimit(512 * 1024)\r\n            .setHttpMessageCacheSize(1000)\r\n            .setDisconnectDelay(30 * 1000);\r\n    }\r\n    \r\n    // ...\r\n}\r\n```\r\n\r\n## STOMP\r\n\r\nWebSocket 协议定义两种信息类型（text 和 binary），但是它们内容是未定义的。协议为客户端和服务器协商子协议（也就是说更高级内容协议）定义一种机制，用于 WebSocket 之上使用，来定义每个可以发送的消息、格式、每个消息的内容等等。子协议的使用是可选的，但是，不管怎样，客户端和服务器需要在定义消息内容的协议上达成一致。\r\n\r\n### Overview\r\n\r\nSTOMP（Simple Text Oriented Messaging Protocol）最初是为脚本语言(如Ruby、Python 和 Perl)创建的，以连接到企业消息代理。它的目的是解决通常使用的消息传递模式的最小子集。STOMP 可用于任何可靠的双向流媒体协议，如 TCP 和 WebSocket。虽然 STOMP 是一种面向文本的协议，但消息负载可以是文本或二进制。\r\n\r\nSTOMP 是一个基于框架的协议，它的框架是在 HTTP 上建模的。下面的清单显示了一个 STOMP 的结构：\r\n\r\n```\r\nCOMMAND\r\nheader1:value1\r\nheader2:value2\r\n\r\nBody^@\r\n```\r\n\r\n客户机可以使用发送或订阅命令发送或订阅消息，以及一个目标头，它描述消息的内容，以及谁应该接收它。这使得您可以使用一个简单的发布-订阅机制来将消息通过代理传递给其他连接的客户端，或者将消息发送到服务器，以要求执行一些工作。\r\n\r\n当您使用 Spring 的 STOMP 支持时，Spring WebSocket 应用程序充当了客户机的 STOMP 代理。消息被路由到 @Controller 的消息处理方法，或者是一个简单的内存中的代理，它跟踪订阅并向订阅的用户播放消息。您还可以配置 Spring 与专门的 STOMP 代理(如 RabbitMQ、ActiveMQ 和其他)来处理消息的实际传播。在这种情况下，Spring 与代理保持 TCP 连接，将消息传递给它，并将消息从它传递到连接的 WebSocket 客户端。因此，Spring web 应用程序可以依赖于统一的基于 HTTP 的安全性、共同的验证和一个熟悉的消息处理编程模型。\r\n\r\n下面的示例显示了一个客户端订阅的股票报价，服务器可以周期性地发出(例如，通过一个计划的任务，通过 SimpMessagingTemplate 向代理发送消息)：\r\n\r\n```\r\nSUBSCRIBE\r\nid:sub-1\r\ndestination:/topic/price.stock.*\r\n\r\n^@\r\n```\r\n\r\n下面的示例显示了一个发送一个贸易请求的客户端，服务器可以通过 @MessageMapping 方法处理这个请求：\r\n\r\n```\r\nSEND\r\ndestination:/queue/trade\r\ncontent-type:application/json\r\ncontent-length:44\r\n\r\n{\"action\":\"BUY\",\"ticker\":\"MMM\",\"shares\",44}^@\r\n```\r\n\r\n在执行之后，服务器可以向客户发送一个交易确认消息和详细信息。\r\n\r\n目的地的意思是故意在 STOMP 规范中不透明。它可以是任何字符串，而且完全由 STOMP 服务器来定义它们支持的目的地的语义和语法。然而，对于目的地来说，这是很常见的，比如在 /topic/.. 上的路径。意味着发布-订阅(一对多)和 /queue/ 点对点(一对一)消息交换。\r\n\r\nSTOMP 服务器可以使用消息命令向所有订阅者发送消息。下面的示例显示了向订阅客户发送股票报价的服务器：\r\n\r\n```\r\nMESSAGE\r\nmessage-id:nxahklf6-1\r\nsubscription:sub-1\r\ndestination:/topic/price.stock.MMM\r\n\r\n{\"ticker\":\"MMM\",\"price\":129.45}^@\r\n```\r\n\r\n服务器不能发送未经请求的消息。来自服务器的所有消息都必须响应特定的客户订阅，而服务器消息的 subscription-id 头必须与客户端订阅的 id 头匹配。\r\n\r\n前面的概述旨在为 STOMP 协议提供最基本的理解。我们建议全面审查协议规范。\r\n\r\n### Benefits\r\n\r\n后面部分暂时跳过。。。\r\n\r\n', '阅读 Spring 指导文件 spring-mvc 部分的笔记', '鸡米花', 'IMG_3331.JPG', '1', '14', '5', '2021-08-15 00:19:00', '2021-08-22 14:07:14');
INSERT INTO `t_blog` VALUES ('7', 'Test Title', 'Test Content', 'Test Outline', null, 'IMG_3331.JPG', '1', '3', null, '2021-08-15 00:19:01', '2021-08-22 14:07:02');
INSERT INTO `t_blog` VALUES ('8', 'Test Title', 'Test Content', 'Test Outline', null, 'IMG_3331.JPG', '1', '0', null, '2021-08-15 00:19:01', '2021-08-15 00:19:01');
INSERT INTO `t_blog` VALUES ('9', 'Test Title', 'Test Content', 'Test Outline', null, 'IMG_3331.JPG', '1', '1', null, '2021-08-15 00:19:02', '2021-08-15 00:19:02');
INSERT INTO `t_blog` VALUES ('10', 'Test Title', 'Blog 10', 'Test Outline', null, 'IMG_3331.JPG', '1', '0', null, '2021-08-15 00:19:03', '2021-08-22 13:39:26');

-- ----------------------------
-- Table structure for t_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_blog_tag`;
CREATE TABLE `t_blog_tag` (
  `blog_id` int(11) NOT NULL,
  `tag_id` int(11) NOT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_blog_tag
-- ----------------------------
INSERT INTO `t_blog_tag` VALUES ('2', '9');
INSERT INTO `t_blog_tag` VALUES ('3', '4');
INSERT INTO `t_blog_tag` VALUES ('3', '8');
INSERT INTO `t_blog_tag` VALUES ('3', '9');
INSERT INTO `t_blog_tag` VALUES ('4', '6');
INSERT INTO `t_blog_tag` VALUES ('4', '8');
INSERT INTO `t_blog_tag` VALUES ('4', '9');
INSERT INTO `t_blog_tag` VALUES ('5', '7');
INSERT INTO `t_blog_tag` VALUES ('5', '8');
INSERT INTO `t_blog_tag` VALUES ('5', '9');
INSERT INTO `t_blog_tag` VALUES ('6', '4');
INSERT INTO `t_blog_tag` VALUES ('6', '5');
INSERT INTO `t_blog_tag` VALUES ('6', '8');
INSERT INTO `t_blog_tag` VALUES ('6', '9');

-- ----------------------------
-- Table structure for t_comment
-- ----------------------------
DROP TABLE IF EXISTS `t_comment`;
CREATE TABLE `t_comment` (
  `co_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `content` varchar(255) DEFAULT NULL,
  `blog_id` int(11) NOT NULL,
  `parent_id` int(11) DEFAULT NULL,
  `is_deleted` tinyint(1) DEFAULT '0',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`co_id`)
) ENGINE=InnoDB AUTO_INCREMENT=21 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_comment
-- ----------------------------
INSERT INTO `t_comment` VALUES ('4', '鸡米花', '', '你好', '4', null, null, '2021-08-17 16:09:17', '2021-08-17 16:09:17');
INSERT INTO `t_comment` VALUES ('5', '杨', '', '第二条评论！', '4', null, null, '2021-08-17 16:12:17', '2021-08-17 16:12:17');
INSERT INTO `t_comment` VALUES ('6', '起', '', 'hello', '4', null, null, '2021-08-17 16:14:20', '2021-08-17 16:14:20');
INSERT INTO `t_comment` VALUES ('7', '我', '', '你也好', '4', null, null, '2021-08-17 16:14:43', '2021-08-17 16:14:43');
INSERT INTO `t_comment` VALUES ('8', '匿名', '', '回复第三条评论', '4', '5', null, '2021-08-17 16:57:03', '2021-08-17 16:57:03');
INSERT INTO `t_comment` VALUES ('9', '鸡米花', '', '评论一', '5', null, null, '2021-08-17 19:05:30', '2021-08-17 19:05:30');
INSERT INTO `t_comment` VALUES ('10', '杨', '', '评论二', '5', null, null, '2021-08-17 19:05:44', '2021-08-17 19:05:44');
INSERT INTO `t_comment` VALUES ('11', '林', '', '评论三', '5', null, null, '2021-08-17 19:05:56', '2021-08-17 19:05:56');
INSERT INTO `t_comment` VALUES ('12', '黄', '', '回复鸡米花评论一', '5', '9', null, '2021-08-17 19:06:11', '2021-08-17 19:06:11');
INSERT INTO `t_comment` VALUES ('13', '谢', '', '回复“黄”的回复', '5', '12', null, '2021-08-17 19:06:43', '2021-08-17 19:06:43');
INSERT INTO `t_comment` VALUES ('14', '是我', '', '你好', '2', null, null, '2021-08-17 22:31:42', '2021-08-17 22:31:42');
INSERT INTO `t_comment` VALUES ('15', '是你', '', '你也好', '2', '14', null, '2021-08-17 22:32:03', '2021-08-17 22:32:03');
INSERT INTO `t_comment` VALUES ('16', '是他', '', '大家都好', '2', '15', null, '2021-08-17 22:32:18', '2021-08-17 22:32:18');
INSERT INTO `t_comment` VALUES ('17', '李', '', '回复“谢”的评论', '5', '13', null, '2021-08-17 23:46:09', '2021-08-17 23:46:09');
INSERT INTO `t_comment` VALUES ('18', 'OK', '', '回复“杨”', '5', '10', null, '2021-08-17 23:47:14', '2021-08-17 23:47:14');
INSERT INTO `t_comment` VALUES ('19', '他', '', '再加一个回复', '5', null, null, '2021-08-17 23:49:07', '2021-08-17 23:49:07');
INSERT INTO `t_comment` VALUES ('20', '你好', '', '哦哦', '5', null, null, '2021-08-17 23:50:12', '2021-08-17 23:50:12');

-- ----------------------------
-- Table structure for t_friend
-- ----------------------------
DROP TABLE IF EXISTS `t_friend`;
CREATE TABLE `t_friend` (
  `f_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `web_site` varchar(255) DEFAULT NULL,
  `description` varchar(255) DEFAULT NULL,
  `is_rem` tinyint(1) NOT NULL,
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`f_id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_friend
-- ----------------------------
INSERT INTO `t_friend` VALUES ('1', '百度', 'http://www.baidu.com', '百度一下，你就知道！', '1', '2021-08-15 01:03:53');
INSERT INTO `t_friend` VALUES ('2', 'Google', 'http://www.google.com', '谷歌', '1', '2021-08-15 01:04:14');
INSERT INTO `t_friend` VALUES ('3', 'GitHub', 'http://www.github.com', 'GitHub仓库管理中心', '0', '2021-08-15 01:04:17');
INSERT INTO `t_friend` VALUES ('4', '百度', 'http://www.baidu.com', '百度一下，你就知道！', '1', '2021-08-15 01:49:09');
INSERT INTO `t_friend` VALUES ('5', '百度', 'http://www.baidu.com', '百度一下，你就知道！', '1', '2021-08-15 01:49:10');
INSERT INTO `t_friend` VALUES ('6', '百度', 'http://www.baidu.com', '百度一下，你就知道！', '1', '2021-08-15 01:49:11');
INSERT INTO `t_friend` VALUES ('7', '百度', 'http://www.baidu.com', '百度一下，你就知道！', '1', '2021-08-15 01:49:11');

-- ----------------------------
-- Table structure for t_tag
-- ----------------------------
DROP TABLE IF EXISTS `t_tag`;
CREATE TABLE `t_tag` (
  `tag_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=10 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_tag
-- ----------------------------
INSERT INTO `t_tag` VALUES ('1', 'Java', '2021-08-14 01:18:30', '2021-08-14 01:18:30');
INSERT INTO `t_tag` VALUES ('2', 'C语言', '2021-08-14 01:18:37', '2021-08-14 01:18:37');
INSERT INTO `t_tag` VALUES ('3', 'LeetCode', '2021-08-14 01:18:46', '2021-08-14 01:18:46');
INSERT INTO `t_tag` VALUES ('4', 'Spring', '2021-08-22 13:13:46', '2021-08-22 13:13:46');
INSERT INTO `t_tag` VALUES ('5', 'Spring MVC', '2021-08-22 13:13:51', '2021-08-22 13:13:51');
INSERT INTO `t_tag` VALUES ('6', 'MyBatis', '2021-08-22 13:13:55', '2021-08-22 13:13:55');
INSERT INTO `t_tag` VALUES ('7', 'Shiro', '2021-08-22 13:14:00', '2021-08-22 13:14:00');
INSERT INTO `t_tag` VALUES ('8', '框架', '2021-08-22 13:14:09', '2021-08-22 13:14:09');
INSERT INTO `t_tag` VALUES ('9', '笔记', '2021-08-22 13:14:29', '2021-08-22 13:14:29');

-- ----------------------------
-- Table structure for t_type
-- ----------------------------
DROP TABLE IF EXISTS `t_type`;
CREATE TABLE `t_type` (
  `type_id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`type_id`)
) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of t_type
-- ----------------------------
INSERT INTO `t_type` VALUES ('1', '编程语言', '2021-08-14 01:19:00', '2021-08-14 01:19:00');
INSERT INTO `t_type` VALUES ('2', '计算机网络', '2021-08-14 01:19:03', '2021-08-14 01:19:03');
INSERT INTO `t_type` VALUES ('3', '面试题', '2021-08-14 01:19:14', '2021-08-14 01:19:14');
INSERT INTO `t_type` VALUES ('4', '硬件', '2021-08-14 13:50:24', '2021-08-14 13:50:24');
INSERT INTO `t_type` VALUES ('5', 'Spring', '2021-08-22 13:13:16', '2021-08-22 13:13:16');
INSERT INTO `t_type` VALUES ('6', 'Maven', '2021-08-22 13:13:20', '2021-08-22 13:13:20');
INSERT INTO `t_type` VALUES ('7', 'Shiro', '2021-08-22 13:13:26', '2021-08-22 13:13:26');
INSERT INTO `t_type` VALUES ('8', 'MyBatis', '2021-08-22 13:13:35', '2021-08-22 13:13:35');
